<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>모의고사 전용도구</title>
  <link rel="stylesheet" href="styles-frame.css" />
  <link rel="stylesheet" href="nav-buttons.css" />
  <style>
    [hidden] {
      display: none !important;
    }

    *,
    *::before,
    *::after {
      -webkit-tap-highlight-color: transparent;
    }

    :root {
      --topbar-bg: #2e2b27;
      --topbar-border: #b08d57;
      --icon-ink: #f0e6d2;
      --icon-hover: #3a352f;
      --icon-active: #4a433a;

      --panel-bg: #0b0f16;
      --panel-border-a: #ffae42;
      --panel-border-b: #ffd27f;
      --combo-bg: #141c26;
      --combo-ink: #ffd27f;
      --combo-border: #ffae42;
      --combo-hover-bg: #1d2835;
      --button-ink: #0b0f16;

      --workspace-bg: #111722;
      --workspace-border: rgba(255, 210, 127, 0.22);
      --memo-font-size: 15px;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      background: #f0eee9;
    }

    .main-page {
      position: relative;
      width: min(1120px, 96vw);
      height: min(840px, 92vh);
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid rgba(0, 0, 0, 0.14);
      box-shadow: 0 12px 26px rgba(0, 0, 0, 0.14);
      background: #ddd7ca;
    }

    #cafe_int {
      position: absolute;
      inset: 12px;
      border-radius: 14px;
      overflow: hidden;
      background: linear-gradient(180deg, #f5efe2 0%, #e8dfcf 100%);
      border: 1px solid rgba(0, 0, 0, 0.18);
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      z-index: 1;
    }

    .exam-topbar {
      width: 100%;
      height: 60px;
      box-sizing: border-box;
      background: var(--topbar-bg);
      border-bottom: 2px solid var(--topbar-border);
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 10px 10px 20px;
      position: relative;
      z-index: 30;
    }

    .topbar-icon-btn {
      width: 45px;
      height: 45px;
      border-radius: 8px;
      border: none;
      background: transparent;
      color: var(--icon-ink);
      font-size: 20px;
      font-weight: 700;
      line-height: 1;
      cursor: pointer;
      transition: background 0.18s ease, box-shadow 0.18s ease;
      flex: 0 0 auto;
    }

    .topbar-icon-btn:hover {
      background: var(--icon-hover);
    }

    .topbar-icon-btn.is-active {
      background: var(--icon-active);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.2);
    }

    .topbar-save-btn {
      width: auto;
      min-width: 58px;
      padding: 0 12px;
      font-size: 12px;
      letter-spacing: 0.01em;
    }

    .topbar-submit-wrap {
      position: relative;
      flex: 0 0 auto;
    }

    .topbar-submit-wrap .topbar-save-btn {
      min-width: 74px;
    }

    .topbar-submit-menu {
      position: absolute;
      left: 0;
      top: 50px;
      z-index: 48;
      background: #2e2b27;
      border: 1px solid rgba(255, 255, 255, 0.58);
      border-radius: 8px;
      padding: 6px;
      display: grid;
      gap: 6px;
      min-width: 148px;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.32);
    }

    .topbar-submit-menu[hidden] {
      display: none;
    }

    .topbar-submit-option {
      border: none;
      border-radius: 6px;
      background: #4a463f;
      color: #f0e6d2;
      height: 32px;
      font-size: 12px;
      font-weight: 700;
      cursor: pointer;
      text-align: left;
      padding: 0 10px;
    }

    .topbar-submit-option:hover {
      background: #5c574e;
    }

    .topbar-submit-option:disabled {
      opacity: 0.5;
      cursor: default;
    }

    .topbar-save-btn.is-busy {
      background: rgba(255, 236, 191, 0.5);
      color: #5a4621;
    }

    .topbar-save-btn.is-ok {
      background: rgba(191, 255, 211, 0.52);
      color: #1f5a38;
    }

    .topbar-save-btn.is-error {
      background: rgba(255, 189, 189, 0.52);
      color: #6a2323;
    }

    .topbar-print-btn {
      min-width: 45px;
      width: 45px;
      padding: 0;
      font-size: 18px;
      line-height: 1;
    }

    .topbar-status {
      width: min(380px, 50vw);
      min-width: 210px;
      height: 45px;
      border-radius: 8px;
      border: 1px solid rgba(176, 141, 87, 0.7);
      background: linear-gradient(180deg, #fff0c8 0%, #f0d2a0 100%);
      color: #2e2b27;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      padding: 0 26px 0 10px;
      font-size: 11px;
      font-weight: 700;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      position: relative;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      outline: none;
    }

    .topbar-status::after {
      content: "▾";
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 10px;
      opacity: 0.75;
      pointer-events: none;
    }

    .topbar-status:hover {
      background: linear-gradient(180deg, #fff4d6 0%, #f4dbb1 100%);
    }

    .topbar-status.is-active {
      box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.45);
    }

    .topbar-status.is-local-draft {
      border-color: rgba(176, 128, 12, 0.9);
      background: linear-gradient(180deg, #ffe56e 0%, #ffca45 100%);
      color: #3e2f0f;
      box-shadow: inset 0 0 0 1px rgba(255, 248, 210, 0.8);
    }

    .topbar-status.is-local-draft:hover {
      background: linear-gradient(180deg, #ffeb89 0%, #ffd568 100%);
    }

    .topbar-status-writing {
      flex: 0 0 auto;
      font-size: 14px;
      font-weight: 900;
      letter-spacing: 0.01em;
    }

    .topbar-status-sep {
      flex: 0 0 auto;
      margin: 0 4px;
      opacity: 0.64;
      font-weight: 700;
    }

    .topbar-status-main {
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 11px;
      font-weight: 500;
    }

    .topbar-spacer {
      flex: 1;
      min-width: 0;
    }

    .topbar-power-btn {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.65);
      background: var(--topbar-bg);
      color: var(--icon-ink);
      font-size: 16px;
      font-weight: 800;
      cursor: pointer;
      flex: 0 0 auto;
    }

    .pdf-picker-backdrop {
      position: absolute;
      inset: 60px 0 0;
      z-index: 40;
      background: transparent;
    }

    .pdf-picker-popup {
      position: absolute;
      top: 68px;
      left: 20px;
      right: 20px;
      z-index: 45;
    }

    .session-picker-backdrop {
      position: absolute;
      inset: 60px 0 0;
      z-index: 46;
      background: transparent;
    }

    .session-picker-popup {
      position: absolute;
      top: 68px;
      right: 18px;
      width: min(430px, calc(100% - 36px));
      z-index: 48;
    }

    .session-picker-card {
      width: 100%;
      box-sizing: border-box;
      border-radius: 12px;
      border: 1px solid rgba(176, 141, 87, 0.7);
      background:
        radial-gradient(220px 100px at 8% -20%, rgba(255, 189, 216, 0.45), transparent 70%),
        radial-gradient(280px 120px at 100% 125%, rgba(255, 225, 166, 0.32), transparent 75%),
        linear-gradient(180deg, #fff8ed 0%, #ffefd8 100%);
      box-shadow: 0 10px 22px rgba(24, 20, 16, 0.24);
      overflow: hidden;
    }

    .session-picker-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(86, 74, 55, 0.2);
      background: linear-gradient(180deg, rgba(255, 238, 206, 0.95) 0%, rgba(255, 226, 177, 0.9) 100%);
    }

    .session-picker-tabs {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      min-width: 0;
      flex: 1;
    }

    .session-picker-tab {
      height: 30px;
      border: 1px solid rgba(117, 90, 58, 0.34);
      border-radius: 9px;
      background: rgba(255, 251, 241, 0.82);
      color: rgba(64, 48, 33, 0.78);
      font-size: 11px;
      font-weight: 800;
      letter-spacing: 0.02em;
      padding: 0 12px;
      cursor: pointer;
      transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease;
    }

    .session-picker-tab:hover {
      background: rgba(255, 248, 232, 0.98);
      border-color: rgba(117, 90, 58, 0.48);
    }

    .session-picker-tab.is-active {
      background: linear-gradient(180deg, #fff0cc 0%, #ffd98b 100%);
      border-color: rgba(153, 108, 52, 0.72);
      color: #4b321d;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.62);
    }

    .session-picker-sub {
      color: rgba(77, 59, 43, 0.75);
      font-size: 10px;
      font-weight: 600;
      flex: 0 0 auto;
      white-space: nowrap;
    }

    .session-picker-list {
      max-height: min(46vh, 360px);
      overflow: auto;
      padding: 10px;
      box-sizing: border-box;
      display: grid;
      gap: 8px;
    }

    .session-item-btn {
      width: 100%;
      border-radius: 10px;
      border: 1px solid rgba(126, 104, 76, 0.25);
      background: rgba(255, 255, 255, 0.72);
      cursor: pointer;
      text-align: left;
      padding: 9px 10px;
      box-sizing: border-box;
      transition: border-color 0.16s ease, transform 0.16s ease, background 0.16s ease;
      position: relative;
      overflow: hidden;
    }

    .session-item-btn.has-ribbon {
      padding-right: 132px;
    }

    .session-item-btn:hover {
      border-color: rgba(255, 158, 98, 0.7);
      background: rgba(255, 250, 242, 0.98);
      transform: translateY(-1px);
    }

    .session-item-btn.is-selected {
      border-color: rgba(255, 154, 76, 0.95);
      background:
        linear-gradient(180deg, rgba(255, 236, 210, 0.98) 0%, rgba(255, 226, 191, 0.98) 100%);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.66);
    }

    .session-item-btn.is-disabled {
      cursor: default;
      opacity: 0.72;
      border-color: rgba(114, 97, 78, 0.18);
      background: rgba(248, 243, 236, 0.86);
    }

    .session-item-btn.is-disabled:hover {
      transform: none;
      border-color: rgba(114, 97, 78, 0.18);
      background: rgba(248, 243, 236, 0.86);
    }

    .session-item-title {
      color: #443425;
      font-size: 12px;
      font-weight: 800;
      line-height: 1.35;
    }

    .session-item-meta {
      margin-top: 3px;
      color: rgba(58, 44, 30, 0.88);
      font-size: 11px;
      font-weight: 700;
      line-height: 1.4;
    }

    .session-item-note {
      margin-top: 4px;
      color: rgba(64, 48, 33, 0.7);
      font-size: 10px;
      line-height: 1.3;
    }

    .session-item-qno {
      position: absolute;
      right: 138px;
      top: 24px;
      min-width: 56px;
      display: inline-flex;
      align-items: baseline;
      justify-content: flex-end;
      gap: 3px;
      text-align: right;
      color: rgba(80, 54, 35, 0.92);
      letter-spacing: 0.01em;
      line-height: 1;
      white-space: nowrap;
      text-shadow: 0 1px 0 rgba(255, 255, 255, 0.48);
      pointer-events: none;
    }

    .session-item-qno-prefix {
      font-size: 18px;
      font-weight: 900;
      letter-spacing: 0.01em;
    }

    .session-item-qno-value {
      font-size: 16px;
      font-weight: 800;
      letter-spacing: 0;
    }

    .session-item-qno.is-empty {
      color: rgba(93, 73, 55, 0.54);
    }

    .session-item-ribbon {
      position: absolute;
      top: 10px;
      right: -28px;
      width: 112px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: 900;
      letter-spacing: 0.02em;
      color: #fffdf8;
      transform: rotate(34deg);
      transform-origin: center;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.22);
      pointer-events: none;
      border-radius: 999px;
      text-shadow: 0 1px 0 rgba(0, 0, 0, 0.18);
    }

    .session-item-ribbon.is-afterclass {
      background: linear-gradient(180deg, #9a6b3a 0%, #7a4f25 100%);
    }

    .session-item-ribbon.is-solo {
      background: linear-gradient(180deg, #35b86f 0%, #1f9656 100%);
    }

    .session-item-ribbon.is-submitted {
      background: linear-gradient(180deg, #35b86f 0%, #1f9656 100%);
    }

    .session-item-ribbon.is-secondary {
      top: 30px;
      right: -24px;
      width: 104px;
      opacity: 0.96;
    }

    .session-load-more-btn {
      text-align: center;
      font-weight: 800;
      color: #4d3b2b;
      background: rgba(255, 242, 217, 0.86);
    }

    .mini-confirm-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(20, 16, 11, 0.12);
      z-index: 260;
    }

    .mini-confirm-popup {
      position: fixed;
      inset: 0;
      z-index: 261;
      display: grid;
      place-items: center;
      padding: 16px;
      box-sizing: border-box;
    }

    .mini-confirm-card {
      width: min(320px, calc(100vw - 28px));
      border-radius: 12px;
      border: 1px solid rgba(176, 141, 87, 0.84);
      background: linear-gradient(180deg, #3b342c 0%, #2e2923 100%);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.18), inset 0 0 0 1px rgba(255, 255, 255, 0.06);
      padding: 14px;
      box-sizing: border-box;
      display: grid;
      gap: 12px;
    }

    .mini-confirm-text {
      font-size: 13px;
      font-weight: 800;
      color: var(--icon-ink);
      line-height: 1.4;
      text-align: center;
    }

    .mini-confirm-actions {
      display: flex;
      justify-content: center;
      gap: 8px;
    }

    .mini-confirm-btn {
      min-width: 84px;
      height: 34px;
      border-radius: 8px;
      border: 1px solid rgba(176, 141, 87, 0.44);
      cursor: pointer;
      font-size: 12px;
      font-weight: 800;
      transition: filter 0.14s ease, transform 0.14s ease;
    }

    .mini-confirm-btn:hover {
      filter: brightness(1.05);
      transform: translateY(-1px);
    }

    .mini-confirm-btn--cancel {
      background: #4a433a;
      color: #f0e6d2;
    }

    .mini-confirm-btn--ok {
      background: linear-gradient(180deg, #dbc087 0%, #c49a59 100%);
      color: #2e2b27;
    }

    .submit-toast {
      position: fixed;
      left: 50%;
      bottom: 26px;
      transform: translateX(-50%) translateY(10px) scale(0.96);
      opacity: 0;
      min-width: 168px;
      max-width: min(92vw, 360px);
      border-radius: 999px;
      padding: 10px 14px;
      box-sizing: border-box;
      border: 1px solid rgba(171, 128, 61, 0.9);
      background: linear-gradient(180deg, #fff4cf 0%, #ffd98f 100%);
      color: #3f2f1c;
      font-size: 13px;
      font-weight: 900;
      text-align: center;
      box-shadow: 0 10px 18px rgba(24, 16, 8, 0.18), inset 0 1px 0 rgba(255, 255, 255, 0.65);
      pointer-events: none;
      z-index: 320;
    }

    .submit-toast::before {
      content: "✦ ";
      color: #8f6130;
      font-weight: 900;
    }

    .submit-toast.is-show {
      animation: submit-toast-in 0.22s ease-out forwards, submit-toast-out 0.28s ease-in forwards 1.6s;
    }

    @keyframes submit-toast-in {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(10px) scale(0.96);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0) scale(1);
      }
    }

    @keyframes submit-toast-out {
      from {
        opacity: 1;
        transform: translateX(-50%) translateY(0) scale(1);
      }
      to {
        opacity: 0;
        transform: translateX(-50%) translateY(10px) scale(0.98);
      }
    }

    .pdf-picker-wrap {
      width: 100%;
      margin: 0;
      box-sizing: border-box;
      background: var(--panel-bg);
      border: 2px solid transparent;
      border-radius: 10px;
      background-image:
        linear-gradient(var(--panel-bg), var(--panel-bg)),
        linear-gradient(135deg, var(--panel-border-a) 0%, var(--panel-border-b) 48%, var(--panel-border-a) 100%);
      background-origin: border-box;
      background-clip: padding-box, border-box;
      padding: 8px;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
    }

    @media (min-width: 860px) {
      .pdf-picker-wrap {
        grid-template-columns: repeat(5, minmax(0, 1fr));
      }

      .pdf-open-btn {
        grid-column: auto;
      }
    }

    .pdf-picker-wrap select {
      width: 100%;
      height: 34px;
      border-radius: 6px;
      border: 1px solid var(--combo-border);
      background: var(--combo-bg);
      color: var(--combo-ink);
      font-size: 12px;
      font-weight: 700;
      padding: 0 8px;
      box-sizing: border-box;
      outline: none;
    }

    .pdf-picker-wrap select:hover {
      background: var(--combo-hover-bg);
      border-color: var(--panel-border-b);
    }

    .pdf-open-btn {
      grid-column: span 2;
      height: 34px;
      border-radius: 6px;
      border: 1px solid var(--combo-border);
      background: linear-gradient(135deg, #ffd27f 0%, #ffae42 100%);
      color: var(--button-ink);
      font-size: 13px;
      font-weight: 800;
      cursor: pointer;
    }

    .pdf-open-btn:hover {
      background: linear-gradient(135deg, #fff0b3 0%, #ffcf70 100%);
    }

    .workspace {
      width: calc(100% - 24px);
      flex: 1;
      margin: 12px auto 14px;
      border-radius: 12px;
      border: 1px solid var(--workspace-border);
      background:
        radial-gradient(130px 70px at 15% 15%, rgba(255, 210, 127, 0.16), transparent 75%),
        radial-gradient(220px 120px at 88% 98%, rgba(255, 174, 66, 0.11), transparent 75%),
        var(--workspace-bg);
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      color: #ebd9a7;
      text-align: center;
      padding: 14px;
      position: relative;
    }

    .workspace--has-pdf {
      justify-content: flex-start;
      align-items: stretch;
      gap: 0;
      padding: 10px;
    }

    .pdf-preview {
      width: 100%;
      height: 100%;
      flex: 1;
      min-height: 0;
      border: 1px solid rgba(255, 210, 127, 0.35);
      border-radius: 10px;
      background: #101722;
      overflow: hidden;
      position: relative;
      touch-action: pan-y;
    }

    .pdf-pages {
      width: 100%;
      height: 100%;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 10px 0 16px;
      box-sizing: border-box;
      position: relative;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
      touch-action: pan-y;
    }

    .pdf-page {
      position: relative;
      width: fit-content;
      margin: 0 auto 12px;
      background: #fff;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.16);
    }

    .pdf-page canvas {
      display: block;
      width: 100%;
      height: auto;
      background: #fff;
      touch-action: pan-y;
      cursor: default;
      image-rendering: auto;
    }

    .pdf-text-layer {
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      line-height: 1;
      user-select: none;
      -webkit-user-select: none;
      touch-action: pan-y;
      pointer-events: auto;
    }

    .pdf-text-layer span {
      color: transparent;
      position: absolute;
      white-space: pre;
      cursor: default;
      transform-origin: 0 0;
      touch-action: pan-y;
      -webkit-tap-highlight-color: transparent;
      pointer-events: none;
    }

    .pdf-text-layer span:hover {
      background: rgba(255, 204, 112, 0.34);
    }

    .pdf-text-layer ::selection {
      background: rgba(255, 183, 85, 0.55);
    }

    .pdf-preview iframe {
      width: 100%;
      height: 100%;
      border: none;
      background: #101722;
      position: absolute;
      inset: 0;
      touch-action: pan-y;
      -webkit-overflow-scrolling: touch;
    }

    .pdf-word-tooltip {
      position: fixed;
      z-index: 220;
      max-width: min(300px, 72vw);
      background: rgba(17, 14, 11, 0.94);
      color: #fff1cf;
      border: 1px solid rgba(255, 192, 102, 0.72);
      border-radius: 8px;
      padding: 6px 8px;
      box-sizing: border-box;
      font-size: 12px;
      line-height: 1.4;
      box-shadow: 0 5px 16px rgba(0, 0, 0, 0.26);
      pointer-events: none;
      opacity: 0;
      transform: translateY(2px);
      transition: opacity 0.1s ease, transform 0.1s ease;
      white-space: pre-wrap;
    }

    .pdf-word-tooltip.is-visible {
      opacity: 1;
      transform: translateY(0);
    }

    .overlay-memo {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      width: 50%;
      min-width: 320px;
      z-index: 90;
      display: flex;
      flex-direction: column;
      background: rgba(255, 255, 255, 0.98);
      border-left: 2px solid #b08d57;
      border-right: 2px solid #b08d57;
      box-sizing: border-box;
      transform: translateX(102%);
      opacity: 0;
      pointer-events: none;
      transition: transform 0.2s ease, opacity 0.2s ease;
    }

    .overlay-memo.is-left {
      left: 0;
      right: auto;
      transform: translateX(-102%);
    }

    .overlay-memo.is-open {
      transform: translateX(0);
      opacity: 1;
      pointer-events: auto;
    }

    .overlay-memo-topbar {
      height: 70px;
      background-color: #2e2b27;
      border-bottom: 2px solid #b08d57;
      color: #f0e6d2;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 10px;
      box-sizing: border-box;
      flex: 0 0 auto;
    }

    .overlay-memo-title {
      font-size: 20px;
      font-weight: 700;
      letter-spacing: 0.01em;
      color: #f0e6d2;
      margin-right: 6px;
      white-space: nowrap;
    }

    .overlay-memo-close {
      width: 24px;
      height: 24px;
      border: none;
      background: transparent;
      color: #f0e6d2;
      font-size: 16px;
      cursor: pointer;
      flex: 0 0 auto;
      padding: 0;
    }

    .overlay-memo-close:hover {
      color: #ff6666;
    }

    .overlay-memo-topbar-spacer {
      flex: 1;
      min-width: 0;
    }

    .overlay-memo-tool-btn {
      height: 32px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.24);
      background-color: #4a463f;
      color: #f0e6d2;
      font-size: 13px;
      font-weight: 700;
      padding: 0 10px;
      cursor: pointer;
      flex: 0 0 auto;
    }

    .overlay-memo-tool-btn:hover {
      background-color: #5c574e;
    }

    .overlay-mini-popup {
      position: absolute;
      top: 76px;
      right: 12px;
      z-index: 8;
      background: #2e2b27;
      border: 1px solid rgba(255, 255, 255, 0.58);
      border-radius: 8px;
      padding: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.32);
    }

    .overlay-mini-popup[hidden] {
      display: none;
    }

    .overlay-mini-step-btn {
      width: 30px;
      height: 30px;
      border: none;
      border-radius: 6px;
      background: #4a463f;
      color: #f0e6d2;
      font-size: 17px;
      cursor: pointer;
      padding: 0;
    }

    .overlay-mini-step-btn:hover {
      background: #5c574e;
    }

    .overlay-font-size-value {
      min-width: 46px;
      text-align: center;
      font-size: 12px;
      font-weight: 700;
      color: #f0e6d2;
      letter-spacing: 0.01em;
    }

    .overlay-memo-body {
      flex: 1;
      min-height: 0;
      background-color: #fdf3e7;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    .overlay-question-bar {
      flex: 0 0 auto;
      height: 30px;
      display: flex;
      align-items: center;
      padding: 0 12px;
      box-sizing: border-box;
      border-bottom: 1px solid rgba(42, 28, 20, 0.35);
      background:
        linear-gradient(180deg, rgba(114, 77, 54, 0.96) 0%, rgba(83, 56, 39, 0.96) 100%);
      color: #f6ebdd;
      font-size: 12px;
      font-weight: 800;
      letter-spacing: 0.015em;
      text-shadow: 0 1px 0 rgba(0, 0, 0, 0.28);
    }

    .overlay-pane {
      flex: 1;
      min-height: 0;
      width: 100%;
      display: flex;
    }

    .overlay-pane[hidden] {
      display: none;
    }

    .overlay-blank-pane {
      position: relative;
      overflow: hidden;
      background: #fdf3e7;
    }

    .overlay-blank-controls {
      position: absolute;
      top: 8px;
      right: 10px;
      z-index: 6;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .overlay-blank-tool-btn {
      height: 28px;
      border-radius: 8px;
      border: 1px solid rgba(46, 43, 39, 0.26);
      background: rgba(255, 255, 255, 0.92);
      color: #2e2b27;
      font-size: 11px;
      font-weight: 700;
      padding: 0 10px;
      cursor: pointer;
      box-sizing: border-box;
      transition: background 0.14s ease, border-color 0.14s ease;
      line-height: 1;
    }

    .overlay-blank-tool-btn:hover {
      background: #fff6e7;
      border-color: rgba(46, 43, 39, 0.4);
    }

    .overlay-blank-tool-btn.is-on {
      background: linear-gradient(180deg, #ffe09a 0%, #f4bf5a 100%);
      border-color: rgba(141, 95, 28, 0.72);
      color: #2c2217;
    }

    .overlay-blank-tool-btn:disabled {
      opacity: 0.5;
      cursor: default;
    }

    .overlay-memo-textarea {
      flex: 1;
      min-height: 0;
      width: 100%;
      box-sizing: border-box;
      resize: none;
      border: none;
      outline: none;
      padding: 12px;
      font-size: var(--memo-font-size);
      line-height: 1.45;
      background: #fdf3e7;
      color: #2e2b27;
      font-family: "Malgun Gothic", "Apple SD Gothic Neo", sans-serif;
      padding-top: 44px;
    }

    .overlay-memo-textarea::placeholder {
      color: rgba(46, 43, 39, 0.38);
    }

    .overlay-blank-pane.is-pen-mode .overlay-memo-textarea {
      display: none;
    }

    .overlay-blank-draw-wrap {
      position: absolute;
      inset: 0;
      z-index: 4;
      background: #fdf3e7;
      border-top: 1px solid rgba(46, 43, 39, 0.08);
      touch-action: none;
    }

    .overlay-blank-draw-wrap[hidden] {
      display: none;
    }

    .overlay-blank-draw-canvas {
      width: 100%;
      height: 100%;
      display: block;
      background:
        linear-gradient(180deg, rgba(140, 116, 86, 0.06) 0, rgba(140, 116, 86, 0.06) 1px, transparent 1px, transparent 34px);
      background-size: 100% 34px;
      cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='18' height='18' viewBox='0 0 18 18'%3E%3Cpath d='M2 16l3.2-.8 8.6-8.6-2.4-2.4-8.6 8.6L2 16z' fill='%232f2a24' stroke='%23f4c36d' stroke-width='.8'/%3E%3Cpath d='M11.4 2.2l2.4 2.4 1.2-1.2c.7-.7.7-1.8 0-2.5-.7-.7-1.8-.7-2.5 0l-1.1 1.3z' fill='%23463b2c'/%3E%3C/svg%3E") 2 16, pointer;
      touch-action: none;
    }

    .overlay-two-three {
      display: grid;
      grid-template-columns: 3fr 7fr;
      gap: 0;
      width: 100%;
      height: 100%;
      position: relative;
    }

    .overlay-two-three.is-flipped {
      grid-template-columns: 7fr 3fr;
    }

    .overlay-two-col {
      display: flex;
      flex-direction: column;
      min-height: 0;
      overflow: hidden;
    }

    .overlay-two-col--twoT {
      background: #fdf3e7;
      color: #2e2b27;
    }

    .overlay-two-col--threeT {
      background: #463b2c;
      color: #f7f2e8;
      border-left: 1px solid rgba(42, 30, 23, 0.95);
    }

    .overlay-two-three.is-flipped .overlay-two-col--threeT {
      border-left: none;
      border-right: 1px solid rgba(42, 30, 23, 0.95);
      order: 1;
    }

    .overlay-two-three.is-flipped .overlay-two-col--twoT {
      order: 2;
    }

    .overlay-two-head {
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 0 8px;
      font-size: 11px;
      font-weight: 700;
      border-bottom: 1px solid rgba(42, 30, 23, 0.25);
      box-sizing: border-box;
    }

    .overlay-two-head-label {
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .overlay-two-head-toggle {
      height: 24px;
      min-width: 70px;
      border-radius: 8px;
      border: 1px solid rgba(120, 84, 39, 0.58);
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.42) 0%, rgba(255, 255, 255, 0.06) 42%, rgba(0, 0, 0, 0.06) 100%),
        linear-gradient(180deg, #fff2ce 0%, #e8c788 100%);
      color: #3b2c22;
      font-size: 10px;
      font-weight: 800;
      letter-spacing: 0.01em;
      cursor: pointer;
      flex: 0 0 auto;
      padding: 0 10px;
      box-sizing: border-box;
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.58),
        0 1px 2px rgba(0, 0, 0, 0.22);
      transition: filter 0.16s ease, transform 0.16s ease;
    }

    .overlay-two-head-toggle:hover {
      filter: brightness(1.05);
    }

    .overlay-two-head-toggle.is-on {
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.36) 0%, rgba(255, 255, 255, 0.04) 40%, rgba(0, 0, 0, 0.08) 100%),
        linear-gradient(180deg, #ffd97d 0%, #f0b145 100%);
      border-color: #ad6f1d;
      color: #2f241a;
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.48),
        0 1px 3px rgba(0, 0, 0, 0.3);
    }

    .overlay-two-col--threeT .overlay-two-head {
      border-bottom-color: rgba(247, 242, 232, 0.18);
    }

    .overlay-three-head-tools {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      flex: 0 0 auto;
    }

    .overlay-three-head-pen-toggle {
      height: 24px;
      min-width: 56px;
      border-radius: 8px;
      border: 1px solid rgba(247, 242, 232, 0.26);
      background: rgba(77, 65, 50, 0.92);
      color: #f2e8d4;
      font-size: 10px;
      font-weight: 800;
      cursor: pointer;
      padding: 0 9px;
      box-sizing: border-box;
      flex: 0 0 auto;
    }

    .overlay-three-head-pen-toggle:hover {
      background: rgba(94, 80, 62, 0.95);
    }

    .overlay-three-head-pen-toggle.is-on {
      background: linear-gradient(180deg, #ffd27c 0%, #f2b14d 100%);
      border-color: rgba(156, 102, 24, 0.76);
      color: #2c2116;
    }

    .overlay-three-head-pen-toggle:disabled {
      opacity: 0.44;
      cursor: default;
    }

    .overlay-three-head-clear-btn {
      height: 24px;
      min-width: 56px;
      border-radius: 8px;
      border: 1px solid rgba(247, 242, 232, 0.24);
      background: rgba(71, 59, 46, 0.9);
      color: #f2e8d4;
      font-size: 10px;
      font-weight: 800;
      cursor: pointer;
      padding: 0 9px;
      box-sizing: border-box;
      flex: 0 0 auto;
    }

    .overlay-three-head-clear-btn:hover {
      background: rgba(90, 74, 58, 0.94);
    }

    .overlay-three-head-clear-btn:disabled {
      opacity: 0.38;
      cursor: default;
    }

    .overlay-two-col--threeT .overlay-two-head.is-dict-mode {
      background: linear-gradient(180deg, #15120f 0%, #090807 100%);
      color: #f4e9cc;
      border-bottom-color: rgba(244, 233, 204, 0.22);
      text-shadow: 0 1px 0 rgba(0, 0, 0, 0.52);
    }

    .overlay-two-scroll {
      flex: 1;
      min-height: 0;
      width: 100%;
      overflow-y: auto;
      box-sizing: border-box;
      padding: 8px 8px 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: stretch;
    }

    #mock-overlay-two-right-list {
      padding-right: 16px;
    }

    .overlay-two-scroll::-webkit-scrollbar {
      width: 8px;
    }

    .overlay-two-scroll::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 999px;
    }

    .overlay-dict-panel {
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
      background: #17120e;
    }

    .overlay-dict-panel:not([hidden]) {
      animation: overlay-dict-slide-up 0.24s ease-out;
    }

    @keyframes overlay-dict-slide-up {
      from {
        opacity: 0;
        transform: translateY(16px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .overlay-dict-toolbar {
      height: 30px;
      border-bottom: 1px solid rgba(247, 242, 232, 0.18);
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 0 8px;
      box-sizing: border-box;
      background: rgba(20, 14, 10, 0.86);
    }

    .overlay-dict-current {
      flex: 1;
      min-width: 0;
      font-size: 10px;
      color: rgba(247, 242, 232, 0.86);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .overlay-dict-open {
      height: 22px;
      border-radius: 999px;
      border: 1px solid rgba(247, 242, 232, 0.28);
      background: #4a463f;
      color: #f0e6d2;
      font-size: 10px;
      font-weight: 700;
      padding: 0 8px;
      cursor: pointer;
      flex: 0 0 auto;
    }

    .overlay-dict-open:disabled {
      opacity: 0.42;
      cursor: default;
    }

    .overlay-dict-zoom-btn {
      width: 22px;
      height: 22px;
      border-radius: 6px;
      border: 1px solid rgba(247, 242, 232, 0.24);
      background: rgba(87, 78, 67, 0.96);
      color: #f0e6d2;
      font-size: 13px;
      font-weight: 700;
      cursor: pointer;
      padding: 0;
      line-height: 1;
      flex: 0 0 auto;
    }

    .overlay-dict-zoom-btn:hover {
      background: rgba(106, 95, 82, 0.98);
    }

    .overlay-dict-zoom-value {
      min-width: 36px;
      text-align: center;
      font-size: 10px;
      color: rgba(247, 242, 232, 0.92);
      font-weight: 700;
      letter-spacing: 0.01em;
      flex: 0 0 auto;
    }

    .overlay-dict-frame {
      width: 100%;
      flex: 1;
      min-height: 0;
      border: none;
      background: #fff;
    }

    .overlay-card {
      border-radius: 8px;
      overflow: hidden;
      box-sizing: border-box;
      flex: 0 0 auto;
      width: 100%;
    }

    .overlay-card--twoT {
      background: #f3e5bb;
      border: 2px solid #d6b97f;
      min-height: 84px;
    }

    .overlay-card--twoT.is-captured {
      border-color: #efaf47;
      box-shadow: 0 0 0 2px rgba(239, 175, 71, 0.26);
    }

    .overlay-card--threeT {
      background: #3b2a1f;
      border: 1px solid #2a1e17;
      min-height: 86px;
    }

    .overlay-two-three.is-three-pen-mode .overlay-card--threeT {
      min-height: 212px;
    }

    .overlay-card-inner {
      box-sizing: border-box;
      padding: 7px;
      display: grid;
      gap: 7px;
    }

    .overlay-card-inner--twoT {
      background: linear-gradient(180deg, #fff6d6 0%, #edd8a2 100%);
      border: 1px solid #e4c98e;
      border-radius: 6px;
    }

    .overlay-card-inner--threeT {
      background: #3f2d22;
      border: 1px solid #201711;
      border-radius: 5px;
    }

    .overlay-card-row {
      display: flex;
      align-items: flex-start;
      gap: 6px;
    }

    .overlay-card-row--threeT {
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 2px;
    }

    .overlay-three-card-tools {
      margin-left: auto;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      flex: 0 0 auto;
    }

    .overlay-three-card-tool-btn {
      height: 20px;
      min-width: 44px;
      border-radius: 6px;
      border: 1px solid rgba(247, 242, 232, 0.3);
      background: rgba(76, 62, 48, 0.92);
      color: #f6ead5;
      font-size: 9px;
      font-weight: 800;
      padding: 0 6px;
      cursor: pointer;
      box-sizing: border-box;
      line-height: 1;
    }

    .overlay-three-card-tool-btn:hover {
      background: rgba(96, 79, 61, 0.96);
    }

    .overlay-card-row .overlay-card-input,
    .overlay-card-row .overlay-card-textarea {
      flex: 1;
      min-width: 0;
      width: 100%;
      max-width: 100%;
    }

    .overlay-card-row--twoT {
      display: grid;
      grid-template-columns: 14px minmax(0, 1fr);
      align-items: center;
      gap: 6px;
    }

    .overlay-card-index {
      flex: 0 0 auto;
      min-width: 20px;
      height: 20px;
      border-radius: 4px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: 800;
      letter-spacing: 0.02em;
    }

    .overlay-card-index--twoT {
      background: rgba(42, 30, 23, 0.08);
      color: #2e2b27;
      border: 1px solid rgba(42, 30, 23, 0.2);
      min-width: 12px;
      width: 12px;
      height: 12px;
      font-size: 8px;
      border-radius: 3px;
    }

    .overlay-card-index--threeT {
      background: #2a1e17;
      color: #f7f2e8;
      border: 1px solid #1b130e;
    }

    .overlay-card-input,
    .overlay-card-textarea {
      border: none;
      outline: none;
      box-sizing: border-box;
      font-family: "Malgun Gothic", "Apple SD Gothic Neo", sans-serif;
      font-size: var(--memo-font-size);
      width: 100%;
      max-width: 100%;
    }

    .overlay-card-input {
      height: 30px;
      border-radius: 5px;
      padding: 3px 6px;
    }

    .overlay-card-textarea {
      min-height: 48px;
      border-radius: 5px;
      padding: 5px 6px;
      resize: vertical;
      line-height: 1.45;
    }

    .overlay-card-input--twoT,
    .overlay-card-textarea--twoT {
      background: #fff9e9;
      color: #2e2b27;
      border: 1px solid #d6b97f;
      font-size: calc(var(--memo-font-size) - 1px) !important;
      line-height: 1.35;
    }

    .overlay-card-input--twoT {
      height: 32px !important;
      padding: 3px 8px !important;
    }

    .overlay-card-textarea--twoT {
      min-height: 44px !important;
      padding: 5px 8px !important;
      resize: vertical;
    }

    .overlay-card-textarea--threeT {
      min-height: 30px;
      padding: 5px 6px;
      resize: vertical;
    }

    .overlay-card-textarea--threeT-sentence {
      min-height: 32px !important;
      max-height: 90px;
    }

    .overlay-two-three.is-three-pen-mode .overlay-card-textarea--threeT-sentence {
      display: none;
      min-height: 68px !important;
      max-height: 180px;
    }

    .overlay-card-input--threeT,
    .overlay-card-textarea--threeT {
      background: #2f221a;
      color: #f7f2e8;
      border: 1px solid #1c140f;
    }

    .overlay-card-input--threeT::placeholder,
    .overlay-card-textarea--threeT::placeholder {
      color: rgba(247, 242, 232, 0.45);
    }

    .overlay-card-input--twoT::placeholder,
    .overlay-card-textarea--twoT::placeholder {
      color: rgba(46, 43, 39, 0.38);
    }

    .overlay-three-ink-wrap {
      margin-top: 6px;
      height: 86px;
      border: 1px solid rgba(247, 242, 232, 0.26);
      border-radius: 6px;
      background: rgba(246, 239, 225, 0.06);
      overflow: hidden;
      touch-action: none;
      display: none;
      position: relative;
    }

    .overlay-two-three.is-three-pen-mode .overlay-three-ink-wrap {
      display: block;
      margin-top: 0;
      height: 182px;
    }

    .overlay-three-ink-canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
      cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='18' height='18' viewBox='0 0 18 18'%3E%3Cpath d='M2 16l3.2-.8 8.6-8.6-2.4-2.4-8.6 8.6L2 16z' fill='%23f7f2e8' stroke='%233b2a1f' stroke-width='.8'/%3E%3Cpath d='M11.4 2.2l2.4 2.4 1.2-1.2c.7-.7.7-1.8 0-2.5-.7-.7-1.8-.7-2.5 0l-1.1 1.3z' fill='%23f2b14d'/%3E%3C/svg%3E") 2 16, pointer;
      background:
        linear-gradient(180deg, rgba(244, 230, 205, 0.06) 0, rgba(244, 230, 205, 0.06) 1px, transparent 1px, transparent 26px);
      background-size: 100% 26px;
    }

    .overlay-side-flip {
      position: absolute;
      top: 50%;
      left: -12px;
      width: 12px;
      height: 44px;
      transform: translateY(-50%);
      border: none;
      background: #d6b97f;
      clip-path: polygon(100% 0, 0 50%, 100% 100%);
      cursor: pointer;
      padding: 0;
      z-index: 95;
      opacity: 0.94;
    }

    .overlay-side-flip:hover {
      background: #c4a96b;
      opacity: 1;
    }

    .overlay-memo.is-left .overlay-side-flip {
      left: auto;
      right: -12px;
      transform: translateY(-50%) rotate(180deg);
    }

    .overlay-memo-tabbar {
      height: 42px;
      background-color: #2e2b27;
      border-top: 2px solid #b08d57;
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 5px;
      box-sizing: border-box;
      flex: 0 0 auto;
    }

    .overlay-tab-list {
      display: flex;
      align-items: center;
      gap: 5px;
      min-width: 0;
      overflow-x: auto;
      flex: 1;
    }

    .overlay-tab-list::-webkit-scrollbar {
      height: 6px;
    }

    .overlay-tab-list::-webkit-scrollbar-thumb {
      background: rgba(240, 230, 210, 0.35);
      border-radius: 999px;
    }

    .overlay-tab-item {
      display: inline-flex;
      align-items: center;
      flex: 0 0 auto;
      gap: 0;
    }

    .overlay-tab-btn {
      width: 30px;
      height: 30px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 700;
    }

    .overlay-tab-btn.is-active {
      background-color: #2e2b27;
      color: #f0e6d2;
    }

    .overlay-tab-btn.is-active:hover {
      background-color: #3a3733;
    }

    .overlay-tab-btn.is-inactive {
      background-color: #4a463f;
      color: #d0c9b9;
    }

    .overlay-tab-btn.is-inactive:hover {
      background-color: #5c574e;
      color: #f0e6d2;
    }

    .overlay-tab-close {
      width: 20px;
      height: 30px;
      border: none;
      background: transparent;
      color: #f0e6d2;
      cursor: pointer;
      font-size: 12px;
      padding: 0;
    }

    .overlay-tab-close:hover {
      color: #ff6666;
    }

    .overlay-tab-add {
      width: 32px;
      height: 30px;
      border: none;
      border-radius: 6px;
      background-color: #4a463f;
      color: #f0e6d2;
      font-size: 17px;
      line-height: 1;
      cursor: pointer;
      flex: 0 0 auto;
    }

    .overlay-tab-add:hover {
      background-color: #5c574e;
    }

    .overlay-tab-type-popup {
      position: absolute;
      right: 10px;
      bottom: 52px;
      z-index: 8;
      background: #2e2b27;
      border: 1px solid rgba(255, 255, 255, 0.58);
      border-radius: 8px;
      padding: 6px;
      display: grid;
      gap: 6px;
      min-width: 164px;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.32);
    }

    .overlay-tab-type-popup[hidden] {
      display: none;
    }

    .overlay-type-option {
      border: none;
      border-radius: 6px;
      background: #4a463f;
      color: #f0e6d2;
      height: 32px;
      font-size: 12px;
      font-weight: 700;
      cursor: pointer;
      text-align: left;
      padding: 0 10px;
    }

    .overlay-type-option:hover {
      background: #5c574e;
    }

    .pdf-preview-empty {
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: rgba(235, 217, 167, 0.75);
      padding: 12px;
      text-align: center;
      box-sizing: border-box;
      position: absolute;
      inset: 0;
    }

    .pdf-quick-link {
      position: absolute;
      top: 16px;
      right: 16px;
      z-index: 4;
      color: #ffe9bb;
      font-size: 12px;
      text-decoration: underline;
      cursor: pointer;
      border: none;
      background: rgba(0, 0, 0, 0.24);
      border-radius: 8px;
      padding: 5px 8px;
    }

    #back-to-tray-btn {
      position: absolute;
      bottom: 18px;
      left: 18px;
      z-index: 999;
    }
  </style>
</head>
<body>
  <div class="main-page">
    <div id="cafe_int">
      <div class="exam-topbar">
        <button id="mock-topbar-picker-btn" class="topbar-icon-btn" type="button" title="PDF 불러오기">📂</button>
        <button id="mock-topbar-memo-btn" class="topbar-icon-btn" type="button" title="오버레이 메모">📝</button>
        <div class="topbar-submit-wrap">
          <button id="mock-topbar-submit-btn" class="topbar-icon-btn topbar-save-btn" type="button" title="제출 메뉴">제출</button>
          <div id="mock-topbar-submit-popup" class="topbar-submit-menu" hidden>
            <button id="mock-topbar-submit-active-btn" class="topbar-submit-option" type="button">현재 페이지 보내기</button>
            <button id="mock-topbar-submit-all-btn" class="topbar-submit-option" type="button">전체 페이지 보내기</button>
          </div>
        </div>
        <div class="topbar-submit-wrap">
          <button id="mock-topbar-print-btn" class="topbar-icon-btn topbar-save-btn topbar-print-btn" type="button" title="출력 메뉴">🖨</button>
          <div id="mock-topbar-print-popup" class="topbar-submit-menu" hidden>
            <button id="mock-topbar-print-ready-btn" class="topbar-submit-option" type="button">출력</button>
          </div>
        </div>
        <div class="topbar-spacer"></div>
        <button id="mock-topbar-status" class="topbar-status" type="button">학년 · 연도 선택</button>
        <button class="topbar-power-btn" type="button" title="전원">⏻</button>
      </div>
      <div id="mock-session-backdrop" class="session-picker-backdrop" hidden></div>
      <div id="mock-session-popup" class="session-picker-popup" hidden>
        <div class="session-picker-card">
          <div class="session-picker-head">
            <div class="session-picker-tabs" role="tablist" aria-label="수업 세션 목록">
              <button id="mock-session-tab-review" class="session-picker-tab is-active" type="button">수업 후 REVIEW</button>
              <button id="mock-session-tab-submitted" class="session-picker-tab" type="button">제출됨</button>
            </div>
            <span id="mock-session-sub" class="session-picker-sub">live sessions</span>
          </div>
          <div id="mock-session-list" class="session-picker-list"></div>
        </div>
      </div>
      <div id="mock-tab-close-confirm-backdrop" class="mini-confirm-backdrop" hidden></div>
      <div id="mock-tab-close-confirm-popup" class="mini-confirm-popup" hidden>
        <div class="mini-confirm-card" role="dialog" aria-modal="true" aria-labelledby="mock-tab-close-confirm-text">
          <div id="mock-tab-close-confirm-text" class="mini-confirm-text">탭을 닫을까요?</div>
          <div class="mini-confirm-actions">
            <button id="mock-tab-close-cancel-btn" class="mini-confirm-btn mini-confirm-btn--cancel" type="button">취소</button>
            <button id="mock-tab-close-ok-btn" class="mini-confirm-btn mini-confirm-btn--ok" type="button">닫기</button>
          </div>
        </div>
      </div>

      <div id="mock-workspace" class="workspace workspace--has-pdf">
        <button id="mock-pdf-open-newtab" class="pdf-quick-link" type="button" hidden>새 탭에서 열기</button>
        <div class="pdf-preview">
          <div id="pdf-preview-empty" class="pdf-preview-empty">상단에서 시험 구성을 고른 뒤<br />PDF 불러오기를 눌러주세요.</div>
          <div id="mock-pdf-pages" class="pdf-pages" hidden></div>
          <iframe id="mock-pdf-frame" title="모의고사 PDF 미리보기" hidden></iframe>
        </div>
      </div>

      <div id="mock-overlay-memo" class="overlay-memo" aria-hidden="true">
        <div class="overlay-memo-topbar">
          <span class="overlay-memo-title">NOTES : 필기</span>
          <button id="mock-overlay-close-btn" class="overlay-memo-close" type="button" aria-label="메모 닫기">✕</button>
          <div class="overlay-memo-topbar-spacer"></div>
          <button id="mock-overlay-font-open" class="overlay-memo-tool-btn" type="button">A+-</button>
          <div id="mock-overlay-font-popup" class="overlay-mini-popup" hidden>
            <button id="mock-overlay-font-dec" class="overlay-mini-step-btn" type="button" aria-label="폰트 줄이기">-</button>
            <div id="mock-overlay-font-size-value" class="overlay-font-size-value">16px</div>
            <button id="mock-overlay-font-inc" class="overlay-mini-step-btn" type="button" aria-label="폰트 키우기">+</button>
          </div>
        </div>
        <button id="mock-overlay-two-flip-triangle" class="overlay-side-flip" type="button" aria-label="오버레이 좌우 전환" title="오버레이 좌우 전환"></button>
        <div class="overlay-memo-body">
          <div id="mock-overlay-question-bar" class="overlay-question-bar">Question No. -</div>
          <div id="mock-overlay-blank-pane" class="overlay-pane overlay-blank-pane">
            <div class="overlay-blank-controls">
              <button id="mock-blank-pen-toggle" class="overlay-blank-tool-btn" type="button" aria-pressed="false" title="필기 모드">
                펜
              </button>
              <button id="mock-blank-pen-clear" class="overlay-blank-tool-btn" type="button" title="필기 지우기">
                지우기
              </button>
            </div>
            <textarea id="mock-overlay-memo-text" class="overlay-memo-textarea" placeholder="메모를 적어주세요..."></textarea>
            <div id="mock-blank-draw-wrap" class="overlay-blank-draw-wrap" hidden>
              <canvas id="mock-blank-draw-canvas" class="overlay-blank-draw-canvas"></canvas>
            </div>
          </div>
          <div id="mock-overlay-two-three-pane" class="overlay-pane overlay-two-three" hidden>
            <div class="overlay-two-col overlay-two-col--twoT">
              <div class="overlay-two-head">
                <span class="overlay-two-head-label">2T · 단어/뜻</span>
                <button
                  id="mock-overlay-dict-toggle"
                  class="overlay-two-head-toggle"
                  type="button"
                  aria-pressed="false"
                  title="3T 영역 사전 검색 토글"
                >
                  검색창
                </button>
              </div>
              <div id="mock-overlay-two-left-list" class="overlay-two-scroll"></div>
            </div>
            <div id="mock-overlay-three-col" class="overlay-two-col overlay-two-col--threeT">
              <div id="mock-overlay-three-head" class="overlay-two-head">
                <span id="mock-overlay-three-head-label" class="overlay-two-head-label">3T · 문장/분석</span>
                <div class="overlay-three-head-tools">
                  <button id="mock-overlay-three-pen-toggle" class="overlay-three-head-pen-toggle" type="button" aria-pressed="false">
                    펜
                  </button>
                  <button id="mock-overlay-three-pen-clear" class="overlay-three-head-clear-btn" type="button" disabled title="3T 필기 지우기">
                    지우기
                  </button>
                </div>
              </div>
              <div id="mock-overlay-two-right-list" class="overlay-two-scroll"></div>
              <div id="mock-overlay-dict-panel" class="overlay-dict-panel" hidden>
                <div class="overlay-dict-toolbar">
                  <span id="mock-overlay-dict-current" class="overlay-dict-current">단어를 클릭하면 검색됩니다.</span>
                  <button id="mock-overlay-dict-zoom-out" class="overlay-dict-zoom-btn" type="button" aria-label="검색창 축소">-</button>
                  <span id="mock-overlay-dict-zoom-value" class="overlay-dict-zoom-value">100%</span>
                  <button id="mock-overlay-dict-zoom-in" class="overlay-dict-zoom-btn" type="button" aria-label="검색창 확대">+</button>
                  <button id="mock-overlay-dict-open" class="overlay-dict-open" type="button" disabled>새 탭</button>
                </div>
                <iframe
                  id="mock-overlay-dict-frame"
                  class="overlay-dict-frame"
                  title="네이버 영한 검색"
                  referrerpolicy="no-referrer-when-downgrade"
                ></iframe>
              </div>
            </div>
          </div>
        </div>
        <div class="overlay-memo-tabbar">
          <div id="mock-overlay-tab-list" class="overlay-tab-list"></div>
          <button id="mock-overlay-add-tab" class="overlay-tab-add" type="button" aria-label="메모 탭 추가">＋</button>
          <div id="mock-overlay-tab-type-popup" class="overlay-tab-type-popup" hidden>
            <button class="overlay-type-option" type="button" data-type="blank">Blank</button>
            <button class="overlay-type-option" type="button" data-type="two_three">Words / Translation</button>
          </div>
        </div>
      </div>

      <div id="mock-picker-backdrop" class="pdf-picker-backdrop" hidden></div>
      <div id="mock-picker-popup" class="pdf-picker-popup" hidden>
        <div class="pdf-picker-wrap" aria-label="PDF 불러오기">
          <select id="mock-grade-select" aria-label="학년">
            <option value="">학년 로딩중...</option>
          </select>
          <select id="mock-year-select" aria-label="연도">
            <option value="">연도 로딩중...</option>
          </select>
          <select id="mock-exam-select" aria-label="몇평">
            <option value="">몇평 선택</option>
          </select>
          <select id="mock-type-select" aria-label="유형">
            <option value="">유형 선택</option>
          </select>
          <button id="mock-pdf-open-btn" class="pdf-open-btn" type="button">PDF 불러오기</button>
        </div>
      </div>
    </div>

    <button
      id="back-to-tray-btn"
      class="nav-mainhall-btn"
      data-nav-mainhall="homework-tray_v1.html"
      data-nav-replace="true"
    >
      ⬅ 테이블로 돌아가기
    </button>
  </div>

  <script src="nav-buttons.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script>
    (function () {
      const pickerToggleBtn = document.getElementById("mock-topbar-picker-btn");
      const memoToggleBtn = document.getElementById("mock-topbar-memo-btn");
      const submitMenuBtn = document.getElementById("mock-topbar-submit-btn");
      const submitMenuPopup = document.getElementById("mock-topbar-submit-popup");
      const submitActiveBtn = document.getElementById("mock-topbar-submit-active-btn");
      const submitAllBtn = document.getElementById("mock-topbar-submit-all-btn");
      const printMenuBtn = document.getElementById("mock-topbar-print-btn");
      const printMenuPopup = document.getElementById("mock-topbar-print-popup");
      const printReadyBtn = document.getElementById("mock-topbar-print-ready-btn");
      const pickerPopup = document.getElementById("mock-picker-popup");
      const pickerBackdrop = document.getElementById("mock-picker-backdrop");
      const sessionPopup = document.getElementById("mock-session-popup");
      const sessionBackdrop = document.getElementById("mock-session-backdrop");
      const sessionList = document.getElementById("mock-session-list");
      const sessionSub = document.getElementById("mock-session-sub");
      const sessionTabReviewBtn = document.getElementById("mock-session-tab-review");
      const sessionTabSubmittedBtn = document.getElementById("mock-session-tab-submitted");
      const tabCloseConfirmBackdrop = document.getElementById("mock-tab-close-confirm-backdrop");
      const tabCloseConfirmPopup = document.getElementById("mock-tab-close-confirm-popup");
      const tabCloseConfirmText = document.getElementById("mock-tab-close-confirm-text");
      const tabCloseCancelBtn = document.getElementById("mock-tab-close-cancel-btn");
      const tabCloseOkBtn = document.getElementById("mock-tab-close-ok-btn");
      const overlayMemo = document.getElementById("mock-overlay-memo");
      const overlayCloseBtn = document.getElementById("mock-overlay-close-btn");
      const overlayFontOpenBtn = document.getElementById("mock-overlay-font-open");
      const overlayFontPopup = document.getElementById("mock-overlay-font-popup");
      const overlayFontDecBtn = document.getElementById("mock-overlay-font-dec");
      const overlayFontIncBtn = document.getElementById("mock-overlay-font-inc");
      const overlayFontSizeValue = document.getElementById("mock-overlay-font-size-value");
      const overlayBlankPane = document.getElementById("mock-overlay-blank-pane");
      const overlayTwoThreePane = document.getElementById("mock-overlay-two-three-pane");
      const overlayTwoFlipTriangleBtn = document.getElementById("mock-overlay-two-flip-triangle");
      const overlayQuestionBar = document.getElementById("mock-overlay-question-bar");
      const overlayMemoText = document.getElementById("mock-overlay-memo-text");
      const blankPenToggleBtn = document.getElementById("mock-blank-pen-toggle");
      const blankPenClearBtn = document.getElementById("mock-blank-pen-clear");
      const blankDrawWrap = document.getElementById("mock-blank-draw-wrap");
      const blankDrawCanvas = document.getElementById("mock-blank-draw-canvas");
      const overlayTwoLeftList = document.getElementById("mock-overlay-two-left-list");
      const overlayTwoRightList = document.getElementById("mock-overlay-two-right-list");
      const overlayThreeCol = document.getElementById("mock-overlay-three-col");
      const overlayThreeHead = document.getElementById("mock-overlay-three-head");
      const overlayThreeHeadLabel = document.getElementById("mock-overlay-three-head-label");
      const overlayThreePenToggleBtn = document.getElementById("mock-overlay-three-pen-toggle");
      const overlayThreePenClearBtn = document.getElementById("mock-overlay-three-pen-clear");
      const overlayDictToggleBtn = document.getElementById("mock-overlay-dict-toggle");
      const overlayDictPanel = document.getElementById("mock-overlay-dict-panel");
      const overlayDictFrame = document.getElementById("mock-overlay-dict-frame");
      const overlayDictCurrent = document.getElementById("mock-overlay-dict-current");
      const overlayDictZoomOutBtn = document.getElementById("mock-overlay-dict-zoom-out");
      const overlayDictZoomInBtn = document.getElementById("mock-overlay-dict-zoom-in");
      const overlayDictZoomValue = document.getElementById("mock-overlay-dict-zoom-value");
      const overlayDictOpenBtn = document.getElementById("mock-overlay-dict-open");
      const overlayTabList = document.getElementById("mock-overlay-tab-list");
      const overlayAddTabBtn = document.getElementById("mock-overlay-add-tab");
      const overlayTabTypePopup = document.getElementById("mock-overlay-tab-type-popup");
      const overlayTypeOptionBtns = Array.from(document.querySelectorAll("#mock-overlay-tab-type-popup [data-type]"));
      const topbarStatus = document.getElementById("mock-topbar-status");
      const openBtn = document.getElementById("mock-pdf-open-btn");
      const gradeSel = document.getElementById("mock-grade-select");
      const yearSel = document.getElementById("mock-year-select");
      const examSel = document.getElementById("mock-exam-select");
      const typeSel = document.getElementById("mock-type-select");
      const previewPages = document.getElementById("mock-pdf-pages");
      const previewFrame = document.getElementById("mock-pdf-frame");
      const previewEmpty = document.getElementById("pdf-preview-empty");
      const newTabBtn = document.getElementById("mock-pdf-open-newtab");

      const SUPABASE_ORIGIN = "https://yslwgaephsnbfoiqnpuw.supabase.co";
      const SUPABASE_BASE = `${SUPABASE_ORIGIN}/storage/v1/object/public`;
      const BUCKET = "ksat-moi-sets";
      const DEFAULT_GRADE = "High3";
      const GRADE_OPTIONS = [
        { value: "High1", label: "고1" },
        { value: "High2", label: "고2" },
        { value: "High3", label: "고3" }
      ];

      const YEAR_CANDIDATES = (function () {
        const years = [];
        const startYear = 2017;
        const latestStartYear = new Date().getFullYear() - 1; // 예: 2026 -> 2025to2026
        for (let y = startYear; y <= latestStartYear; y += 1) {
          years.push(`${y}to${y + 1}`);
        }
        return years;
      })();

      const EXAM_META = [
        { key: "march", label: "3평", token: "march" },
        { key: "april", label: "4평", token: "april" },
        { key: "june", label: "6평", token: "june" },
        { key: "july", label: "7평", token: "july" },
        { key: "september", label: "9평", token: "september" },
        { key: "october", label: "10평", token: "october" },
        { key: "november", label: "11평", token: "november" }
      ];
      const EXAM_KEYS_BY_GRADE = {
        High1: ["march", "june", "september", "november"],
        High2: ["march", "june", "september", "november"],
        High3: ["march", "april", "june", "july", "september", "october", "november"]
      };

      const TYPE_META = [
        { label: "시험지", suffix: "" },
        { label: "대본", suffix: "_script" },
        { label: "해설", suffix: "_answer" }
      ];
      const DEFAULT_TYPE_LABEL = "시험지";
      const LIVE_API_BASE = "https://port-0-ltryi-database-1ru12mlw3glz2u.sel5.cloudtype.app";
      const LIVE_RECEIVE_URL = `${LIVE_API_BASE}/api/LiveToAfterclass_receive`;
      const LIVE_SEND_URL = `${LIVE_API_BASE}/api/LiveToAfterclass_send`;
      const LIVE_RECEIVE_LIMIT = 120;
      const FIXED_STUDENT_ID = new URLSearchParams(window.location.search).get("id") || "";
      const LOCAL_DRAFT_STORAGE_KEY = `mock-exam-tool:draft:${FIXED_STUDENT_ID || "guest"}`;
      const PDFJS_WORKER_SRC = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";
      const RENDER_QUALITY_BOOST = 1.35;
      const THREE_PEN_COLOR = "#f3e8d2";
      const THREE_PEN_WIDTH_SCALE = 0.72;
      const NAVER_EN_KO_SEARCH_BASE = "https://en.dict.naver.com/#/search?query=";
      const DICT_ZOOM_MIN = 0.8;
      const DICT_ZOOM_MAX = 1.8;
      const DICT_ZOOM_STEP = 0.1;
      const DEFAULT_PAYLOAD_QNO = 0;
      const DEFAULT_PAYLOAD_LAP = "1.1";

      let lastBlobUrl = "";
      let lastPdfUrl = "";
      let memoFontSize = 15;
      let overlaySide = "right";
      let nextMemoTabId = 2;
      const DEFAULT_TWO_T_CARD_COUNT = 50;
      const DEFAULT_THREE_T_CARD_COUNT = 15;
      const memoTabs = [{
        id: 1,
        type: "blank",
        blankText: "",
        twoThree: null,
        blankInk: []
      }];
      let activeMemoTabIndex = 0;
      const TAB_TYPE_LABEL = {
        blank: "Blank",
        two_three: "Words / Translation"
      };
      let classSessions = [];
      let isSessionListLoading = false;
      let sessionListLoadedOnce = false;
      let sessionListError = "";
      let sessionListExpandStep = 0;
      let sessionListHydrationToken = 0;
      const sessionListHydratedStepByTab = { review: -1, submitted: -1 };
      let sessionViewTab = "review";
      let selectedSessionId = "";
      let selectedSessionTitle = "";
      let selectedSessionTargetPage = null;
      let pendingCloseTabIndex = null;
      let pdfRenderToken = 0;
      let lastPreviewScrollAt = 0;
      let activeWordIndex = null;
      let wordMeaningMap = new Map();
      let wordTooltipEl = null;
      let isDictModeOn = false;
      let lastCapturedWord = "";
      let dictZoom = 1;
      let isBlankPenMode = false;
      let isThreeTPenMode = false;
      let hasLocalDraftSnapshot = false;
      let localDraftSaveTimer = null;
      let saveButtonUiTimer = null;
      let isSavingSessionToServer = false;
      let isApplyingLocalDraft = false;
      let submitToastTimer = null;
      const threePenState = {
        drawing: false,
        pointerId: null,
        card: null,
        canvas: null,
        lastPoint: null
      };
      const blankPenState = {
        drawing: false,
        pointerId: null,
        stroke: null,
        lastPoint: null
      };
      const DEBUG_SCROLL_DIAG = false;
      const DEBUG_LIVE_FETCH_LOG = true;

      if (
        !pickerToggleBtn ||
        !memoToggleBtn ||
        !submitMenuBtn ||
        !submitMenuPopup ||
        !submitActiveBtn ||
        !submitAllBtn ||
        !printMenuBtn ||
        !printMenuPopup ||
        !printReadyBtn ||
        !pickerPopup ||
        !pickerBackdrop ||
        !sessionPopup ||
        !sessionBackdrop ||
        !sessionList ||
        !sessionTabReviewBtn ||
        !sessionTabSubmittedBtn ||
        !tabCloseConfirmBackdrop ||
        !tabCloseConfirmPopup ||
        !tabCloseConfirmText ||
        !tabCloseCancelBtn ||
        !tabCloseOkBtn ||
        !overlayMemo ||
        !overlayCloseBtn ||
        !overlayFontOpenBtn ||
        !overlayFontPopup ||
        !overlayFontDecBtn ||
        !overlayFontIncBtn ||
        !overlayFontSizeValue ||
        !overlayBlankPane ||
        !overlayTwoThreePane ||
        !overlayTwoFlipTriangleBtn ||
        !overlayQuestionBar ||
        !overlayMemoText ||
        !blankPenToggleBtn ||
        !blankPenClearBtn ||
        !blankDrawWrap ||
        !blankDrawCanvas ||
        !overlayTwoLeftList ||
        !overlayTwoRightList ||
        !overlayThreeCol ||
        !overlayThreeHead ||
        !overlayThreeHeadLabel ||
        !overlayThreePenToggleBtn ||
        !overlayThreePenClearBtn ||
        !overlayDictToggleBtn ||
        !overlayDictPanel ||
        !overlayDictFrame ||
        !overlayDictCurrent ||
        !overlayDictZoomOutBtn ||
        !overlayDictZoomInBtn ||
        !overlayDictZoomValue ||
        !overlayDictOpenBtn ||
        !overlayTabList ||
        !overlayAddTabBtn ||
        !overlayTabTypePopup ||
        !overlayTypeOptionBtns.length ||
        !topbarStatus ||
        !openBtn ||
        !gradeSel ||
        !yearSel ||
        !examSel ||
        !typeSel ||
        !previewPages ||
        !previewFrame ||
        !previewEmpty ||
        !newTabBtn
      ) return;

      function showPanel(el) {
        el.hidden = false;
        el.style.display = "";
      }

      function hidePanel(el) {
        el.hidden = true;
        el.style.display = "none";
      }

      function setBtnActive(btn, active) {
        btn.classList.toggle("is-active", !!active);
      }

      function closePickerPopup() {
        pickerPopup.hidden = true;
        pickerBackdrop.hidden = true;
        setBtnActive(pickerToggleBtn, false);
      }

      function openPickerPopup() {
        closeSessionPopup();
        closeSubmitPopup();
        closePrintPopup();
        pickerPopup.hidden = false;
        pickerBackdrop.hidden = false;
        setBtnActive(pickerToggleBtn, true);
      }

      function togglePickerPopup() {
        if (pickerPopup.hidden) {
          openPickerPopup();
        } else {
          closePickerPopup();
        }
      }

      function closeSubmitPopup() {
        submitMenuPopup.hidden = true;
        setBtnActive(submitMenuBtn, false);
      }

      function openSubmitPopup() {
        closeSessionPopup();
        closePickerPopup();
        closePrintPopup();
        submitMenuPopup.hidden = false;
        setBtnActive(submitMenuBtn, true);
      }

      function toggleSubmitPopup() {
        if (submitMenuPopup.hidden) {
          openSubmitPopup();
        } else {
          closeSubmitPopup();
        }
      }

      function closePrintPopup() {
        printMenuPopup.hidden = true;
        setBtnActive(printMenuBtn, false);
      }

      function openPrintPopup() {
        closeSessionPopup();
        closePickerPopup();
        closeSubmitPopup();
        printMenuPopup.hidden = false;
        setBtnActive(printMenuBtn, true);
      }

      function togglePrintPopup() {
        if (printMenuPopup.hidden) {
          openPrintPopup();
        } else {
          closePrintPopup();
        }
      }

      function closeSessionPopup() {
        sessionListHydrationToken += 1;
        sessionPopup.hidden = true;
        sessionBackdrop.hidden = true;
        setBtnActive(topbarStatus, false);
      }

      function resetSessionListHydrationState() {
        sessionListHydrationToken += 1;
        sessionListHydratedStepByTab.review = -1;
        sessionListHydratedStepByTab.submitted = -1;
      }

      async function hydrateSessionListForCurrentScope(reason, tabOverride) {
        if (sessionPopup.hidden) return;
        if (!Array.isArray(classSessions) || !classSessions.length) return;

        const tab = tabOverride === "submitted"
          ? "submitted"
          : (sessionViewTab === "submitted" ? "submitted" : "review");
        const step = normalizeSessionExpandStep(sessionListExpandStep);
        if (sessionListHydratedStepByTab[tab] >= step) return;

        const token = ++sessionListHydrationToken;
        const scope = getSessionScopeByTabAndStep(tab, step, classSessions);
        const targets = Array.isArray(scope.visibleSessions) ? scope.visibleSessions.slice() : [];
        let submittedScopeForReview = null;
        if (tab === "review") {
          // REVIEW 탭에서도 suppress 판정을 위해 같은 범위(step)의 제출본 메타를 같이 로드한다.
          submittedScopeForReview = getSessionScopeByTabAndStep("submitted", step, classSessions);
          const submittedVisible = Array.isArray(submittedScopeForReview.visibleSessions)
            ? submittedScopeForReview.visibleSessions
            : [];
          submittedVisible.forEach(function (session) {
            if (!session) return;
            if (targets.indexOf(session) >= 0) return;
            targets.push(session);
          });
        }
        if (!targets.length) {
          sessionListHydratedStepByTab[tab] = step;
          if (tab === "review") {
            sessionListHydratedStepByTab.submitted = Math.max(sessionListHydratedStepByTab.submitted, step);
          }
          return;
        }

        if (DEBUG_LIVE_FETCH_LOG) {
          trace("info", `session scan start (${tab}, step ${step}, count ${targets.length})${reason ? `: ${reason}` : ""}`);
        }

        for (let i = 0; i < targets.length; i += 1) {
          if (token !== sessionListHydrationToken) return;
          const session = targets[i];
          if (!session || session._payloadLoaded) continue;
          await ensureSessionPayloadLoaded(session);
          if (token !== sessionListHydrationToken) return;
          renderSessionList();
        }

        if (token !== sessionListHydrationToken) return;
        sessionListHydratedStepByTab[tab] = step;
        if (tab === "review") {
          const submittedScope = submittedScopeForReview || getSessionScopeByTabAndStep("submitted", step, classSessions);
          const submittedVisible = Array.isArray(submittedScope.visibleSessions)
            ? submittedScope.visibleSessions
            : [];
          const submittedLoaded = submittedVisible.every(function (session) {
            if (!session) return true;
            const url = toSafeText(session.servedFileURL).trim();
            if (!url) return true;
            return !!session._payloadLoaded;
          });
          if (submittedLoaded) {
            sessionListHydratedStepByTab.submitted = Math.max(sessionListHydratedStepByTab.submitted, step);
          }
        }
        renderSessionList();
        if (DEBUG_LIVE_FETCH_LOG) {
          trace("info", `session scan done (${tab}, step ${step})`);
        }
      }

      function updateSessionTabUi() {
        const isReview = sessionViewTab !== "submitted";
        sessionTabReviewBtn.classList.toggle("is-active", isReview);
        sessionTabSubmittedBtn.classList.toggle("is-active", !isReview);
      }

      function setSessionViewTab(nextTab) {
        sessionViewTab = nextTab === "submitted" ? "submitted" : "review";
        sessionListExpandStep = 0;
        updateSessionTabUi();
        renderSessionList();
        void hydrateSessionListForCurrentScope("tab-switch", sessionViewTab);
      }

      function openSessionPopup() {
        closePickerPopup();
        closeSubmitPopup();
        closePrintPopup();
        sessionPopup.hidden = false;
        sessionBackdrop.hidden = false;
        setBtnActive(topbarStatus, true);
        sessionListExpandStep = 0;
        updateSessionTabUi();
        renderSessionList();
        void hydrateSessionListForCurrentScope("popup-open");
        void fetchLiveSessions(true);
      }

      function toggleSessionPopup() {
        if (sessionPopup.hidden) {
          openSessionPopup();
        } else {
          closeSessionPopup();
        }
      }

      function eventPathIncludesNode(event, node) {
        if (!event || !node) return false;
        if (typeof event.composedPath === "function") {
          const path = event.composedPath();
          if (Array.isArray(path) && path.indexOf(node) >= 0) return true;
        }
        const target = event.target;
        return target instanceof Node ? node.contains(target) : false;
      }

      function closeFontPopup() {
        overlayFontPopup.hidden = true;
      }

      function toggleFontPopup() {
        overlayFontPopup.hidden = !overlayFontPopup.hidden;
        if (!overlayFontPopup.hidden) {
          closeTabTypePopup();
        }
      }

      function closeTabTypePopup() {
        overlayTabTypePopup.hidden = true;
      }

      function closeTabCloseConfirm() {
        tabCloseConfirmPopup.hidden = true;
        tabCloseConfirmBackdrop.hidden = true;
        pendingCloseTabIndex = null;
      }

      function openTabCloseConfirm(index) {
        if (!Number.isFinite(Number(index))) return;
        pendingCloseTabIndex = Math.trunc(Number(index));
        tabCloseConfirmText.textContent = "탭을 닫을까요?";
        tabCloseConfirmPopup.hidden = false;
        tabCloseConfirmBackdrop.hidden = false;
      }

      function toggleTabTypePopup() {
        overlayTabTypePopup.hidden = !overlayTabTypePopup.hidden;
        if (!overlayTabTypePopup.hidden) {
          closeFontPopup();
        }
      }

      function applyOverlaySide() {
        const isLeft = overlaySide === "left";
        overlayMemo.classList.toggle("is-left", isLeft);
        overlayTwoThreePane.classList.toggle("is-flipped", isLeft);
      }

      function flipOverlaySide() {
        overlaySide = overlaySide === "right" ? "left" : "right";
        applyOverlaySide();
        markMemoDirty("overlay-side");
      }

      function isMemoOpen() {
        return overlayMemo.classList.contains("is-open");
      }

      function makeDefaultTwoTCards() {
        return Array.from({ length: DEFAULT_TWO_T_CARD_COUNT }, function () {
          return {
            word: "",
            meaning: ""
          };
        });
      }

      function makeDefaultThreeTCards() {
        return Array.from({ length: DEFAULT_THREE_T_CARD_COUNT }, function () {
          return {
            sentence: "",
            ink: []
          };
        });
      }

      function ensureThreeSentenceInk(card) {
        if (!card || typeof card !== "object") return [];
        if (!Array.isArray(card.ink)) {
          card.ink = [];
        }

        const normalized = [];
        for (let i = 0; i < card.ink.length; i += 1) {
          const rawStroke = card.ink[i];
          if (!rawStroke || !Array.isArray(rawStroke.points)) continue;

          const safeStroke = (typeof rawStroke === "object") ? rawStroke : { points: [] };
          const safePoints = [];
          for (let j = 0; j < rawStroke.points.length; j += 1) {
            const pt = rawStroke.points[j];
            if (!pt) continue;
            const xNum = Number(pt.x);
            const yNum = Number(pt.y);
            if (!Number.isFinite(xNum) || !Number.isFinite(yNum)) continue;
            const pNum = Number(pt.p);
            const pressure = Number.isFinite(pNum)
              ? Math.max(0.05, Math.min(1, pNum))
              : 0.5;
            safePoints.push({
              x: Math.max(0, Math.min(1, xNum)),
              y: Math.max(0, Math.min(1, yNum)),
              p: pressure
            });
          }

          if (!safePoints.length) continue;
          safeStroke.points = safePoints;
          normalized.push(safeStroke);
        }

        card.ink = normalized;
        return normalized;
      }

      function ensureTwoThreeData(tab) {
        if (!tab) return null;
        if (!tab.twoThree) {
          tab.twoThree = {
            words: makeDefaultTwoTCards(),
            sentences: makeDefaultThreeTCards()
          };
        }

        if (Array.isArray(tab.twoThree.cards) && tab.twoThree.cards.length) {
          const legacyCards = tab.twoThree.cards;
          tab.twoThree.words = legacyCards.slice(0, DEFAULT_TWO_T_CARD_COUNT).map(function (row) {
            return {
              word: row && typeof row.word === "string" ? row.word : "",
              meaning: row && typeof row.meaning === "string" ? row.meaning : ""
            };
          });
          tab.twoThree.sentences = legacyCards.slice(0, DEFAULT_THREE_T_CARD_COUNT).map(function (row) {
            return {
              sentence: row && typeof row.sentence === "string" ? row.sentence : "",
              ink: Array.isArray(row && row.ink) ? row.ink : []
            };
          });
          delete tab.twoThree.cards;
        }

        if (!Array.isArray(tab.twoThree.words)) {
          tab.twoThree.words = makeDefaultTwoTCards();
        }
        if (!Array.isArray(tab.twoThree.sentences)) {
          tab.twoThree.sentences = makeDefaultThreeTCards();
        }
        while (tab.twoThree.words.length < DEFAULT_TWO_T_CARD_COUNT) {
          tab.twoThree.words.push({ word: "", meaning: "" });
        }
        while (tab.twoThree.sentences.length < DEFAULT_THREE_T_CARD_COUNT) {
          tab.twoThree.sentences.push({ sentence: "", ink: [] });
        }
        if (tab.twoThree.words.length > DEFAULT_TWO_T_CARD_COUNT) {
          tab.twoThree.words = tab.twoThree.words.slice(0, DEFAULT_TWO_T_CARD_COUNT);
        }
        if (tab.twoThree.sentences.length > DEFAULT_THREE_T_CARD_COUNT) {
          tab.twoThree.sentences = tab.twoThree.sentences.slice(0, DEFAULT_THREE_T_CARD_COUNT);
        }
        for (let i = 0; i < tab.twoThree.sentences.length; i += 1) {
          const sentenceCard = tab.twoThree.sentences[i];
          if (!sentenceCard || typeof sentenceCard !== "object") {
            tab.twoThree.sentences[i] = { sentence: "", ink: [] };
            continue;
          }
          if (typeof sentenceCard.sentence !== "string") {
            sentenceCard.sentence = "";
          }
          ensureThreeSentenceInk(sentenceCard);
        }
        return tab.twoThree;
      }

      function getActiveMemoTab() {
        return memoTabs[activeMemoTabIndex] || null;
      }

      function syncActiveBlankTextFromEditor() {
        const tab = getActiveMemoTab();
        if (!tab || tab.type !== "blank") return false;
        const nextText = overlayMemoText.value;
        if (tab.blankText === nextText) return false;
        tab.blankText = nextText;
        return true;
      }

      function saveActiveMemoText() {
        if (syncActiveBlankTextFromEditor()) {
          markMemoDirty("blank-text");
        }
      }

      function applyMemoFontSize() {
        const px = `${memoFontSize}px`;
        overlayMemo.style.setProperty("--memo-font-size", px);
        overlayFontSizeValue.textContent = px;
      }

      function getActiveBlankTab() {
        const tab = getActiveMemoTab();
        return tab && tab.type === "blank" ? tab : null;
      }

      function ensureBlankInk(tab) {
        if (!tab) return [];
        if (!Array.isArray(tab.blankInk)) {
          tab.blankInk = [];
        }

        const normalized = [];
        for (let i = 0; i < tab.blankInk.length; i += 1) {
          const rawStroke = tab.blankInk[i];
          if (!rawStroke || !Array.isArray(rawStroke.points)) continue;

          const safeStroke = (typeof rawStroke === "object") ? rawStroke : { points: [] };
          const safePoints = [];
          for (let j = 0; j < rawStroke.points.length; j += 1) {
            const pt = rawStroke.points[j];
            if (!pt) continue;
            const xNum = Number(pt.x);
            const yNum = Number(pt.y);
            if (!Number.isFinite(xNum) || !Number.isFinite(yNum)) continue;
            const pNum = Number(pt.p);
            const pressure = Number.isFinite(pNum)
              ? Math.max(0.05, Math.min(1, pNum))
              : 0.5;
            safePoints.push({
              x: Math.max(0, Math.min(1, xNum)),
              y: Math.max(0, Math.min(1, yNum)),
              p: pressure
            });
          }

          if (!safePoints.length) continue;
          safeStroke.points = safePoints;
          normalized.push(safeStroke);
        }

        tab.blankInk = normalized;
        return normalized;
      }

      function getBlankPenPressure(event) {
        const pressure = Number(event.pressure);
        if (Number.isFinite(pressure) && pressure > 0) {
          return Math.max(0.05, Math.min(1, pressure));
        }
        if (event.pointerType === "pen") return 0.28;
        if (event.pointerType === "touch") return 0.45;
        return event.buttons ? 0.55 : 0.35;
      }

      function setupBlankCanvasContext() {
        const rect = blankDrawCanvas.getBoundingClientRect();
        if (!Number.isFinite(rect.width) || !Number.isFinite(rect.height) || rect.width < 8 || rect.height < 8) {
          return null;
        }
        const cssWidth = Math.max(1, Math.floor(rect.width));
        const cssHeight = Math.max(1, Math.floor(rect.height));
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const targetW = Math.floor(cssWidth * dpr);
        const targetH = Math.floor(cssHeight * dpr);
        if (blankDrawCanvas.width !== targetW || blankDrawCanvas.height !== targetH) {
          blankDrawCanvas.width = targetW;
          blankDrawCanvas.height = targetH;
        }

        const ctx = blankDrawCanvas.getContext("2d");
        if (!ctx) return null;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        return {
          ctx,
          width: cssWidth,
          height: cssHeight
        };
      }

      function bindBlankPenWindowListeners() {
        window.addEventListener("pointermove", handleBlankPenPointerMove, { passive: false });
        window.addEventListener("pointerup", handleBlankPenPointerEnd, { passive: false });
        window.addEventListener("pointercancel", handleBlankPenPointerEnd, { passive: false });
      }

      function unbindBlankPenWindowListeners() {
        window.removeEventListener("pointermove", handleBlankPenPointerMove);
        window.removeEventListener("pointerup", handleBlankPenPointerEnd);
        window.removeEventListener("pointercancel", handleBlankPenPointerEnd);
      }

      function drawInkDot(ctx, point, width, height, color, widthScale) {
        const px = point.x * width;
        const py = point.y * height;
        const scale = Math.max(0.45, Math.min(1.4, Number(widthScale) || 1));
        const penW = (0.9 + (3.8 - 0.9) * Math.max(0.05, Math.min(1, point.p || 0.5))) * scale;
        ctx.fillStyle = color || "#2f2a24";
        ctx.beginPath();
        ctx.arc(px, py, Math.max(0.55, penW * 0.5), 0, Math.PI * 2);
        ctx.fill();
      }

      function drawInkSegment(ctx, p1, p2, width, height, color, widthScale) {
        const x1 = p1.x * width;
        const y1 = p1.y * height;
        const x2 = p2.x * width;
        const y2 = p2.y * height;
        const pressure = ((p1.p || 0.5) + (p2.p || 0.5)) * 0.5;
        const scale = Math.max(0.45, Math.min(1.4, Number(widthScale) || 1));
        const penW = (0.9 + (3.8 - 0.9) * Math.max(0.05, Math.min(1, pressure))) * scale;

        ctx.strokeStyle = color || "#2f2a24";
        ctx.lineWidth = penW;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }

      function redrawBlankCanvas() {
        const tab = getActiveBlankTab();
        const setup = setupBlankCanvasContext();
        if (!setup) return;

        const ink = tab ? ensureBlankInk(tab) : [];
        const ctx = setup.ctx;
        const width = setup.width;
        const height = setup.height;
        ctx.clearRect(0, 0, width, height);

        for (let i = 0; i < ink.length; i += 1) {
          const points = ink[i].points;
          if (!points || !points.length) continue;
          if (points.length === 1) {
            drawInkDot(ctx, points[0], width, height);
            continue;
          }
          for (let j = 1; j < points.length; j += 1) {
            drawInkSegment(ctx, points[j - 1], points[j], width, height);
          }
        }
      }

      function updateBlankPenUi() {
        const tab = getActiveBlankTab();
        const isBlankTab = !!tab && !overlayBlankPane.hidden;

        blankPenToggleBtn.hidden = !isBlankTab;
        blankPenClearBtn.hidden = !isBlankTab;

        const penOn = isBlankTab && isBlankPenMode;
        overlayBlankPane.classList.toggle("is-pen-mode", penOn);
        blankDrawWrap.hidden = !penOn;
        blankPenToggleBtn.classList.toggle("is-on", penOn);
        blankPenToggleBtn.setAttribute("aria-pressed", penOn ? "true" : "false");
        blankPenToggleBtn.textContent = penOn ? "펜 ON" : "펜";

        const ink = tab ? ensureBlankInk(tab) : [];
        blankPenClearBtn.disabled = !isBlankTab || ink.length === 0;

        if (penOn) {
          overlayMemoText.blur();
          redrawBlankCanvas();
        }
      }

      function setBlankPenMode(forceOn) {
        const next = typeof forceOn === "boolean" ? forceOn : !isBlankPenMode;
        isBlankPenMode = !!next;
        if (!isBlankPenMode) {
          blankPenState.drawing = false;
          blankPenState.pointerId = null;
          blankPenState.stroke = null;
          blankPenState.lastPoint = null;
          unbindBlankPenWindowListeners();
        }
        updateBlankPenUi();
      }

      function clearActiveBlankInk() {
        const tab = getActiveBlankTab();
        if (!tab) return;
        tab.blankInk = [];
        redrawBlankCanvas();
        updateBlankPenUi();
        markMemoDirty("blank-ink-clear");
      }

      function getBlankCanvasPoint(event) {
        const rect = blankDrawCanvas.getBoundingClientRect();
        const localX = Math.max(0, Math.min(rect.width, event.clientX - rect.left));
        const localY = Math.max(0, Math.min(rect.height, event.clientY - rect.top));
        const safeW = Math.max(1, rect.width);
        const safeH = Math.max(1, rect.height);
        return {
          x: localX / safeW,
          y: localY / safeH,
          p: getBlankPenPressure(event)
        };
      }

      function handleBlankPenPointerDown(event) {
        if (!isBlankPenMode) return;
        const tab = getActiveBlankTab();
        if (!tab) return;

        event.preventDefault();
        const ink = ensureBlankInk(tab);
        const point = getBlankCanvasPoint(event);
        const stroke = { points: [point] };
        ink.push(stroke);

        blankPenState.drawing = true;
        blankPenState.pointerId = event.pointerId;
        blankPenState.stroke = stroke;
        blankPenState.lastPoint = point;
        bindBlankPenWindowListeners();

        if (typeof blankDrawCanvas.setPointerCapture === "function") {
          try {
            blankDrawCanvas.setPointerCapture(event.pointerId);
          } catch (_err) {}
        }

        const setup = setupBlankCanvasContext();
        if (setup) {
          drawInkDot(setup.ctx, point, setup.width, setup.height);
        }
        updateBlankPenUi();
      }

      function handleBlankPenPointerMove(event) {
        if (!blankPenState.drawing || blankPenState.pointerId !== event.pointerId) return;
        if (!isBlankPenMode) return;

        event.preventDefault();
        const nextPoint = getBlankCanvasPoint(event);
        if (!blankPenState.stroke) return;
        blankPenState.stroke.points.push(nextPoint);

        const setup = setupBlankCanvasContext();
        if (setup && blankPenState.lastPoint) {
          drawInkSegment(setup.ctx, blankPenState.lastPoint, nextPoint, setup.width, setup.height);
        }
        blankPenState.lastPoint = nextPoint;
      }

      function handleBlankPenPointerEnd(event) {
        if (!blankPenState.drawing || blankPenState.pointerId !== event.pointerId) return;
        event.preventDefault();

        if (typeof blankDrawCanvas.releasePointerCapture === "function") {
          try {
            blankDrawCanvas.releasePointerCapture(event.pointerId);
          } catch (_err) {}
        }

        blankPenState.drawing = false;
        blankPenState.pointerId = null;
        blankPenState.stroke = null;
        blankPenState.lastPoint = null;
        unbindBlankPenWindowListeners();
        updateBlankPenUi();
        markMemoDirty("blank-ink-draw");
      }

      function setupThreeInkCanvas(canvas) {
        if (!canvas) return null;
        const rect = canvas.getBoundingClientRect();
        if (!Number.isFinite(rect.width) || !Number.isFinite(rect.height) || rect.width < 8 || rect.height < 8) {
          return null;
        }
        const cssWidth = Math.max(1, Math.floor(rect.width));
        const cssHeight = Math.max(1, Math.floor(rect.height));
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const targetW = Math.floor(cssWidth * dpr);
        const targetH = Math.floor(cssHeight * dpr);
        if (canvas.width !== targetW || canvas.height !== targetH) {
          canvas.width = targetW;
          canvas.height = targetH;
        }

        const ctx = canvas.getContext("2d");
        if (!ctx) return null;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        return {
          ctx,
          width: cssWidth,
          height: cssHeight
        };
      }

      function redrawThreeInkCanvas(canvas, sentenceCard) {
        const setup = setupThreeInkCanvas(canvas);
        if (!setup) return;
        const strokes = ensureThreeSentenceInk(sentenceCard);
        const ctx = setup.ctx;
        const width = setup.width;
        const height = setup.height;
        ctx.clearRect(0, 0, width, height);

        for (let i = 0; i < strokes.length; i += 1) {
          const points = strokes[i].points;
          if (!points || !points.length) continue;
          if (points.length === 1) {
            drawInkDot(ctx, points[0], width, height, THREE_PEN_COLOR, THREE_PEN_WIDTH_SCALE);
            continue;
          }
          for (let j = 1; j < points.length; j += 1) {
            drawInkSegment(ctx, points[j - 1], points[j], width, height, THREE_PEN_COLOR, THREE_PEN_WIDTH_SCALE);
          }
        }
      }

      function getThreeCanvasPoint(canvas, event) {
        const rect = canvas.getBoundingClientRect();
        const localX = Math.max(0, Math.min(rect.width, event.clientX - rect.left));
        const localY = Math.max(0, Math.min(rect.height, event.clientY - rect.top));
        const safeW = Math.max(1, rect.width);
        const safeH = Math.max(1, rect.height);
        return {
          x: localX / safeW,
          y: localY / safeH,
          p: getBlankPenPressure(event)
        };
      }

      function stopThreePenDrawing() {
        if (threePenState.drawing && threePenState.canvas && typeof threePenState.canvas.releasePointerCapture === "function") {
          try {
            threePenState.canvas.releasePointerCapture(threePenState.pointerId);
          } catch (_err) {}
        }
        threePenState.drawing = false;
        threePenState.pointerId = null;
        threePenState.card = null;
        threePenState.canvas = null;
        threePenState.lastPoint = null;
      }

      function updateThreePenUi() {
        const tab = getActiveMemoTab();
        const isTwoThree = !!tab && tab.type === "two_three" && !overlayTwoThreePane.hidden;
        const allowPen = isTwoThree && !isDictModeOn;
        if (!allowPen && isThreeTPenMode) {
          isThreeTPenMode = false;
          stopThreePenDrawing();
        }

        overlayThreePenToggleBtn.hidden = !isTwoThree;
        overlayThreePenToggleBtn.disabled = !allowPen;
        overlayThreePenToggleBtn.classList.toggle("is-on", allowPen && isThreeTPenMode);
        overlayThreePenToggleBtn.setAttribute("aria-pressed", (allowPen && isThreeTPenMode) ? "true" : "false");
        overlayThreePenToggleBtn.textContent = allowPen && isThreeTPenMode ? "펜 ON" : "펜";

        overlayThreePenClearBtn.hidden = !isTwoThree;
        overlayThreePenClearBtn.disabled = !isTwoThree;

        overlayTwoThreePane.classList.toggle("is-three-pen-mode", allowPen && isThreeTPenMode);
      }

      function setThreePenMode(forceOn) {
        const tab = getActiveMemoTab();
        if (!tab || tab.type !== "two_three") return;
        if (isDictModeOn) return;
        const next = typeof forceOn === "boolean" ? forceOn : !isThreeTPenMode;
        isThreeTPenMode = !!next;
        if (!isThreeTPenMode) {
          stopThreePenDrawing();
        }
        renderTwoThreeCards();
      }

      function clearActiveThreeInk() {
        const tab = getActiveMemoTab();
        if (!tab || tab.type !== "two_three") return;
        const twoThree = ensureTwoThreeData(tab);
        if (!twoThree || !Array.isArray(twoThree.sentences)) return;

        let changed = false;
        for (let idx = 0; idx < twoThree.sentences.length; idx += 1) {
          const sentenceCard = twoThree.sentences[idx];
          const strokes = ensureThreeSentenceInk(sentenceCard);
          if (strokes.length > 0) {
            sentenceCard.ink = [];
            changed = true;
          }
        }

        if (!changed) return;
        stopThreePenDrawing();
        renderTwoThreeCards();
        markMemoDirty("three-ink-clear-all");
      }

      function clearThreeCardInk(sentenceCard, canvas) {
        if (!sentenceCard) return;
        const strokes = ensureThreeSentenceInk(sentenceCard);
        if (!strokes.length) return;
        if (threePenState.card === sentenceCard) {
          stopThreePenDrawing();
        }
        sentenceCard.ink = [];
        redrawThreeInkCanvas(canvas, sentenceCard);
        markMemoDirty("three-ink-clear-one");
      }

      function undoThreeCardInk(sentenceCard, canvas) {
        if (!sentenceCard) return;
        const strokes = ensureThreeSentenceInk(sentenceCard);
        if (!strokes.length) return;
        if (threePenState.card === sentenceCard) {
          stopThreePenDrawing();
        }
        strokes.pop();
        redrawThreeInkCanvas(canvas, sentenceCard);
        markMemoDirty("three-ink-undo");
      }

      function handleThreeInkPointerDown(event, sentenceCard, canvas) {
        if (!isThreeTPenMode || isDictModeOn) return;
        event.preventDefault();

        const strokes = ensureThreeSentenceInk(sentenceCard);
        const point = getThreeCanvasPoint(canvas, event);
        const stroke = { points: [point] };
        strokes.push(stroke);

        threePenState.drawing = true;
        threePenState.pointerId = event.pointerId;
        threePenState.card = sentenceCard;
        threePenState.canvas = canvas;
        threePenState.lastPoint = point;

        if (typeof canvas.setPointerCapture === "function") {
          try {
            canvas.setPointerCapture(event.pointerId);
          } catch (_err) {}
        }

        const setup = setupThreeInkCanvas(canvas);
        if (setup) {
          drawInkDot(setup.ctx, point, setup.width, setup.height, THREE_PEN_COLOR, THREE_PEN_WIDTH_SCALE);
        }
      }

      function handleThreeInkPointerMove(event, sentenceCard, canvas) {
        if (!threePenState.drawing || threePenState.pointerId !== event.pointerId) return;
        if (!isThreeTPenMode || isDictModeOn) return;
        if (threePenState.canvas !== canvas || threePenState.card !== sentenceCard) return;

        event.preventDefault();
        const nextPoint = getThreeCanvasPoint(canvas, event);
        const strokes = ensureThreeSentenceInk(sentenceCard);
        const activeStroke = strokes[strokes.length - 1];
        if (!activeStroke || !Array.isArray(activeStroke.points)) return;
        activeStroke.points.push(nextPoint);

        const setup = setupThreeInkCanvas(canvas);
        if (setup && threePenState.lastPoint) {
          drawInkSegment(setup.ctx, threePenState.lastPoint, nextPoint, setup.width, setup.height, THREE_PEN_COLOR, THREE_PEN_WIDTH_SCALE);
        }
        threePenState.lastPoint = nextPoint;
      }

      function handleThreeInkPointerEnd(event, sentenceCard, canvas) {
        if (!threePenState.drawing || threePenState.pointerId !== event.pointerId) return;
        if (threePenState.canvas !== canvas || threePenState.card !== sentenceCard) return;
        event.preventDefault();
        stopThreePenDrawing();
        markMemoDirty("three-ink-draw");
      }

      function buildNaverDictUrl(word) {
        const clean = normalizeCapturedWord(word);
        if (!clean) return "https://en.dict.naver.com/";
        return `${NAVER_EN_KO_SEARCH_BASE}${encodeURIComponent(clean)}`;
      }

      function clampDictZoom(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) return dictZoom;
        return Math.max(DICT_ZOOM_MIN, Math.min(DICT_ZOOM_MAX, numeric));
      }

      function applyDictZoom() {
        overlayDictZoomValue.textContent = `${Math.round(dictZoom * 100)}%`;
        overlayDictFrame.style.zoom = String(dictZoom);
      }

      function adjustDictZoom(direction) {
        const delta = direction > 0 ? DICT_ZOOM_STEP : -DICT_ZOOM_STEP;
        const next = clampDictZoom(dictZoom + delta);
        if (Math.abs(next - dictZoom) < 0.001) return;
        dictZoom = next;
        applyDictZoom();
      }

      function refreshDictPanel() {
        const tab = getActiveMemoTab();
        const isTwoThree = !!tab && tab.type === "two_three" && !overlayTwoThreePane.hidden;
        const shouldShowDict = isTwoThree && isDictModeOn;

        overlayDictToggleBtn.classList.toggle("is-on", shouldShowDict);
        overlayDictToggleBtn.setAttribute("aria-pressed", shouldShowDict ? "true" : "false");
        overlayDictToggleBtn.textContent = shouldShowDict ? "🔎 검색중" : "🔎 검색";
        overlayDictToggleBtn.title = shouldShowDict ? "검색창 끄기" : "검색창 켜기";

        overlayTwoRightList.hidden = shouldShowDict;
        overlayDictPanel.hidden = !shouldShowDict;
        overlayThreeCol.classList.toggle("is-dict-mode", shouldShowDict);
        overlayThreeHead.classList.toggle("is-dict-mode", shouldShowDict);
        overlayThreeHeadLabel.textContent = shouldShowDict ? "단어 검색창" : "3T · 문장/분석";
        updateThreePenUi();

        if (!shouldShowDict) return;

        let clean = normalizeCapturedWord(lastCapturedWord);
        if (!clean && tab && tab.type === "two_three") {
          const twoThree = ensureTwoThreeData(tab);
          if (twoThree && Array.isArray(twoThree.words)) {
            for (let i = 0; i < twoThree.words.length; i += 1) {
              const fromCard = normalizeCapturedWord(twoThree.words[i] && twoThree.words[i].word);
              if (fromCard) {
                clean = fromCard;
                lastCapturedWord = fromCard;
                break;
              }
            }
          }
        }

        const targetUrl = buildNaverDictUrl(clean);
        if (overlayDictFrame.dataset.loadedUrl !== targetUrl) {
          overlayDictFrame.src = targetUrl;
          overlayDictFrame.dataset.loadedUrl = targetUrl;
        }
        overlayDictCurrent.textContent = clean ? `검색어: ${clean}` : "단어를 클릭하면 검색됩니다.";
        overlayDictOpenBtn.disabled = !clean;
        overlayDictOpenBtn.dataset.url = targetUrl;
        applyDictZoom();
      }

      function toggleDictPanel(forceOn) {
        const next = typeof forceOn === "boolean" ? forceOn : !isDictModeOn;
        isDictModeOn = !!next;
        refreshDictPanel();
      }

      function pushWordToDictSearch(word) {
        const clean = normalizeCapturedWord(word);
        if (!clean) return;
        lastCapturedWord = clean;
        if (!isDictModeOn) return;
        refreshDictPanel();
      }

      function findNextTwoTWordSlot(words) {
        for (let i = 0; i < words.length; i += 1) {
          const row = words[i] || {};
          if (!normalizeCapturedWord(row.word || "")) {
            return i;
          }
        }
        return -1;
      }

      function applyCapturedWordToTwoTView(slotIndex, word) {
        if (overlayTwoThreePane.hidden) return;

        const inputEl = overlayTwoLeftList.querySelector(`.overlay-card-input--twoT[data-two-t-slot="${slotIndex}"]`);
        if (inputEl) {
          inputEl.value = word;
        }

        const cardEl = overlayTwoLeftList.querySelector(`.overlay-card--twoT[data-two-t-card="${slotIndex}"]`);
        if (cardEl) {
          cardEl.classList.remove("is-captured");
          requestAnimationFrame(function () {
            cardEl.classList.add("is-captured");
            cardEl.scrollIntoView({ block: "nearest", behavior: "smooth" });
            window.setTimeout(function () {
              cardEl.classList.remove("is-captured");
            }, 460);
          });
        }
      }

      function buildTwoTCard(card, idx) {
        const outer = document.createElement("div");
        outer.className = "overlay-card overlay-card--twoT";
        outer.dataset.twoTCard = String(idx);
        const inner = document.createElement("div");
        inner.className = "overlay-card-inner overlay-card-inner--twoT";

        const row = document.createElement("div");
        row.className = "overlay-card-row overlay-card-row--twoT";

        const idxEl = document.createElement("span");
        idxEl.className = "overlay-card-index overlay-card-index--twoT";
        idxEl.textContent = String(idx + 1);

        const wordInput = document.createElement("input");
        wordInput.type = "text";
        wordInput.className = "overlay-card-input overlay-card-input--twoT";
        wordInput.dataset.twoTSlot = String(idx);
        wordInput.placeholder = "단어";
        wordInput.value = card.word || "";
        wordInput.addEventListener("input", function () {
          card.word = wordInput.value;
          rebuildWordMeaningMap();
          markMemoDirty("two-t-word");
        });

        row.appendChild(idxEl);
        row.appendChild(wordInput);

        const meaningArea = document.createElement("textarea");
        meaningArea.className = "overlay-card-textarea overlay-card-textarea--twoT";
        meaningArea.placeholder = "뜻/메모";
        meaningArea.value = card.meaning || "";
        meaningArea.addEventListener("input", function () {
          card.meaning = meaningArea.value;
          rebuildWordMeaningMap();
          markMemoDirty("two-t-meaning");
        });

        inner.appendChild(row);
        inner.appendChild(meaningArea);
        outer.appendChild(inner);
        return outer;
      }

      function buildThreeTCard(card, idx) {
        const outer = document.createElement("div");
        outer.className = "overlay-card overlay-card--threeT";
        const inner = document.createElement("div");
        inner.className = "overlay-card-inner overlay-card-inner--threeT";

        const row = document.createElement("div");
        row.className = "overlay-card-row overlay-card-row--threeT";

        const idxEl = document.createElement("span");
        idxEl.className = "overlay-card-index overlay-card-index--threeT";
        idxEl.textContent = String(idx + 1).padStart(2, "0");

        const tools = document.createElement("div");
        tools.className = "overlay-three-card-tools";

        const undoBtn = document.createElement("button");
        undoBtn.className = "overlay-three-card-tool-btn";
        undoBtn.type = "button";
        undoBtn.textContent = "Undo";

        const clearBtn = document.createElement("button");
        clearBtn.className = "overlay-three-card-tool-btn";
        clearBtn.type = "button";
        clearBtn.textContent = "지우기";

        const sentenceInput = document.createElement("textarea");
        sentenceInput.className = "overlay-card-textarea overlay-card-textarea--threeT overlay-card-textarea--threeT-sentence";
        sentenceInput.placeholder = "문장";
        sentenceInput.value = card.sentence || "";
        sentenceInput.readOnly = isThreeTPenMode;
        sentenceInput.addEventListener("input", function () {
          card.sentence = sentenceInput.value;
          markMemoDirty("three-t-sentence");
        });

        row.appendChild(idxEl);
        tools.appendChild(undoBtn);
        tools.appendChild(clearBtn);
        row.appendChild(tools);

        inner.appendChild(row);
        inner.appendChild(sentenceInput);

        const inkWrap = document.createElement("div");
        inkWrap.className = "overlay-three-ink-wrap";
        const inkCanvas = document.createElement("canvas");
        inkCanvas.className = "overlay-three-ink-canvas";
        inkCanvas.addEventListener("pointerdown", function (event) {
          handleThreeInkPointerDown(event, card, inkCanvas);
        });
        inkCanvas.addEventListener("pointermove", function (event) {
          handleThreeInkPointerMove(event, card, inkCanvas);
        });
        inkCanvas.addEventListener("pointerup", function (event) {
          handleThreeInkPointerEnd(event, card, inkCanvas);
        });
        inkCanvas.addEventListener("pointercancel", function (event) {
          handleThreeInkPointerEnd(event, card, inkCanvas);
        });
        undoBtn.addEventListener("click", function () {
          undoThreeCardInk(card, inkCanvas);
        });
        clearBtn.addEventListener("click", function () {
          clearThreeCardInk(card, inkCanvas);
        });
        inkWrap.appendChild(inkCanvas);
        inner.appendChild(inkWrap);
        outer.appendChild(inner);

        requestAnimationFrame(function () {
          redrawThreeInkCanvas(inkCanvas, card);
        });
        return outer;
      }

      function renderTwoThreeCards() {
        const tab = getActiveMemoTab();
        if (!tab || tab.type !== "two_three") return;
        const twoThree = ensureTwoThreeData(tab);
        if (!twoThree) return;

        overlayTwoThreePane.classList.toggle("is-flipped", overlaySide === "left");
        updateThreePenUi();
        overlayTwoLeftList.innerHTML = "";
        overlayTwoRightList.innerHTML = "";

        for (let idx = 0; idx < twoThree.words.length; idx += 1) {
          const wordCard = twoThree.words[idx];
          overlayTwoLeftList.appendChild(buildTwoTCard(wordCard, idx));
        }
        for (let idx = 0; idx < twoThree.sentences.length; idx += 1) {
          const sentCard = twoThree.sentences[idx];
          overlayTwoRightList.appendChild(buildThreeTCard(sentCard, idx));
        }
        refreshDictPanel();
      }

      function renderActiveMemoPane() {
        const tab = getActiveMemoTab();
        const isTwoThree = !!tab && tab.type === "two_three";
        rebuildWordMeaningMap();
        overlayBlankPane.hidden = isTwoThree;
        overlayTwoThreePane.hidden = !isTwoThree;

        if (!tab) {
          updateBlankPenUi();
          updateOverlayQuestionNoBar();
          return;
        }
        if (isTwoThree) {
          ensureTwoThreeData(tab);
          renderTwoThreeCards();
        } else {
          overlayMemoText.value = tab.blankText || "";
          refreshDictPanel();
        }
        updateThreePenUi();
        updateBlankPenUi();
        updateOverlayQuestionNoBar();
      }

      function renderMemoTabbar() {
        overlayTabList.innerHTML = "";
        for (let idx = 0; idx < memoTabs.length; idx += 1) {
          const item = memoTabs[idx];
          const wrapper = document.createElement("div");
          wrapper.className = "overlay-tab-item";

          const tabBtn = document.createElement("button");
          tabBtn.type = "button";
          tabBtn.className = `overlay-tab-btn ${idx === activeMemoTabIndex ? "is-active" : "is-inactive"}`;
          tabBtn.textContent = String(item.id);
          tabBtn.title = TAB_TYPE_LABEL[item.type] || item.type;
          tabBtn.addEventListener("click", function () {
            switchMemoTab(idx);
          });

          const closeBtn = document.createElement("button");
          closeBtn.type = "button";
          closeBtn.className = "overlay-tab-close";
          closeBtn.textContent = "✕";
          closeBtn.title = "탭 닫기";
          closeBtn.addEventListener("click", function () {
            closeMemoTab(idx);
          });

          wrapper.appendChild(tabBtn);
          wrapper.appendChild(closeBtn);
          overlayTabList.appendChild(wrapper);
        }
      }

      function switchMemoTab(index) {
        if (index < 0 || index >= memoTabs.length) return;
        stopThreePenDrawing();
        saveActiveMemoText();
        activeMemoTabIndex = index;
        renderActiveMemoPane();
        renderMemoTabbar();
        markMemoDirty("tab-switch");
      }

      function addMemoTab(tabType) {
        stopThreePenDrawing();
        saveActiveMemoText();
        const type = tabType === "two_three" ? "two_three" : "blank";
        memoTabs.push({
          id: nextMemoTabId,
          type,
          blankText: "",
          blankInk: [],
          twoThree: type === "two_three" ? {
            words: makeDefaultTwoTCards(),
            sentences: makeDefaultThreeTCards()
          } : null
        });
        nextMemoTabId += 1;
        activeMemoTabIndex = memoTabs.length - 1;
        renderActiveMemoPane();
        renderMemoTabbar();
        closeTabTypePopup();
        markMemoDirty("tab-add");
      }

      function closeMemoTab(index) {
        if (!Number.isFinite(Number(index))) return;
        openTabCloseConfirm(Math.trunc(Number(index)));
      }

      function closeMemoTabConfirmed(index) {
        if (index < 0 || index >= memoTabs.length) return;
        stopThreePenDrawing();
        saveActiveMemoText();
        if (memoTabs.length === 1) {
          memoTabs[0].blankText = "";
          memoTabs[0].blankInk = [];
          memoTabs[0].twoThree = null;
          renderActiveMemoPane();
          markMemoDirty("tab-reset-last");
          return;
        }
        memoTabs.splice(index, 1);
        if (activeMemoTabIndex >= memoTabs.length) {
          activeMemoTabIndex = memoTabs.length - 1;
        } else if (index < activeMemoTabIndex) {
          activeMemoTabIndex -= 1;
        }
        renderActiveMemoPane();
        renderMemoTabbar();
        markMemoDirty("tab-close");
      }

      function toggleMemoOverlay(forceVisible) {
        const shouldShow = typeof forceVisible === "boolean" ? forceVisible : !isMemoOpen();
        if (shouldShow && !pickerPopup.hidden) {
          closePickerPopup();
        }
        if (shouldShow && !sessionPopup.hidden) {
          closeSessionPopup();
        }
        overlayMemo.classList.toggle("is-open", shouldShow);
        overlayMemo.setAttribute("aria-hidden", shouldShow ? "false" : "true");
        setBtnActive(memoToggleBtn, shouldShow);
        if (!shouldShow) {
          stopThreePenDrawing();
          blankPenState.drawing = false;
          blankPenState.pointerId = null;
          blankPenState.stroke = null;
          blankPenState.lastPoint = null;
          unbindBlankPenWindowListeners();
          closeFontPopup();
          closeTabTypePopup();
          closeTabCloseConfirm();
        }
      }

      function trace(level, message, meta) {
        const fn = (console && typeof console[level] === "function") ? console[level] : console.log;
        if (meta !== undefined) {
          fn(`[mock-exam-tool] ${message}`, meta);
        } else {
          fn(`[mock-exam-tool] ${message}`);
        }
      }

      function describeNodeForDiag(node) {
        if (!(node instanceof Element)) return String(node);
        const id = node.id ? `#${node.id}` : "";
        let cls = "";
        if (node.classList && node.classList.length) {
          cls = "." + Array.from(node.classList).slice(0, 3).join(".");
        }
        return `${node.tagName.toLowerCase()}${id}${cls}`;
      }

      function getScrollHostMetrics(host) {
        if (!host) return null;
        const cs = window.getComputedStyle(host);
        return {
          node: describeNodeForDiag(host),
          clientH: host.clientHeight,
          scrollH: host.scrollHeight,
          scrollTop: host.scrollTop,
          canScrollY: host.scrollHeight > host.clientHeight + 1,
          overflowY: cs.overflowY,
          touchAction: cs.touchAction,
          pointerEvents: cs.pointerEvents
        };
      }

      function lockPreviewViewportHeight(reason) {
        const previewBox = previewPages.parentElement;
        if (!previewBox) return;

        const workspace = document.getElementById("mock-workspace");
        let target = 0;
        if (workspace) {
          const wsRect = workspace.getBoundingClientRect();
          const topPad = 8;
          const bottomPad = 12;
          target = wsRect.height - topPad - bottomPad;
        }
        if (!Number.isFinite(target) || target <= 0) {
          target = window.innerHeight - 220;
        }
        target = Math.max(260, Math.min(760, Math.floor(target)));

        previewBox.style.height = `${target}px`;
        previewBox.style.maxHeight = `${target}px`;
        previewPages.style.height = "100%";
        previewPages.style.maxHeight = "100%";
        previewPages.style.minHeight = "0";

        if (DEBUG_SCROLL_DIAG) {
          trace("info", `diag/layout-${reason}`, {
            target,
            previewBox: getScrollHostMetrics(previewBox),
            host: getScrollHostMetrics(previewPages)
          });
        }
      }

      function attachPreviewScrollDiagnostics(host) {
        if (!DEBUG_SCROLL_DIAG || !host) return;
        let lastEmitAt = 0;
        const emit = function (stage, payload) {
          const now = Date.now();
          if (stage === "scroll" && now - lastEmitAt < 120) return;
          lastEmitAt = now;
          trace("info", `diag/${stage}`, payload);
        };

        emit("init", getScrollHostMetrics(host));

        host.addEventListener("scroll", function () {
          emit("scroll", {
            top: host.scrollTop,
            left: host.scrollLeft,
            maxY: Math.max(0, host.scrollHeight - host.clientHeight)
          });
        }, { passive: true });

        host.addEventListener("wheel", function (event) {
          const before = host.scrollTop;
          const target = describeNodeForDiag(event.target);
          requestAnimationFrame(function () {
            const topEl = document.elementFromPoint(event.clientX, event.clientY);
            emit("wheel", {
              deltaY: event.deltaY,
              before,
              after: host.scrollTop,
              target,
              topElement: describeNodeForDiag(topEl),
              defaultPrevented: event.defaultPrevented
            });
          });
        }, { passive: true });

        host.addEventListener("touchstart", function (event) {
          const t = event.touches && event.touches[0];
          emit("touchstart", {
            target: describeNodeForDiag(event.target),
            x: t ? t.clientX : null,
            y: t ? t.clientY : null
          });
        }, { passive: true });

        host.addEventListener("touchmove", function (event) {
          const before = host.scrollTop;
          const t = event.touches && event.touches[0];
          const x = t ? t.clientX : 0;
          const y = t ? t.clientY : 0;
          requestAnimationFrame(function () {
            const topEl = document.elementFromPoint(x, y);
            emit("touchmove", {
              before,
              after: host.scrollTop,
              target: describeNodeForDiag(event.target),
              topElement: describeNodeForDiag(topEl),
              defaultPrevented: event.defaultPrevented
            });
          });
        }, { passive: true });

        host.addEventListener("pointerdown", function (event) {
          emit("pointerdown", {
            target: describeNodeForDiag(event.target),
            pointerType: event.pointerType,
            x: event.clientX,
            y: event.clientY
          });
        }, { passive: true });
      }

      function bindTouchDragScrollBridge(targetEl) {
        if (!targetEl || !previewPages) return;
        let dragging = false;
        let moved = false;
        let startX = 0;
        let startY = 0;
        let startTop = 0;
        let startLeft = 0;

        targetEl.addEventListener("touchstart", function (event) {
          if (!event.touches || event.touches.length !== 1) {
            dragging = false;
            moved = false;
            return;
          }
          const t = event.touches[0];
          dragging = true;
          moved = false;
          startX = t.clientX;
          startY = t.clientY;
          startTop = previewPages.scrollTop;
          startLeft = previewPages.scrollLeft;
        }, { passive: true });

        targetEl.addEventListener("touchmove", function (event) {
          if (!dragging || !event.touches || event.touches.length !== 1) return;
          const t = event.touches[0];
          const dx = t.clientX - startX;
          const dy = t.clientY - startY;
          if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {
            moved = true;
          }
          previewPages.scrollTop = startTop - dy;
          previewPages.scrollLeft = startLeft - dx;
          if (moved) {
            lastPreviewScrollAt = Date.now();
            hideWordTooltip();
            event.preventDefault();
          }
        }, { passive: false });

        const stopDrag = function () {
          dragging = false;
          if (moved) {
            lastPreviewScrollAt = Date.now();
          }
          moved = false;
        };
        targetEl.addEventListener("touchend", stopDrag, { passive: true });
        targetEl.addEventListener("touchcancel", stopDrag, { passive: true });
      }

      function clearBlobUrl() {
        if (!lastBlobUrl) return;
        try {
          URL.revokeObjectURL(lastBlobUrl);
        } catch (_err) {}
        lastBlobUrl = "";
      }

      function getSupabaseKey() {
        const fromWindow = window.SUPABASE_ANON_KEY || window.__SUPABASE_ANON_KEY__;
        if (fromWindow) return String(fromWindow).trim();

        const fromLocal = localStorage.getItem("SUPABASE_ANON_KEY");
        if (fromLocal) return String(fromLocal).trim();

        const fromQuery = new URLSearchParams(window.location.search).get("sbkey");
        if (fromQuery) return String(fromQuery).trim();

        return "";
      }

      function setLocalDraftState(next, skipStatusTextUpdate) {
        hasLocalDraftSnapshot = !!next;
        topbarStatus.classList.toggle("is-local-draft", hasLocalDraftSnapshot);
        topbarStatus.classList.toggle("is-writing", hasLocalDraftSnapshot);
        if (!skipStatusTextUpdate) {
          updateTopbarStatus();
        }
      }

      function clearLocalDraftStorage(reason) {
        clearLocalDraftSaveTimer();
        try {
          localStorage.removeItem(LOCAL_DRAFT_STORAGE_KEY);
        } catch (err) {
          trace("warn", "local draft delete failed", err);
        }
        setLocalDraftState(false);
        if (reason) {
          trace("info", `local draft cleared: ${reason}`);
        }
      }

      function hasStoredLocalDraftData() {
        try {
          return !!localStorage.getItem(LOCAL_DRAFT_STORAGE_KEY);
        } catch (_err) {
          return hasLocalDraftSnapshot;
        }
      }

      function shouldAskDiscardDraftForSession(nextSessionKey) {
        if (!hasLocalDraftSnapshot) return false;
        if (!hasStoredLocalDraftData()) {
          setLocalDraftState(false, true);
          return false;
        }
        if (nextSessionKey && selectedSessionId && nextSessionKey === selectedSessionId) {
          return false;
        }
        return true;
      }

      function confirmDiscardWorkingDraft() {
        const ok = window.confirm("작성중인 임시저장 내용이 있습니다.\n버리고 새 세션을 불러올까요?");
        if (!ok) return false;
        clearLocalDraftStorage("discard-by-user");
        return true;
      }

      function hasAnyWorkingMemoContent() {
        if (hasLocalDraftSnapshot || hasStoredLocalDraftData()) return true;
        try {
          return snapshotHasMeaningfulContent(buildLocalDraftSnapshot());
        } catch (_err) {
          return false;
        }
      }

      function resetMemoWorkspaceForNewLoad() {
        stopThreePenDrawing();
        setBlankPenMode(false);
        isThreeTPenMode = false;
        isDictModeOn = false;
        lastCapturedWord = "";

        clearSessionSelection();

        memoTabs.length = 0;
        memoTabs.push({
          id: 1,
          type: "blank",
          blankText: "",
          twoThree: null,
          blankInk: []
        });
        nextMemoTabId = 2;
        activeMemoTabIndex = 0;
        renderActiveMemoPane();
        renderMemoTabbar();

        closeFontPopup();
        closeTabTypePopup();
        closeTabCloseConfirm();

        clearLocalDraftStorage("discard-before-load");
        updateTopbarStatus();
      }

      function confirmDiscardWorkingNotesForLoad() {
        if (!hasAnyWorkingMemoContent()) return true;
        const ok = window.confirm("작성중인 임시저장 내용이 있습니다.\n버리고 새 세션을 불러올까요?");
        if (!ok) return false;
        resetMemoWorkspaceForNewLoad();
        return true;
      }

      function markMemoDirty(reason) {
        scheduleLocalDraftSave(reason || "memo-change");
      }

      function clearLocalDraftSaveTimer() {
        if (!localDraftSaveTimer) return;
        clearTimeout(localDraftSaveTimer);
        localDraftSaveTimer = null;
      }

      function scheduleLocalDraftSave(reason) {
        if (isApplyingLocalDraft) return;
        clearLocalDraftSaveTimer();
        localDraftSaveTimer = window.setTimeout(function () {
          localDraftSaveTimer = null;
          saveLocalDraftNow(reason || "auto");
        }, 220);
      }

      function cloneInkStrokes(rawStrokes) {
        const strokes = Array.isArray(rawStrokes) ? rawStrokes : [];
        const cloned = [];
        for (let i = 0; i < strokes.length; i += 1) {
          const stroke = strokes[i];
          if (!stroke || !Array.isArray(stroke.points)) continue;
          const points = [];
          for (let j = 0; j < stroke.points.length; j += 1) {
            const pt = stroke.points[j];
            if (!pt) continue;
            const x = Number(pt.x);
            const y = Number(pt.y);
            if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
            const pNum = Number(pt.p);
            const p = Number.isFinite(pNum) ? Math.max(0.05, Math.min(1, pNum)) : 0.5;
            points.push({
              x: Math.max(0, Math.min(1, x)),
              y: Math.max(0, Math.min(1, y)),
              p
            });
          }
          if (!points.length) continue;
          cloned.push({ points });
        }
        return cloned;
      }

      function serializeMemoTabsForSave(tabs) {
        const safeTabs = Array.isArray(tabs) ? tabs : [];
        return safeTabs.map(function (tab) {
          const safeTab = tab && typeof tab === "object" ? tab : {};
          const rawQNo = getRawQNoFromAny(safeTab);
          const parsedQNo = parseQNoForPayload(rawQNo);
          const rawLap = getRawLapFromAny(safeTab);
          const hasRawLap = hasMeaningfulText(rawLap);
          const normalizedLap = normalizeLapForPayload(rawLap);
          const attachQuestionMeta = function (target) {
            if (!target || typeof target !== "object") return target;
            if (parsedQNo > 0) {
              target.QNo = parsedQNo;
              target.qNo = parsedQNo;
            }
            if (hasRawLap || normalizedLap !== DEFAULT_PAYLOAD_LAP) {
              target.Lap = normalizedLap;
              target.lap = normalizedLap;
            }
            return target;
          };
          if (safeTab.type === "two_three") {
            const twoThree = ensureTwoThreeData(safeTab) || {};
            const words = Array.isArray(twoThree.words) ? twoThree.words.map(function (row) {
              const safeRow = row && typeof row === "object" ? row : {};
              return {
                word: toSafeText(safeRow.word),
                meaning: toSafeText(safeRow.meaning)
              };
            }) : [];
            const sentences = Array.isArray(twoThree.sentences) ? twoThree.sentences.map(function (row) {
              const safeRow = row && typeof row === "object" ? row : {};
              return {
                sentence: toSafeText(safeRow.sentence),
                ink: cloneInkStrokes(safeRow.ink)
              };
            }) : [];
            return attachQuestionMeta({
              type: "two_three",
              words,
              sentences
            });
          }
          return attachQuestionMeta({
            type: "blank",
            blankText: toSafeText(safeTab.blankText),
            blankInk: cloneInkStrokes(safeTab.blankInk)
          });
        });
      }

      function getCurrentPreviewPageNumber() {
        if (!previewPages.hidden) {
          const wraps = previewPages.querySelectorAll(".pdf-page");
          if (wraps && wraps.length) {
            const scrollTop = Math.max(0, Number(previewPages.scrollTop) || 0);
            let page = 1;
            for (let i = 0; i < wraps.length; i += 1) {
              const top = Math.max(0, Number(wraps[i].offsetTop) || 0);
              if (top - 8 <= scrollTop) {
                page = i + 1;
              } else {
                break;
              }
            }
            return page;
          }
        }
        if (!previewFrame.hidden) {
          const src = String(previewFrame.getAttribute("src") || previewFrame.src || "");
          const match = src.match(/[?#&]page=(\d+)/i);
          return parsePositivePage(match ? match[1] : null);
        }
        return null;
      }

      function hasMeaningfulText(value) {
        return !!toSafeText(value).trim();
      }

      function isTemplateTabFilled(tab) {
        const safeTab = tab && typeof tab === "object" ? tab : {};
        if (safeTab.type === "two_three") {
          const words = Array.isArray(safeTab.words) ? safeTab.words : [];
          for (let i = 0; i < words.length; i += 1) {
            const row = words[i] && typeof words[i] === "object" ? words[i] : {};
            if (hasMeaningfulText(row.word) || hasMeaningfulText(row.meaning)) return true;
          }

          const sentences = Array.isArray(safeTab.sentences) ? safeTab.sentences : [];
          for (let i = 0; i < sentences.length; i += 1) {
            const row = sentences[i] && typeof sentences[i] === "object" ? sentences[i] : {};
            if (hasMeaningfulText(row.sentence) || hasInkStrokeList(row.ink)) return true;
          }
          return false;
        }

        if (hasMeaningfulText(safeTab.blankText)) return true;
        return hasInkStrokeList(safeTab.blankInk);
      }

      function collectTemplateSubmitTargets(submitMode) {
        syncActiveBlankTextFromEditor();
        const tabs = serializeMemoTabsForSave(memoTabs);
        const mode = submitMode === "all" ? "all" : "active";

        if (mode === "active") {
          const idxNum = Number(activeMemoTabIndex);
          const idx = Number.isFinite(idxNum) ? Math.trunc(idxNum) : -1;
          if (idx < 0 || idx >= tabs.length) return [];
          const tab = tabs[idx];
          if (!isTemplateTabFilled(tab)) return [];
          return [{
            tab,
            templatePage: idx + 1,
            originalIndex: idx
          }];
        }

        const targets = [];
        for (let i = 0; i < tabs.length; i += 1) {
          const tab = tabs[i];
          if (!isTemplateTabFilled(tab)) continue;
          targets.push({
            tab,
            templatePage: i + 1,
            originalIndex: i
          });
        }
        return targets;
      }

      function buildPayloadJsonForTemplatePage(tab, templatePage, submitMeta) {
        const safeTab = tab && typeof tab === "object" ? tab : { type: "blank", blankText: "", blankInk: [] };
        const tabType = safeTab.type === "two_three" ? "two_three" : "blank";
        const page = Math.max(1, Math.trunc(Number(templatePage) || 1));
        const mode = submitMeta && submitMeta.mode === "all" ? "all" : "active";
        const order = Math.max(1, Math.trunc(Number(submitMeta && submitMeta.order) || 1));
        const count = Math.max(1, Math.trunc(Number(submitMeta && submitMeta.count) || 1));
        const tabIndex = Math.max(0, Math.trunc(Number(submitMeta && submitMeta.tabIndex) || 0));
        const tabQNo = parseQNoForPayload(getRawQNoFromAny(safeTab));
        const metaQNo = parseQNoForPayload(submitMeta && submitMeta.qNo !== undefined ? submitMeta.qNo : null);
        const qNo = tabQNo > 0 ? tabQNo : (metaQNo > 0 ? metaQNo : DEFAULT_PAYLOAD_QNO);

        const tabLapSource = getRawLapFromAny(safeTab);
        const hasTabLap = hasMeaningfulText(tabLapSource);
        const tabLap = normalizeLapForPayload(tabLapSource);
        const hasMetaLap = !!(submitMeta && submitMeta.lap !== undefined && submitMeta.lap !== null && hasMeaningfulText(submitMeta.lap));
        const metaLap = normalizeLapForPayload(submitMeta && submitMeta.lap !== undefined ? submitMeta.lap : null);
        const forceMetaLap = !!(submitMeta && submitMeta.forceLap === true);
        const lap = forceMetaLap && hasMetaLap
          ? metaLap
          : (hasTabLap ? tabLap : (hasMetaLap ? metaLap : DEFAULT_PAYLOAD_LAP));

        const payload = {
          template: tabType === "two_three" ? "단어찾고번역" : "blank",
          tabs: [safeTab],
          activeTabIndex: 0,
          overlaySide: overlaySide === "left" ? "left" : "right",
          page,
          QNo: qNo,
          Lap: lap,
          meta: {
            source: "mock-exam-tool",
            savedAt: new Date().toISOString(),
            page,
            templatePage: page,
            templateTabIndex: tabIndex,
            submitMode: mode,
            submitOrder: order,
            submitCount: count,
            QNo: qNo,
            Lap: lap
          }
        };

        if (tabType === "two_three") {
          const words = Array.isArray(safeTab.words)
            ? safeTab.words.filter(function (row) {
              const safeRow = row && typeof row === "object" ? row : {};
              return !!(hasMeaningfulText(safeRow.word) || hasMeaningfulText(safeRow.meaning));
            })
            : [];
          const sentences = Array.isArray(safeTab.sentences)
            ? safeTab.sentences.filter(function (row) {
              const safeRow = row && typeof row === "object" ? row : {};
              return !!(hasMeaningfulText(safeRow.sentence) || hasInkStrokeList(safeRow.ink));
            })
            : [];
          if (words.length) {
            payload.pairs = words;
            payload.words = words;
          }
          if (sentences.length) {
            payload.sentences = sentences;
          }
        } else {
          const text = toSafeText(safeTab.blankText).trim();
          if (text) {
            payload.text = text;
          }
        }

        return payload;
      }

      function hasInkStrokeList(rawStrokes) {
        if (!Array.isArray(rawStrokes) || !rawStrokes.length) return false;
        return rawStrokes.some(function (stroke) {
          return !!(stroke && Array.isArray(stroke.points) && stroke.points.length > 0);
        });
      }

      function payloadHasAnyPenInk(payloadObj) {
        const safe = payloadObj && typeof payloadObj === "object" ? payloadObj : {};
        const tabs = Array.isArray(safe.tabs) ? safe.tabs : [];
        for (let i = 0; i < tabs.length; i += 1) {
          const tab = tabs[i] && typeof tabs[i] === "object" ? tabs[i] : {};
          if (tab.type === "blank") {
            if (hasInkStrokeList(tab.blankInk)) return true;
            continue;
          }
          if (tab.type === "two_three") {
            const sentenceRows = Array.isArray(tab.sentences)
              ? tab.sentences
              : (tab.twoThree && Array.isArray(tab.twoThree.sentences) ? tab.twoThree.sentences : []);
            for (let j = 0; j < sentenceRows.length; j += 1) {
              const row = sentenceRows[j] && typeof sentenceRows[j] === "object" ? sentenceRows[j] : {};
              if (hasInkStrokeList(row.ink)) return true;
            }
          }
        }
        if (Array.isArray(safe.sentences)) {
          for (let i = 0; i < safe.sentences.length; i += 1) {
            const row = safe.sentences[i] && typeof safe.sentences[i] === "object" ? safe.sentences[i] : {};
            if (hasInkStrokeList(row.ink)) return true;
          }
        }
        if (hasInkStrokeList(safe.blankInk)) return true;
        return false;
      }

      function parseQYearForSend(value) {
        const text = toSafeText(value).trim();
        if (!text) return Number.NaN;
        const span = text.match(/^(\d{4})to(\d{4})$/i);
        if (span) {
          return Number(span[1]);
        }
        const numeric = Number(text);
        if (Number.isFinite(numeric)) {
          return Math.trunc(numeric);
        }
        return Number.NaN;
      }

      function parseQNoForPayload(value) {
        const text = toSafeText(value).trim();
        if (!text) return DEFAULT_PAYLOAD_QNO;
        const numeric = Number(text);
        if (Number.isFinite(numeric)) {
          return Math.max(0, Math.trunc(numeric));
        }
        const digitMatch = text.match(/\d+/);
        if (digitMatch) {
          const parsed = Number(digitMatch[0]);
          if (Number.isFinite(parsed)) {
            return Math.max(0, Math.trunc(parsed));
          }
        }
        return DEFAULT_PAYLOAD_QNO;
      }

      function getSessionNoFromAny(source) {
        const safe = source && typeof source === "object" ? source : {};
        const row = safe._row && typeof safe._row === "object" ? safe._row : safe;
        const raw = getRawSessionNoFromAny(row);
        const parsed = Number(raw);
        return Number.isFinite(parsed) ? Math.trunc(parsed) : Number.NaN;
      }

      function isReviewSessionNo(sessionNo) {
        return Number(sessionNo) === 1;
      }

      function isSubmittedSessionNo(sessionNo) {
        const n = Number(sessionNo);
        return n === 99 || n === 992;
      }

      function formatQuestionNoLabel(rawValue) {
        const qNo = parseQNoForPayload(rawValue);
        return qNo > 0 ? String(qNo) : "-";
      }

      function getSessionQuestionNoLabel(session) {
        const safeSession = session && typeof session === "object" ? session : null;
        if (!safeSession) return "-";
        return formatQuestionNoLabel(getSessionQNoFromAny(safeSession));
      }

      function getLapTurnFromAny(source) {
        const safe = source && typeof source === "object" ? source : {};
        const row = safe._row && typeof safe._row === "object" ? safe._row : safe;
        const rawLap = safe.lap != null
          ? safe.lap
          : (row ? getRawLapFromAny(row) : null);
        const normalized = normalizeLapForPayload(rawLap);
        const match = normalized.match(/^(\d+)\.(\d+)$/);
        if (!match) return 1;
        const turn = Number(match[2]);
        return Number.isFinite(turn) ? Math.max(1, Math.trunc(turn)) : 1;
      }

      function getLapMajorFromAny(source) {
        const safe = source && typeof source === "object" ? source : {};
        const row = safe._row && typeof safe._row === "object" ? safe._row : safe;
        const rawLap = safe.lap != null
          ? safe.lap
          : (row ? getRawLapFromAny(row) : null);
        const normalized = normalizeLapForPayload(rawLap);
        const match = normalized.match(/^(\d+)\.(\d+)$/);
        if (!match) return 1;
        const major = Number(match[1]);
        return Number.isFinite(major) ? Math.max(1, Math.trunc(major)) : 1;
      }

      function getSessionQNoFromAny(source) {
        const safe = source && typeof source === "object" ? source : {};
        const row = safe._row && typeof safe._row === "object" ? safe._row : safe;
        const sessionQNo = parseQNoForPayload(safe.qNo);
        if (sessionQNo > 0) return sessionQNo;
        return parseQNoForPayload(row ? getRawQNoFromAny(row) : null);
      }

      function getSessionMockTrackKey(source) {
        const safe = source && typeof source === "object" ? source : {};
        const row = safe._row && typeof safe._row === "object" ? safe._row : safe;

        const qLevelRaw = toSafeText(
          row && row.QLevel != null
            ? row.QLevel
            : (safe.mock && safe.mock.grade ? safe.mock.grade : "")
        ).trim();
        const qLevel = normalizeStorageGrade(qLevelRaw || DEFAULT_GRADE);

        const qYear = parseQYearForSend(
          row && row.QYear != null
            ? row.QYear
            : (safe.mock && safe.mock.year ? safe.mock.year : "")
        );

        let qMonth = Number(row && row.QMonth != null ? row.QMonth : Number.NaN);
        if (!Number.isFinite(qMonth) && safe.mock && safe.mock.examKey) {
          qMonth = examKeyToMonth(safe.mock.examKey);
        }

        if (!qLevel || !Number.isFinite(qYear) || !Number.isFinite(qMonth)) return "";

        const page = parsePositivePage(
          safe.targetPage != null
            ? safe.targetPage
            : (row ? (row.Page != null ? row.Page : (row.page != null ? row.page : row.TemplatePage)) : null)
        );

        return `${qLevel}:${Math.trunc(qYear)}:${Math.trunc(qMonth)}:${page || 0}`;
      }

      function buildReviewTrackKey(source) {
        const qNo = getSessionQNoFromAny(source);
        const lapMajor = getLapMajorFromAny(source);
        if (!lapMajor) return "";
        if (qNo > 0) return `q:${qNo}:${lapMajor}`;
        const mockKey = getSessionMockTrackKey(source);
        if (!mockKey) return "";
        return `m:${mockKey}:${lapMajor}`;
      }

      function isReviewSessionForList(session) {
        if (!isReviewSessionNo(getSessionNoFromAny(session))) return false;
        return getLapTurnFromAny(session) === 1;
      }

      function updateOverlayQuestionNoBar() {
        if (!overlayQuestionBar) return;
        const tab = getActiveMemoTab();
        const tabRawQNo = tab && typeof tab === "object"
          ? getRawQNoFromAny(tab)
          : null;
        let label = formatQuestionNoLabel(tabRawQNo);
        if (label === "-") {
          const selectedSession = findSelectedSessionByKey();
          label = getSessionQuestionNoLabel(selectedSession);
        }
        overlayQuestionBar.textContent = `Question No. ${label}`;
      }

      function setActiveTabQuestionNoFromWordHit(rawQNo) {
        const qNo = parseQNoForPayload(rawQNo);
        if (qNo <= 0) return false;
        const tab = getActiveMemoTab();
        if (!tab || typeof tab !== "object") return false;
        const prev = parseQNoForPayload(getRawQNoFromAny(tab));
        if (prev === qNo) return false;
        tab.QNo = qNo;
        tab.qNo = qNo;
        updateOverlayQuestionNoBar();
        markMemoDirty("qno-from-word-hit");
        trace("info", `active tab qno set from word-hit: Q${qNo}`);
        return true;
      }

      function normalizeLapForPayload(value) {
        const text = toSafeText(value).trim();
        if (!text) return DEFAULT_PAYLOAD_LAP;

        const dotMatch = text.match(/^(\d+)\.(\d+)$/);
        if (dotMatch) {
          const lap = Math.max(1, Math.trunc(Number(dotMatch[1]) || 0));
          const turn = Math.max(1, Math.trunc(Number(dotMatch[2]) || 0));
          return `${lap}.${turn}`;
        }

        const pairMatch = text.match(/(\d+)\D+(\d+)/);
        if (pairMatch) {
          const lap = Math.max(1, Math.trunc(Number(pairMatch[1]) || 0));
          const turn = Math.max(1, Math.trunc(Number(pairMatch[2]) || 0));
          return `${lap}.${turn}`;
        }

        const singleMatch = text.match(/^(\d+)$/);
        if (singleMatch) {
          const lap = Math.max(1, Math.trunc(Number(singleMatch[1]) || 0));
          return `${lap}.1`;
        }

        return DEFAULT_PAYLOAD_LAP;
      }

      function incrementLapTurn(rawLap) {
        const normalized = normalizeLapForPayload(rawLap);
        const match = normalized.match(/^(\d+)\.(\d+)$/);
        if (!match) return normalized;
        const lap = Math.max(1, Math.trunc(Number(match[1]) || 0));
        const turn = Math.max(1, Math.trunc(Number(match[2]) || 0)) + 1;
        return `${lap}.${turn}`;
      }

      function resolveSubmitQuestionMeta() {
        const session = findSelectedSessionByKey();
        const sessionNo = getSessionNoFromAny(session);
        const isReviewSubmit = isReviewSessionNo(sessionNo);
        const row = session && session._row && typeof session._row === "object"
          ? session._row
          : null;
        const qNoCandidates = [
          session && session.qNo,
          row && getRawQNoFromAny(row)
        ];
        const lapCandidates = [
          session && session.lap,
          row && getRawLapFromAny(row)
        ];

        let qNo = DEFAULT_PAYLOAD_QNO;
        let hasQNo = false;
        for (let i = 0; i < qNoCandidates.length; i += 1) {
          const parsed = parseQNoForPayload(qNoCandidates[i]);
          if (parsed > 0) {
            qNo = parsed;
            hasQNo = true;
            break;
          }
        }

        let lap = DEFAULT_PAYLOAD_LAP;
        let hasLap = false;
        for (let i = 0; i < lapCandidates.length; i += 1) {
          const normalized = normalizeLapForPayload(lapCandidates[i]);
          if (normalized !== DEFAULT_PAYLOAD_LAP || hasMeaningfulText(lapCandidates[i])) {
            lap = normalized;
            hasLap = true;
            break;
          }
        }

        // REVIEW(SessionNo=1)에서 다시 제출할 때는 왕복 회차를 0.1(=turn +1) 증가시킨다.
        if (isReviewSubmit) {
          lap = incrementLapTurn(lap);
          hasLap = true;
        }

        return { qNo, lap, hasQNo, hasLap, forceLap: isReviewSubmit };
      }

      function examKeyToMonth(examKey) {
        const map = {
          march: 3,
          april: 4,
          june: 6,
          july: 7,
          september: 9,
          october: 10,
          november: 11
        };
        return map[String(examKey || "").trim().toLowerCase()] || Number.NaN;
      }

      function formatNowAsSqlDatetime(dateObj) {
        const d = dateObj instanceof Date ? dateObj : new Date();
        const pad = function (n) {
          return String(Math.max(0, Math.trunc(n))).padStart(2, "0");
        };
        return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
      }

      function findSelectedSessionByKey() {
        if (!selectedSessionId || !Array.isArray(classSessions) || !classSessions.length) return null;
        for (let idx = 0; idx < classSessions.length; idx += 1) {
          const session = classSessions[idx];
          const key = getSessionKey(session, idx);
          if (key === selectedSessionId) {
            return session;
          }
        }
        return null;
      }

      function resolveSaveContext() {
        const session = findSelectedSessionByKey();
        const fallbackYear = session && session._row ? toSafeText(session._row.QYear) : "";
        const fallbackMonth = session && session._row ? Number(session._row.QMonth) : Number.NaN;
        const fallbackExamKey = session && session.mock ? session.mock.examKey : "";
        const qYear = parseQYearForSend(yearSel.value || fallbackYear || (session && session.mock ? session.mock.year : ""));
        const qMonthFromExam = examKeyToMonth(examSel.value || fallbackExamKey || monthToExamKey(fallbackMonth));
        const qMonth = Number.isFinite(qMonthFromExam) ? Math.trunc(qMonthFromExam) : (Number.isFinite(fallbackMonth) ? Math.trunc(fallbackMonth) : Number.NaN);
        const qLevel = normalizeStorageGrade(
          gradeSel.value ||
          (session && session.mock ? session.mock.grade : "") ||
          (session && session._row ? session._row.QLevel : "")
        );
        const userId = toSafeText(FIXED_STUDENT_ID || (session && session._row ? session._row.UserId : "")).trim();

        const issues = [];
        if (!userId) issues.push("UserId");
        if (!qLevel) issues.push("QLevel");
        if (!Number.isFinite(qYear)) issues.push("QYear");
        if (!Number.isFinite(qMonth)) issues.push("QMonth");

        return {
          ok: issues.length === 0,
          issues,
          userId,
          qLevel: qLevel || DEFAULT_GRADE,
          qYear,
          qMonth
        };
      }

      function setSubmitButtonsUi(state, label) {
        submitMenuBtn.classList.remove("is-busy", "is-ok", "is-error");
        if (state === "busy") submitMenuBtn.classList.add("is-busy");
        if (state === "ok") submitMenuBtn.classList.add("is-ok");
        if (state === "error") submitMenuBtn.classList.add("is-error");
        submitMenuBtn.textContent = label || "제출";

        const mustDisable = !FIXED_STUDENT_ID || state === "busy";
        submitMenuBtn.disabled = mustDisable;
        submitActiveBtn.disabled = mustDisable;
        submitAllBtn.disabled = mustDisable;
        submitMenuBtn.title = !FIXED_STUDENT_ID
          ? "URL에 ?id=UserId 가 필요합니다."
          : "제출 메뉴";
        if (mustDisable) {
          closeSubmitPopup();
        }
      }

      function queueSubmitButtonsUiReset(delayMs) {
        if (saveButtonUiTimer) {
          clearTimeout(saveButtonUiTimer);
        }
        saveButtonUiTimer = window.setTimeout(function () {
          saveButtonUiTimer = null;
          setSubmitButtonsUi("idle", "제출");
        }, Math.max(240, Number(delayMs) || 1200));
      }

      function showSubmitToast(message) {
        let toast = document.getElementById("mock-submit-toast");
        if (!toast) {
          toast = document.createElement("div");
          toast.id = "mock-submit-toast";
          toast.className = "submit-toast";
          toast.setAttribute("role", "status");
          toast.setAttribute("aria-live", "polite");
          document.body.appendChild(toast);
        }
        if (submitToastTimer) {
          clearTimeout(submitToastTimer);
          submitToastTimer = null;
        }
        toast.textContent = String(message || "제출되었습니다!");
        toast.classList.remove("is-show");
        void toast.offsetWidth;
        toast.classList.add("is-show");
        submitToastTimer = window.setTimeout(function () {
          toast.classList.remove("is-show");
          submitToastTimer = null;
        }, 1900);
      }

      function buildRequestBodyForSubmit(context, sessionNoForSave, payloadJson) {
        const qNo = extractQNoFromPayload(payloadJson);
        const lap = extractLapFromPayload(payloadJson);
        return {
          UserId: context.userId,
          LiveSchedule: formatNowAsSqlDatetime(new Date()),
          SessionNo: sessionNoForSave,
          QLevel: context.qLevel,
          QYear: context.qYear,
          QMonth: context.qMonth,
          QNo: qNo,
          Lap: lap,
          PayloadJson: payloadJson
        };
      }

      async function postSessionPayload(requestBody) {
        const res = await fetch(LIVE_SEND_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(requestBody)
        });
        const rawText = await res.text();
        let responsePayload = null;
        try {
          responsePayload = rawText ? JSON.parse(rawText) : null;
        } catch (_err) {
          responsePayload = null;
        }
        if (!res.ok) {
          const message = responsePayload && responsePayload.message
            ? responsePayload.message
            : (rawText || `HTTP ${res.status}`);
          throw new Error(message);
        }
        return {
          status: res.status,
          payload: responsePayload
        };
      }

      function resetWorkspaceAfterSubmit() {
        stopThreePenDrawing();
        setBlankPenMode(false);
        isThreeTPenMode = false;
        isDictModeOn = false;
        lastCapturedWord = "";
        dictZoom = 1;
        applyDictZoom();

        selectedSessionId = "";
        selectedSessionTitle = "";
        selectedSessionTargetPage = null;
        renderSessionList();

        gradeSel.value = DEFAULT_GRADE;
        yearSel.value = "";
        examSel.value = "";
        typeSel.value = "";
        refreshYearExamTypeOptions();

        overlaySide = "right";
        applyOverlaySide();

        memoTabs.length = 0;
        memoTabs.push({
          id: 1,
          type: "blank",
          blankText: "",
          twoThree: null,
          blankInk: []
        });
        nextMemoTabId = 2;
        activeMemoTabIndex = 0;
        renderActiveMemoPane();
        renderMemoTabbar();

        closeSessionPopup();
        closePickerPopup();
        closeSubmitPopup();
        closePrintPopup();
        closeFontPopup();
        closeTabTypePopup();
        closeTabCloseConfirm();
        if (isMemoOpen()) {
          toggleMemoOverlay(false);
        }

        activeWordIndex = null;
        wordMeaningMap = new Map();
        lastPdfUrl = "";
        resetPdfPreviewToEmpty("상단에서 시험 구성을 고른 뒤 PDF 불러오기를 눌러주세요.");
        setLocalDraftState(false, true);
        updateTopbarStatus();
      }

      async function sendCurrentSessionToServer(submitMode) {
        if (isSavingSessionToServer) return;
        const mode = submitMode === "all" ? "all" : "active";

        const context = resolveSaveContext();
        if (!context.ok) {
          trace("warn", "manual submit blocked: required fields missing", context.issues);
          setSubmitButtonsUi("error", "정보부족");
          queueSubmitButtonsUiReset(1800);
          return;
        }

        const submitTargets = collectTemplateSubmitTargets(mode);
        if (!submitTargets.length) {
          trace("info", `manual submit skipped: no writable template page (${mode})`);
          if (mode === "all") {
            setSubmitButtonsUi("error", "작성없음");
            window.alert("작성된 템플릿 페이지가 없어 제출하지 않았습니다.");
          } else {
            setSubmitButtonsUi("error", "빈 페이지");
            window.alert("현재 활성 페이지에 작성된 내용이 없어 제출하지 않았습니다.");
          }
          queueSubmitButtonsUiReset(1800);
          return;
        }

        const confirmMessage = mode === "all"
          ? `모두 제출하시겠습니까?\n작성된 ${submitTargets.length}페이지를 제출합니다.`
          : `현재 페이지(${submitTargets[0].templatePage})를 제출하시겠습니까?`;
        if (!window.confirm(confirmMessage)) return;

        const submitQuestionMeta = resolveSubmitQuestionMeta();

        isSavingSessionToServer = true;
        if (saveButtonUiTimer) {
          clearTimeout(saveButtonUiTimer);
          saveButtonUiTimer = null;
        }
        setSubmitButtonsUi("busy", mode === "all" ? `모두 1/${submitTargets.length}` : "제출중");
        saveLocalDraftNow("manual-save");

        try {
          const submitResults = [];
          for (let i = 0; i < submitTargets.length; i += 1) {
            const target = submitTargets[i];
            if (mode === "all") {
              setSubmitButtonsUi("busy", `모두 ${i + 1}/${submitTargets.length}`);
            }

            const payloadJson = buildPayloadJsonForTemplatePage(
              target.tab,
              target.templatePage,
              {
                mode,
                order: i + 1,
                count: submitTargets.length,
                tabIndex: target.originalIndex,
                qNo: submitQuestionMeta.hasQNo ? submitQuestionMeta.qNo : undefined,
                lap: submitQuestionMeta.hasLap ? submitQuestionMeta.lap : undefined,
                forceLap: submitQuestionMeta.forceLap === true
              }
            );
            const hasPenInk = payloadHasAnyPenInk(payloadJson);
            const sessionNoForSave = hasPenInk ? 992 : 99;
            if (!payloadJson.meta || typeof payloadJson.meta !== "object") {
              payloadJson.meta = {};
            }
            payloadJson.meta.hasPenInk = !!hasPenInk;
            payloadJson.meta.sessionNo = sessionNoForSave;

            let posted = null;
            try {
              posted = await postSessionPayload(buildRequestBodyForSubmit(context, sessionNoForSave, payloadJson));
            } catch (err) {
              throw new Error(`template p.${target.templatePage} 제출 실패: ${err && err.message ? err.message : err}`);
            }
            submitResults.push({
              templatePage: target.templatePage,
              status: posted.status,
              sessionNo: sessionNoForSave,
              LSASId: posted.payload && posted.payload.LSASId ? posted.payload.LSASId : "",
              ServedFileURL: posted.payload && posted.payload.ServedFileURL ? posted.payload.ServedFileURL : ""
            });
          }

          trace("info", "manual submit success", {
            mode,
            count: submitResults.length,
            templatePages: submitResults.map(function (item) { return item.templatePage; }),
            statuses: submitResults.map(function (item) { return item.status; }),
            sessionNos: submitResults.map(function (item) { return item.sessionNo; }),
            qNo: submitQuestionMeta.qNo,
            lap: submitQuestionMeta.lap,
            lastLSASId: submitResults.length ? submitResults[submitResults.length - 1].LSASId : "",
            lastServedFileURL: submitResults.length ? submitResults[submitResults.length - 1].ServedFileURL : ""
          });
          clearLocalDraftStorage("server-saved");
          resetWorkspaceAfterSubmit();
          setSubmitButtonsUi("ok", "제출완료");
          queueSubmitButtonsUiReset(1500);
          showSubmitToast("제출되었습니다!");
          void fetchLiveSessions(true);
        } catch (err) {
          trace("error", "manual submit failed", err);
          setSubmitButtonsUi("error", "제출실패");
          queueSubmitButtonsUiReset(2200);
        } finally {
          isSavingSessionToServer = false;
          if (!saveButtonUiTimer) {
            setSubmitButtonsUi("idle", "제출");
          }
        }
      }

      function buildLocalDraftSnapshot() {
        syncActiveBlankTextFromEditor();
        return {
          version: 1,
          savedAt: new Date().toISOString(),
          selected: {
            grade: gradeSel.value || "",
            year: yearSel.value || "",
            examKey: examSel.value || "",
            typeLabel: typeSel.value || ""
          },
          selectedSessionId: selectedSessionId || "",
          selectedSessionTitle: selectedSessionTitle || "",
          selectedSessionTargetPage: parsePositivePage(selectedSessionTargetPage),
          overlaySide: overlaySide === "left" ? "left" : "right",
          activeTabIndex: activeMemoTabIndex,
          tabs: serializeMemoTabsForSave(memoTabs)
        };
      }

      function snapshotHasMeaningfulContent(snapshot) {
        const safe = snapshot && typeof snapshot === "object" ? snapshot : {};
        const tabs = Array.isArray(safe.tabs) ? safe.tabs : [];
        for (let i = 0; i < tabs.length; i += 1) {
          if (isTemplateTabFilled(tabs[i])) return true;
        }
        return false;
      }

      function saveLocalDraftNow(reason) {
        if (isApplyingLocalDraft) return;
        clearLocalDraftSaveTimer();
        try {
          const snapshot = buildLocalDraftSnapshot();
          if (!snapshotHasMeaningfulContent(snapshot)) {
            try {
              localStorage.removeItem(LOCAL_DRAFT_STORAGE_KEY);
            } catch (_err) {}
            setLocalDraftState(false);
            return;
          }
          localStorage.setItem(LOCAL_DRAFT_STORAGE_KEY, JSON.stringify(snapshot));
          setLocalDraftState(true);
          if (reason === "manual-save") {
            trace("info", "local draft saved", {
              key: LOCAL_DRAFT_STORAGE_KEY,
              tabCount: Array.isArray(snapshot.tabs) ? snapshot.tabs.length : 0
            });
          }
        } catch (err) {
          trace("warn", "local draft save failed", err);
        }
      }

      function restoreLocalDraftFromStorage() {
        let raw = "";
        try {
          raw = localStorage.getItem(LOCAL_DRAFT_STORAGE_KEY) || "";
        } catch (err) {
          trace("warn", "local draft read failed", err);
          setLocalDraftState(false, true);
          return false;
        }
        if (!raw) {
          setLocalDraftState(false, true);
          return false;
        }

        let parsed = null;
        try {
          parsed = JSON.parse(raw);
        } catch (err) {
          trace("warn", "local draft parse failed", err);
          clearLocalDraftStorage("invalid-json");
          return false;
        }
        if (!parsed || typeof parsed !== "object") {
          clearLocalDraftStorage("invalid-shape");
          return false;
        }

        const selected = parsed.selected && typeof parsed.selected === "object" ? parsed.selected : {};
        isApplyingLocalDraft = true;
        try {
          const savedGrade = normalizeStorageGrade(selected.grade || "");
          if (savedGrade) {
            ensureSelectValue(gradeSel, savedGrade, getGradeLabel(savedGrade));
          }
          refreshYearExamTypeOptions();
          if (selected.year) {
            ensureSelectValue(yearSel, toSafeText(selected.year), toSafeText(selected.year));
          }
          if (selected.examKey) {
            const examKey = toSafeText(selected.examKey);
            ensureSelectValue(examSel, examKey, getExamLabel(examKey, gradeSel.value || DEFAULT_GRADE));
          }
          if (selected.typeLabel) {
            const typeLabel = toSafeText(selected.typeLabel);
            ensureSelectValue(typeSel, typeLabel, typeLabel);
          }

          if (parsed.overlaySide === "left" || parsed.overlaySide === "right") {
            overlaySide = parsed.overlaySide;
          }
          selectedSessionId = toSafeText(parsed.selectedSessionId);
          selectedSessionTitle = toSafeText(parsed.selectedSessionTitle);
          selectedSessionTargetPage = parsePositivePage(parsed.selectedSessionTargetPage);

          const restoredTabs = normalizeSessionTabs(parsed.tabs);
          if (restoredTabs.length) {
            memoTabs.length = 0;
            restoredTabs.forEach(function (tab) {
              memoTabs.push(tab);
            });
          }
          nextMemoTabId = memoTabs.length + 1;
          const nextIndex = Number(parsed.activeTabIndex);
          activeMemoTabIndex = Number.isFinite(nextIndex)
            ? Math.min(Math.max(Math.trunc(nextIndex), 0), memoTabs.length - 1)
            : 0;

          applyOverlaySide();
          renderActiveMemoPane();
          renderMemoTabbar();
          setLocalDraftState(true, true);
          updateTopbarStatus();
          trace("info", "local draft restored", {
            key: LOCAL_DRAFT_STORAGE_KEY,
            savedAt: toSafeText(parsed.savedAt),
            tabCount: memoTabs.length
          });
          return true;
        } catch (err) {
          trace("warn", "local draft restore failed", err);
          return false;
        } finally {
          isApplyingLocalDraft = false;
        }
      }

      function resetPdfPreviewToEmpty(message) {
        pdfRenderToken += 1;
        hideWordTooltip();
        clearBlobUrl();
        if (message) {
          previewEmpty.textContent = message;
        }
        previewPages.innerHTML = "";
        hidePanel(previewPages);
        hidePanel(previewFrame);
        previewFrame.removeAttribute("src");
        showPanel(previewEmpty);
        newTabBtn.hidden = true;
      }

      function buildIframeBlobSrc(blobUrl, pageNumber) {
        const p = parsePositivePage(pageNumber);
        const pagePart = p ? `page=${p}&` : "";
        return `${blobUrl}#${pagePart}toolbar=0&navpanes=0&statusbar=0&messages=0&view=FitH`;
      }

      function showPdfWithIframeBlob(blob, pageNumber) {
        hideWordTooltip();
        clearBlobUrl();
        lastBlobUrl = URL.createObjectURL(blob);
        previewFrame.src = buildIframeBlobSrc(lastBlobUrl, pageNumber);
        showPanel(previewFrame);
        hidePanel(previewPages);
        hidePanel(previewEmpty);
        lockPreviewViewportHeight("iframe");
      }

      function normalizeCapturedWord(raw) {
        const text = String(raw || "").trim();
        if (!text) return "";
        const cleaned = text
          .replace(/[’`]/g, "'")
          .replace(/^[^\p{L}\p{N}]+|[^\p{L}\p{N}]+$/gu, "");
        if (!cleaned || /\s/.test(cleaned) || cleaned.length > 64) return "";
        return cleaned;
      }

      function normalizeMeaningMapKey(raw) {
        const clean = normalizeCapturedWord(raw);
        return clean ? clean.toLowerCase() : "";
      }

      function rebuildWordMeaningMap() {
        const map = new Map();
        for (let i = 0; i < memoTabs.length; i += 1) {
          const tab = memoTabs[i];
          if (!tab || tab.type !== "two_three") continue;
          const twoThree = tab.twoThree && typeof tab.twoThree === "object" ? tab.twoThree : null;
          const words = twoThree && Array.isArray(twoThree.words) ? twoThree.words : [];
          for (let j = 0; j < words.length; j += 1) {
            const row = words[j] || {};
            const key = normalizeMeaningMapKey(row.word);
            const meaning = String(row.meaning || "").trim();
            if (!key || !meaning) continue;
            map.set(key, meaning);
          }
        }
        wordMeaningMap = map;
      }

      function findMeaningForWord(word) {
        const key = normalizeMeaningMapKey(word);
        if (!key) return "";
        return wordMeaningMap.get(key) || "";
      }

      function ensureWordTooltip() {
        if (wordTooltipEl) return wordTooltipEl;
        const el = document.createElement("div");
        el.className = "pdf-word-tooltip";
        el.setAttribute("aria-hidden", "true");
        document.body.appendChild(el);
        wordTooltipEl = el;
        return wordTooltipEl;
      }

      function hideWordTooltip() {
        if (!wordTooltipEl) return;
        wordTooltipEl.classList.remove("is-visible");
        wordTooltipEl.setAttribute("aria-hidden", "true");
      }

      function showWordTooltip(text, clientX, clientY) {
        const content = String(text || "").trim();
        if (!content) {
          hideWordTooltip();
          return;
        }

        const el = ensureWordTooltip();
        el.textContent = content;
        el.classList.add("is-visible");
        el.setAttribute("aria-hidden", "false");

        const pad = 10;
        const offset = 14;
        let left = clientX + offset;
        let top = clientY + offset;

        const rect = el.getBoundingClientRect();
        if (left + rect.width + pad > window.innerWidth) {
          left = Math.max(pad, clientX - rect.width - offset);
        }
        if (top + rect.height + pad > window.innerHeight) {
          top = Math.max(pad, clientY - rect.height - offset);
        }

        el.style.left = `${Math.round(left)}px`;
        el.style.top = `${Math.round(top)}px`;
      }

      function findWordByApproxOffset(text, approxOffset) {
        const src = String(text || "");
        if (!src) return "";
        const regex = /[A-Za-z][A-Za-z0-9'-]*/g;
        let bestWord = "";
        let bestDistance = Number.POSITIVE_INFINITY;
        let match = regex.exec(src);
        while (match) {
          const start = match.index;
          const end = start + match[0].length;
          const mid = (start + end) / 2;
          const dist = Math.abs(mid - approxOffset);
          const candidate = normalizeCapturedWord(match[0]);
          if (candidate && dist < bestDistance) {
            bestDistance = dist;
            bestWord = candidate;
          }
          match = regex.exec(src);
        }
        return bestWord;
      }

      function extractWordAtOffset(text, offset) {
        const src = String(text || "");
        if (!src) return "";
        const isWordChar = function (ch) {
          return /[A-Za-z0-9'-]/.test(ch);
        };
        let start = Math.max(0, Math.min(offset, src.length));
        let end = start;
        while (start > 0 && isWordChar(src[start - 1])) {
          start -= 1;
        }
        while (end < src.length && isWordChar(src[end])) {
          end += 1;
        }
        return normalizeCapturedWord(src.slice(start, end));
      }

      function buildWordHitsFromSpan(rawText, rect, layerRect) {
        const src = String(rawText || "");
        if (!src || !rect || !layerRect || rect.width <= 0 || rect.height <= 0) return [];

        const words = [];
        const totalChars = Math.max(1, src.length);
        const regex = /[A-Za-z][A-Za-z0-9'-]*/g;
        let match = regex.exec(src);
        while (match) {
          const word = normalizeCapturedWord(match[0]);
          if (word) {
            const start = match.index;
            const end = start + match[0].length;
            words.push({
              word,
              x1: (rect.left - layerRect.left) + (rect.width * (start / totalChars)),
              x2: (rect.left - layerRect.left) + (rect.width * (end / totalChars)),
              y1: rect.top - layerRect.top,
              y2: rect.bottom - layerRect.top
            });
          }
          match = regex.exec(src);
        }
        return words;
      }

      function findWordHitAtPoint(hits, x, y) {
        if (!Array.isArray(hits) || !hits.length) return null;
        for (let idx = 0; idx < hits.length; idx += 1) {
          const hit = hits[idx];
          if (x >= hit.x1 && x <= hit.x2 && y >= hit.y1 && y <= hit.y2) {
            return hit || null;
          }
        }
        return null;
      }

      function buildWordHitsFromIndexRows(rows, scaleX, scaleY, pageHeightPx) {
        if (!Array.isArray(rows) || !rows.length) return [];
        const hits = [];

        for (let i = 0; i < rows.length; i += 1) {
          const row = rows[i];
          if (!row || !Array.isArray(row.bbox) || row.bbox.length !== 4) continue;
          const text = normalizeCapturedWord(row.text || "");
          if (!text) continue;

          const x0 = Number(row.bbox[0]) * scaleX;
          const y0 = Number(row.bbox[1]) * scaleY;
          const x1 = Number(row.bbox[2]) * scaleX;
          const y1 = Number(row.bbox[3]) * scaleY;
          if (!Number.isFinite(x0) || !Number.isFinite(y0) || !Number.isFinite(x1) || !Number.isFinite(y1)) continue;

          const lx = Math.min(x0, x1);
          const rx = Math.max(x0, x1);
          const ty = Math.min(y0, y1);
          const by = Math.max(y0, y1);
          const qNo = getWordIndexQNoFromObject(row);
          const hit = { word: text, x1: lx, y1: ty, x2: rx, y2: by };
          if (qNo > 0) {
            hit.qNo = qNo;
          }
          hits.push(hit);
        }
        return hits;
      }

      function extractWordFromTextSpan(span, event) {
        if (!span) return "";
        const raw = String(span.textContent || "");
        if (!raw.trim()) return "";

        let offset = -1;
        if (document.caretPositionFromPoint) {
          const pos = document.caretPositionFromPoint(event.clientX, event.clientY);
          if (pos && span.contains(pos.offsetNode)) {
            offset = Number(pos.offset) || 0;
          }
        } else if (document.caretRangeFromPoint) {
          const range = document.caretRangeFromPoint(event.clientX, event.clientY);
          if (range && span.contains(range.startContainer)) {
            offset = Number(range.startOffset) || 0;
          }
        }

        if (offset >= 0) {
          const atOffset = extractWordAtOffset(raw, offset);
          if (atOffset) return atOffset;
        }

        if (offset < 0) {
          const rect = span.getBoundingClientRect();
          if (rect.width > 0) {
            const ratio = Math.max(0, Math.min(1, (event.clientX - rect.left) / rect.width));
            offset = Math.round(ratio * raw.length);
          }
        }

        const byApprox = findWordByApproxOffset(raw, Math.max(0, offset));
        if (byApprox) return byApprox;

        const firstMatch = raw.match(/[A-Za-z][A-Za-z0-9'-]*/);
        return normalizeCapturedWord(firstMatch ? firstMatch[0] : "");
      }

      function appendWordToActiveMemo(word) {
        const cleanWord = normalizeCapturedWord(word);
        if (!cleanWord) return false;

        lastCapturedWord = cleanWord;
        pushWordToDictSearch(cleanWord);

        const tab = getActiveMemoTab();
        if (!tab) return false;

        if (tab.type === "blank") {
          const current = typeof tab.blankText === "string" ? tab.blankText : "";
          const next = current.trimEnd().length ? `${current.trimEnd()}\n${cleanWord}` : cleanWord;
          tab.blankText = next;
          overlayMemoText.value = next;
          overlayMemoText.scrollTop = overlayMemoText.scrollHeight;
          markMemoDirty("word-append-blank");
          return true;
        }

        if (tab.type === "two_three") {
          const twoThree = ensureTwoThreeData(tab);
          if (!twoThree || !Array.isArray(twoThree.words) || !twoThree.words.length) return false;

          const nextSlot = findNextTwoTWordSlot(twoThree.words);
          if (nextSlot < 0) {
            trace("warn", "2T 슬롯이 가득 차서 단어를 추가하지 못했습니다.");
            return false;
          }

          twoThree.words[nextSlot].word = cleanWord;
          rebuildWordMeaningMap();
          applyCapturedWordToTwoTView(nextSlot, cleanWord);
          markMemoDirty("word-append-two-three");
          return true;
        }

        return false;
      }

      async function renderPdfPagesWithTextLayer(blob, options) {
        const opts = options && typeof options === "object" ? options : {};
        const preferredPage = parsePositivePage(opts.preferredPage);
        if (!window.pdfjsLib) {
          throw new Error("pdf.js is not loaded");
        }
        pdfjsLib.GlobalWorkerOptions.workerSrc = PDFJS_WORKER_SRC;
        hideWordTooltip();

        const myToken = ++pdfRenderToken;
        const bytes = await blob.arrayBuffer();
        const loadingTask = pdfjsLib.getDocument({ data: bytes });
        const pdfDoc = await loadingTask.promise;

        previewPages.innerHTML = "";
        previewPages.style.minHeight = "0";
        previewPages.style.height = "100%";
        hidePanel(previewFrame);
        previewFrame.removeAttribute("src");
        showPanel(previewPages);
        hidePanel(previewEmpty);
        lockPreviewViewportHeight("before-render");
        let jumpedToPreferredDuringRender = false;

        for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum += 1) {
          if (myToken !== pdfRenderToken) return;
          const page = await pdfDoc.getPage(pageNum);
          const baseViewport = page.getViewport({ scale: 1 });
          const hostWidth = (previewPages.parentElement && previewPages.parentElement.clientWidth) || previewPages.clientWidth;
          const usableWidth = Math.max(320, hostWidth - 24);
          const scale = Math.max(1, Math.min(2.7, usableWidth / baseViewport.width));
          const viewport = page.getViewport({ scale });
          const deviceScale = Math.max(1, window.devicePixelRatio || 1);
          const outputScale = Math.min(4, Math.max(1, deviceScale * RENDER_QUALITY_BOOST));

          const pageWrap = document.createElement("div");
          pageWrap.className = "pdf-page";
          pageWrap.style.width = `${viewport.width}px`;
          pageWrap.style.height = `${viewport.height}px`;

          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d", { alpha: false });
          canvas.width = Math.floor(viewport.width * outputScale);
          canvas.height = Math.floor(viewport.height * outputScale);
          canvas.style.width = `${viewport.width}px`;
          canvas.style.height = `${viewport.height}px`;
          bindTouchDragScrollBridge(canvas);

          pageWrap.appendChild(canvas);
          previewPages.appendChild(pageWrap);

          const renderContext = {
            canvasContext: ctx,
            viewport
          };
          if (outputScale !== 1) {
            renderContext.transform = [outputScale, 0, 0, outputScale, 0, 0];
          }
          await page.render(renderContext).promise;
          if (preferredPage && !jumpedToPreferredDuringRender && pageNum === preferredPage) {
            const moved = jumpToPreferredPage(preferredPage);
            if (moved) {
              jumpedToPreferredDuringRender = true;
              trace("info", `session early page jump: p.${preferredPage}`);
            }
          }

          const indexPages = activeWordIndex && activeWordIndex.pages && typeof activeWordIndex.pages === "object"
            ? activeWordIndex.pages
            : null;
          const indexRows = indexPages
            ? (indexPages[String(pageNum)] || indexPages[pageNum] || [])
            : [];
          const scaleX = viewport.width / baseViewport.width;
          const scaleY = viewport.height / baseViewport.height;
          const wordHits = buildWordHitsFromIndexRows(indexRows, scaleX, scaleY, viewport.height);
          canvas.style.cursor = wordHits.length ? "pointer" : "default";
          const pickWordHitByClientPoint = function (clientX, clientY) {
            if (!wordHits.length) return null;
            const rect = canvas.getBoundingClientRect();
            const px = clientX - rect.left;
            const py = clientY - rect.top;
            return findWordHitAtPoint(wordHits, px, py);
          };
          const showMeaningByClientPoint = function (clientX, clientY) {
            const foundHit = pickWordHitByClientPoint(clientX, clientY);
            if (!foundHit || !foundHit.word) {
              canvas.style.cursor = "default";
              hideWordTooltip();
              return;
            }
            const found = foundHit.word;
            const meaning = findMeaningForWord(found);
            canvas.style.cursor = meaning ? "help" : "pointer";
            if (meaning) {
              showWordTooltip(meaning, clientX, clientY);
            } else {
              hideWordTooltip();
            }
          };
          let lastPenTapAt = 0;

          if (wordHits.length) {
            canvas.addEventListener("mousemove", function (event) {
              showMeaningByClientPoint(event.clientX, event.clientY);
            }, { passive: true });
            canvas.addEventListener("pointermove", function (event) {
              if (event.pointerType === "touch") return;
              showMeaningByClientPoint(event.clientX, event.clientY);
            }, { passive: true });
            canvas.addEventListener("mouseleave", function () {
              canvas.style.cursor = "default";
              hideWordTooltip();
            }, { passive: true });
            canvas.addEventListener("pointerleave", function () {
              canvas.style.cursor = "default";
              hideWordTooltip();
            }, { passive: true });
            canvas.addEventListener("pointercancel", function () {
              canvas.style.cursor = "default";
              hideWordTooltip();
            }, { passive: true });
            canvas.addEventListener("pointerup", function (event) {
              if (event.pointerType !== "pen") return;
              if (Date.now() - lastPreviewScrollAt < 140) return;
              const hit = pickWordHitByClientPoint(event.clientX, event.clientY);
              if (!hit || !hit.word) return;
              lastPenTapAt = Date.now();
              const qNoUpdated = setActiveTabQuestionNoFromWordHit(hit.qNo);
              const added = appendWordToActiveMemo(hit.word);
              if (added || qNoUpdated) {
                trace("info", `memo append word (pen): ${hit.word}${hit.qNo ? ` / Q${hit.qNo}` : ""}`);
              }
              hideWordTooltip();
            }, { passive: true });
          }

          canvas.addEventListener("wheel", function (event) {
            const host = previewPages;
            if (!host) return;
            const before = host.scrollTop;
            host.scrollTop += event.deltaY;
            host.scrollLeft += event.deltaX;
            if (DEBUG_SCROLL_DIAG) {
              trace("info", "diag/canvas-wheel", {
                deltaY: event.deltaY,
                before,
                after: host.scrollTop,
                changed: host.scrollTop !== before
              });
            }
            hideWordTooltip();
            event.preventDefault();
          }, { passive: false });

          canvas.addEventListener("click", function (event) {
            if (Date.now() - lastPenTapAt < 120) return;
            if (Date.now() - lastPreviewScrollAt < 140) return;
            if (!wordHits.length) return;
            const hit = pickWordHitByClientPoint(event.clientX, event.clientY);
            if (!hit || !hit.word) return;
            const qNoUpdated = setActiveTabQuestionNoFromWordHit(hit.qNo);
            const added = appendWordToActiveMemo(hit.word);
            if (added || qNoUpdated) {
              trace("info", `memo append word: ${hit.word}${hit.qNo ? ` / Q${hit.qNo}` : ""}`);
            }
            hideWordTooltip();
          });
        }
        if (DEBUG_SCROLL_DIAG) {
          trace("info", "diag/render-done", {
            host: getScrollHostMetrics(previewPages),
            pagesClientHeight: previewPages.clientHeight,
            pagesScrollHeight: previewPages.scrollHeight
          });
        }
        lockPreviewViewportHeight("after-render");
        return {
          jumpedToPreferredDuringRender
        };
      }

      function getExamLabel(examKey, gradeValue) {
        const normalizedGrade = normalizeStorageGrade(gradeValue || DEFAULT_GRADE);
        const effectiveGrade = EXAM_KEYS_BY_GRADE[normalizedGrade] ? normalizedGrade : DEFAULT_GRADE;
        if (examKey === "november" && effectiveGrade === "High3") {
          return "수능";
        }
        const row = EXAM_META.find(item => item.key === examKey);
        return row ? row.label : "";
      }

      function getExamOptionsForGrade(gradeValue) {
        const normalizedGrade = normalizeStorageGrade(gradeValue || DEFAULT_GRADE);
        const effectiveGrade = EXAM_KEYS_BY_GRADE[normalizedGrade] ? normalizedGrade : DEFAULT_GRADE;
        const keys = EXAM_KEYS_BY_GRADE[effectiveGrade] || [];
        return keys.map(function (key) {
          return {
            value: key,
            label: getExamLabel(key, effectiveGrade)
          };
        });
      }

      function getGradeLabel(gradeValue) {
        const row = GRADE_OPTIONS.find(function (item) {
          return item.value === gradeValue;
        });
        return row ? row.label : String(gradeValue || "");
      }

      function getSessionDateLabel(session) {
        if (!session || typeof session !== "object") return "";
        return String(session.date || session.scheduledAt || session.LiveSchedule || session.title || "").trim();
      }

      function getSessionKey(session, idx) {
        if (session && session._row && session._row.LSASId != null) {
          return `${FIXED_STUDENT_ID || "student"}::${String(session._row.LSASId)}`;
        }
        const dateLabel = getSessionDateLabel(session) || `slot-${idx + 1}`;
        return `${FIXED_STUDENT_ID || "student"}::${dateLabel}::${idx}`;
      }

      function ensureSelectValue(selectEl, value, label) {
        if (!value) return;
        const hasOption = Array.from(selectEl.options).some(function (opt) {
          return opt.value === value;
        });
        if (!hasOption) {
          const option = document.createElement("option");
          option.value = value;
          option.textContent = label || value;
          selectEl.appendChild(option);
        }
        selectEl.value = value;
      }

      function normalizeSessionTabs(rawTabs) {
        const sourceTabs = Array.isArray(rawTabs) && rawTabs.length ? rawTabs : [{ type: "blank", blankText: "" }];
        return sourceTabs.map(function (raw, idx) {
          const safeRaw = raw && typeof raw === "object" ? raw : {};
          const type = safeRaw.type === "two_three" ? "two_three" : "blank";
          const parsedQNo = parseQNoForPayload(getRawQNoFromAny(safeRaw));
          const rawLap = getRawLapFromAny(safeRaw);
          const hasRawLap = hasMeaningfulText(rawLap);
          const normalizedLap = normalizeLapForPayload(rawLap);
          const applyTabMeta = function (target) {
            if (!target || typeof target !== "object") return target;
            if (parsedQNo > 0) {
              target.QNo = parsedQNo;
              target.qNo = parsedQNo;
            }
            if (hasRawLap || normalizedLap !== DEFAULT_PAYLOAD_LAP) {
              target.Lap = normalizedLap;
              target.lap = normalizedLap;
            }
            return target;
          };
          if (type === "two_three") {
            const sourceWords = Array.isArray(safeRaw.words)
              ? safeRaw.words
              : (safeRaw.twoThree && Array.isArray(safeRaw.twoThree.words) ? safeRaw.twoThree.words : []);
            const sourceSentences = Array.isArray(safeRaw.sentences)
              ? safeRaw.sentences
              : (safeRaw.twoThree && Array.isArray(safeRaw.twoThree.sentences) ? safeRaw.twoThree.sentences : []);
            const words = sourceWords.map(function (row) {
              const safeRow = row && typeof row === "object" ? row : {};
              return {
                word: typeof safeRow.word === "string" ? safeRow.word : "",
                meaning: typeof safeRow.meaning === "string" ? safeRow.meaning : ""
              };
            });
            const sentences = sourceSentences.map(function (row) {
              const safeRow = row && typeof row === "object" ? row : {};
              const sentenceCard = {
                sentence: typeof safeRow.sentence === "string" ? safeRow.sentence : ""
              };
              if (Array.isArray(safeRow.ink)) {
                sentenceCard.ink = safeRow.ink;
              };
              ensureThreeSentenceInk(sentenceCard);
              return sentenceCard;
            });
            return applyTabMeta({
              id: idx + 1,
              type: "two_three",
              blankText: "",
              blankInk: [],
              twoThree: { words, sentences }
            });
          }
          const blankTab = {
            id: idx + 1,
            type: "blank",
            blankText: typeof safeRaw.blankText === "string" ? safeRaw.blankText : "",
            blankInk: Array.isArray(safeRaw.blankInk) ? safeRaw.blankInk : [],
            twoThree: null
          };
          ensureBlankInk(blankTab);
          return applyTabMeta(blankTab);
        });
      }

      function setSessionSubLabel(text) {
        if (!sessionSub) return;
        sessionSub.textContent = String(text || "");
      }

      function renderSessionListMessage(text) {
        const msg = document.createElement("div");
        msg.className = "session-item-note";
        msg.style.padding = "10px 6px";
        msg.textContent = String(text || "");
        sessionList.appendChild(msg);
      }

      function normalizeMockYear(value) {
        if (typeof value === "string" && /^\d{4}to\d{4}$/.test(value.trim())) {
          return value.trim();
        }
        const n = Number(value);
        if (!Number.isFinite(n)) return "";
        const year = Math.trunc(n);
        return `${year}to${year + 1}`;
      }

      function monthToExamKey(value) {
        const n = Number(value);
        if (!Number.isFinite(n)) return "";
        const month = Math.trunc(n);
        const map = {
          3: "march",
          4: "april",
          6: "june",
          7: "july",
          9: "september",
          10: "october",
          11: "november"
        };
        return map[month] || "";
      }

      function normalizeStorageGrade(qLevelValue) {
        const text = toSafeText(qLevelValue).trim();
        if (!text) return DEFAULT_GRADE;
        const ko = text.match(/^고\s*([1-3])$/);
        if (ko) return `High${ko[1]}`;
        const high = text.match(/^high\s*([1-3])$/i);
        if (high) return `High${high[1]}`;
        return text;
      }

      function parseReceiveRows(payload) {
        if (Array.isArray(payload)) return payload;
        if (payload && Array.isArray(payload.rows)) return payload.rows;
        return [];
      }

      function toSafeText(value) {
        if (value === null || value === undefined) return "";
        if (typeof value === "string") return value;
        if (typeof value === "number" || typeof value === "boolean") return String(value);
        try {
          if (typeof value.toISOString === "function") {
            return String(value.toISOString());
          }
          if (typeof value.toString === "function") {
            const text = String(value.toString());
            if (text && text !== "[object Object]") {
              return text;
            }
          }
        } catch (_err) {
          return "";
        }
        return "";
      }

      function normalizeLooseKeyName(value) {
        return toSafeText(value).replace(/[^a-z0-9]/gi, "").toLowerCase();
      }

      function findObjectValueByAliases(source, aliases) {
        const safeSource = source && typeof source === "object" ? source : null;
        if (!safeSource) return null;
        const aliasList = Array.isArray(aliases) ? aliases : [];
        for (let i = 0; i < aliasList.length; i += 1) {
          const alias = aliasList[i];
          if (!alias) continue;
          if (Object.prototype.hasOwnProperty.call(safeSource, alias) && safeSource[alias] != null) {
            return { key: alias, value: safeSource[alias] };
          }
        }
        if (!aliasList.length) return null;

        const normalizedAliases = [];
        for (let i = 0; i < aliasList.length; i += 1) {
          const normalized = normalizeLooseKeyName(aliasList[i]);
          if (!normalized) continue;
          if (normalizedAliases.indexOf(normalized) < 0) {
            normalizedAliases.push(normalized);
          }
        }
        if (!normalizedAliases.length) return null;

        const keys = Object.keys(safeSource);
        for (let i = 0; i < keys.length; i += 1) {
          const key = keys[i];
          const value = safeSource[key];
          if (value == null) continue;
          if (normalizedAliases.indexOf(normalizeLooseKeyName(key)) >= 0) {
            return { key, value };
          }
        }
        return null;
      }

      function getObjectValueByAliases(source, aliases) {
        const found = findObjectValueByAliases(source, aliases);
        return found ? found.value : undefined;
      }

      function getRawQNoFromAny(source) {
        return getObjectValueByAliases(source, [
          "QNo",
          "qNo",
          "question_no",
          "questionNo",
          "q_no",
          "problem_number",
          "problemNo",
          "problem_no"
        ]);
      }

      function getRawLapFromAny(source) {
        return getObjectValueByAliases(source, [
          "Lap",
          "lap",
          "lap_no",
          "lapNo",
          "LapNo",
          "LAP"
        ]);
      }

      function getRawSessionNoFromAny(source) {
        return getObjectValueByAliases(source, [
          "SessionNo",
          "sessionNo",
          "session_no",
          "sessionno",
          "SESSIONNO"
        ]);
      }

      function getPayloadFieldFromReceiveRow(row) {
        const safeRow = row && typeof row === "object" ? row : {};
        const direct = findObjectValueByAliases(safeRow, [
          "PayloadJson",
          "payloadJson",
          "PayloadJSON",
          "payload_json",
          "payloadjson",
          "Payload",
          "payload"
        ]);
        if (direct && direct.value != null) return direct;

        const keys = Object.keys(safeRow);
        for (let i = 0; i < keys.length; i += 1) {
          const key = keys[i];
          const value = safeRow[key];
          if (value == null) continue;
          const normalizedKey = normalizeLooseKeyName(key);
          if (
            normalizedKey.indexOf("payloadjson") >= 0 ||
            normalizedKey === "payload" ||
            /payload$/.test(normalizedKey)
          ) {
            return { key, value };
          }
        }
        return null;
      }

      function parsePayloadObjectLoose(value) {
        if (!value) return null;
        if (value && typeof value === "object") return value;
        const text = toSafeText(value).trim();
        if (!text) return null;
        try {
          const parsed = JSON.parse(text);
          return parsed && typeof parsed === "object" ? parsed : null;
        } catch (_err) {
          return null;
        }
      }

      function extractPayloadFromReceiveRow(row) {
        const safeRow = row && typeof row === "object" ? row : {};
        const foundPayloadField = getPayloadFieldFromReceiveRow(safeRow);
        const candidates = [];
        if (foundPayloadField && foundPayloadField.value != null) {
          candidates.push(foundPayloadField.value);
        }

        const nestedContainerCandidates = [
          getObjectValueByAliases(safeRow, ["data", "Data", "row", "Row", "record", "Record"]),
          getObjectValueByAliases(safeRow, ["result", "Result", "item", "Item"])
        ];
        for (let i = 0; i < nestedContainerCandidates.length; i += 1) {
          const nested = nestedContainerCandidates[i];
          if (!nested || typeof nested !== "object") continue;
          const nestedField = getPayloadFieldFromReceiveRow(nested);
          if (nestedField && nestedField.value != null) {
            candidates.push(nestedField.value);
          }
        }

        for (let i = 0; i < candidates.length; i += 1) {
          const parsed = parsePayloadObjectLoose(candidates[i]);
          if (!parsed) continue;
          const nestedPayloadField = getPayloadFieldFromReceiveRow(parsed);
          if (nestedPayloadField && nestedPayloadField.value != null) {
            const nestedParsed = parsePayloadObjectLoose(nestedPayloadField.value);
            if (nestedParsed) return nestedParsed;
          }
          return parsed;
        }
        return null;
      }

      function trimForLog(value, maxLength) {
        const text = toSafeText(value);
        if (!text) return "";
        const limit = Number.isFinite(Number(maxLength)) ? Math.max(0, Math.trunc(Number(maxLength))) : 240;
        if (!limit || text.length <= limit) return text;
        return `${text.slice(0, limit)}...`;
      }

      function normalizeWordIndexPage(value) {
        const n = Number(value);
        if (!Number.isFinite(n)) return null;
        const page = Math.trunc(n);
        return page > 0 ? page : null;
      }

      function normalizeWordIndexIdx(value) {
        const n = Number(value);
        if (!Number.isFinite(n)) return null;
        const idx = Math.trunc(n);
        return idx >= 0 ? idx : null;
      }

      function normalizeWordIndexBBox(value) {
        if (!Array.isArray(value) || value.length < 4) return null;
        const x0 = Number(value[0]);
        const y0 = Number(value[1]);
        const x1 = Number(value[2]);
        const y1 = Number(value[3]);
        if (![x0, y0, x1, y1].every(Number.isFinite)) return null;
        return [x0, y0, x1, y1];
      }

      function parseWordIndexQNo(value) {
        const parsed = parseQNoForPayload(value);
        return parsed > 0 ? parsed : 0;
      }

      function parseWordIndexTupleRef(value) {
        if (Array.isArray(value) && value.length >= 2) {
          const a = Number(value[0]);
          const b = Number(value[1]);
          if (Number.isFinite(a) && Number.isFinite(b)) {
            return [Math.trunc(a), Math.trunc(b)];
          }
          return null;
        }
        const text = toSafeText(value).trim();
        if (!text) return null;
        const nums = text.match(/-?\d+/g);
        if (!nums || nums.length < 2) return null;
        const a = Number(nums[0]);
        const b = Number(nums[1]);
        if (!Number.isFinite(a) || !Number.isFinite(b)) return null;
        return [Math.trunc(a), Math.trunc(b)];
      }

      function parseWordIndexLineRef(value) {
        if (Array.isArray(value) && value.length >= 2) {
          const col = Number(value[0]);
          const line = Number(value[1]);
          if (Number.isFinite(col) && Number.isFinite(line)) {
            return [Math.trunc(col), Math.trunc(line)];
          }
          return null;
        }
        if (value && typeof value === "object") {
          const col = Number(getObjectValueByAliases(value, ["col", "column", "c"]));
          const line = Number(getObjectValueByAliases(value, ["line_id", "lineId", "line", "id"]));
          if (Number.isFinite(col) && Number.isFinite(line)) {
            return [Math.trunc(col), Math.trunc(line)];
          }
        }
        return parseWordIndexTupleRef(value);
      }

      function getWordIndexQNoFromObject(source) {
        const safe = source && typeof source === "object" ? source : null;
        if (!safe) return 0;
        const direct = getObjectValueByAliases(safe, [
          "problem_number",
          "problemNumber",
          "problem_no",
          "problemNo",
          "problem",
          "QNo",
          "qNo",
          "question_no",
          "questionNo",
          "q_no",
          "pno",
          "no"
        ]);
        const directParsed = parseWordIndexQNo(direct);
        if (directParsed > 0) return directParsed;
        const meta = safe.meta && typeof safe.meta === "object" ? safe.meta : null;
        if (meta) {
          const metaValue = getObjectValueByAliases(meta, [
            "problem_number",
            "problemNumber",
            "problem_no",
            "problemNo",
            "problem",
            "QNo",
            "qNo",
            "question_no",
            "questionNo",
            "q_no",
            "pno",
            "no"
          ]);
          const metaParsed = parseWordIndexQNo(metaValue);
          if (metaParsed > 0) return metaParsed;
        }
        return 0;
      }

      function parseWordIndexRow(value, fallbackPage) {
        const pageFallback = normalizeWordIndexPage(fallbackPage);
        if (value && typeof value === "object") {
          const text = normalizeCapturedWord(value.text != null ? value.text : value.word);
          const bbox = normalizeWordIndexBBox(value.bbox);
          const page = normalizeWordIndexPage(value.page != null ? value.page : pageFallback);
          const idx = normalizeWordIndexIdx(getObjectValueByAliases(value, [
            "idx",
            "word_index",
            "wordIndex",
            "word_idx",
            "wordIdx",
            "index"
          ]));
          const qNo = getWordIndexQNoFromObject(value);
          if (text && bbox && page) {
            return { text, bbox, page, idx, qNo };
          }
        }
        if (Array.isArray(value) && value.length >= 5) {
          const bbox = normalizeWordIndexBBox(value.slice(0, 4));
          const text = normalizeCapturedWord(value[4]);
          const page = pageFallback;
          const qNo = parseWordIndexQNo(value.length >= 6 ? value[5] : null);
          const idx = normalizeWordIndexIdx(value.length >= 7 ? value[6] : null);
          if (text && bbox && page) {
            return { text, bbox, page, idx, qNo };
          }
        }
        return null;
      }

      function extractWordIndexObjects(root) {
        const out = [];
        const push = function (value) {
          if (!value || typeof value !== "object") return;
          if (out.indexOf(value) < 0) out.push(value);
        };
        push(root);
        if (!root || typeof root !== "object") return out;
        push(root.ix);
        push(root.data);
        push(root.payload);
        push(root.index);
        return out;
      }

      function normalizeWordIndexData(rawData) {
        const objects = extractWordIndexObjects(rawData);
        const pages = {};
        const dedupe = new Set();
        const dedupeRowByKey = new Map();

        const makeWordRefKey = function (page, idx) {
          const pageNum = normalizeWordIndexPage(page);
          const idxNum = normalizeWordIndexIdx(idx);
          if (!pageNum || idxNum == null) return "";
          return `${pageNum}:${idxNum}`;
        };

        const makeLineRefKey = function (col, lineId) {
          const colNum = normalizeWordIndexIdx(col);
          const lineNum = normalizeWordIndexIdx(lineId);
          if (colNum == null || lineNum == null) return "";
          return `${colNum}:${lineNum}`;
        };

        const buildWordIndexLookup = function (obj) {
          const safeObj = obj && typeof obj === "object" ? obj : {};
          const wordToProblem = new Map();
          const wordToLine = new Map();
          const lineToProblem = new Map();

          const addWordToProblemMap = function (mapValue) {
            if (!mapValue || typeof mapValue !== "object") return;
            const keys = Object.keys(mapValue);
            for (let i = 0; i < keys.length; i += 1) {
              const key = keys[i];
              const pair = parseWordIndexTupleRef(key);
              if (!pair) continue;
              const wordKey = makeWordRefKey(pair[0], pair[1]);
              if (!wordKey) continue;
              const qNo = parseWordIndexQNo(mapValue[key]);
              wordToProblem.set(wordKey, qNo > 0 ? qNo : 0);
            }
          };

          const addWordToLineMap = function (mapValue) {
            if (!mapValue || typeof mapValue !== "object") return;
            const keys = Object.keys(mapValue);
            for (let i = 0; i < keys.length; i += 1) {
              const key = keys[i];
              const pair = parseWordIndexTupleRef(key);
              if (!pair) continue;
              const wordKey = makeWordRefKey(pair[0], pair[1]);
              if (!wordKey) continue;
              const lineRef = parseWordIndexLineRef(mapValue[key]);
              if (!lineRef) continue;
              const lineKey = makeLineRefKey(lineRef[0], lineRef[1]);
              if (!lineKey) continue;
              wordToLine.set(wordKey, lineKey);
            }
          };

          const addLineToProblemMap = function (mapValue) {
            if (!mapValue || typeof mapValue !== "object") return;
            const keys = Object.keys(mapValue);
            for (let i = 0; i < keys.length; i += 1) {
              const key = keys[i];
              const lineRef = parseWordIndexLineRef(key);
              if (!lineRef) continue;
              const lineKey = makeLineRefKey(lineRef[0], lineRef[1]);
              if (!lineKey) continue;
              const qNo = parseWordIndexQNo(mapValue[key]);
              lineToProblem.set(lineKey, qNo > 0 ? qNo : 0);
            }
          };

          addWordToProblemMap(safeObj.word_to_problem);
          addWordToProblemMap(safeObj.wordToProblem);
          addWordToLineMap(safeObj.word_to_line);
          addWordToLineMap(safeObj.wordToLine);
          addLineToProblemMap(safeObj.line_to_problem);
          addLineToProblemMap(safeObj.lineToProblem);

          return {
            wordToProblem,
            wordToLine,
            lineToProblem
          };
        };

        const getWordQNoFromLookup = function (rowObj, lookup) {
          if (!rowObj || !lookup) return 0;
          const wordKey = makeWordRefKey(rowObj.page, rowObj.idx);
          if (!wordKey) return 0;
          const direct = parseWordIndexQNo(lookup.wordToProblem.get(wordKey));
          if (direct > 0) return direct;
          const lineKey = lookup.wordToLine.get(wordKey);
          if (!lineKey) return 0;
          return parseWordIndexQNo(lookup.lineToProblem.get(lineKey));
        };

        const addParsedRow = function (rowObj) {
          if (!rowObj) return;
          const page = normalizeWordIndexPage(rowObj.page);
          if (!page) return;
          const text = normalizeCapturedWord(rowObj.text);
          const bbox = normalizeWordIndexBBox(rowObj.bbox);
          const qNo = parseWordIndexQNo(rowObj.qNo);
          if (!text || !bbox) return;
          const key = `${page}|${text.toLowerCase()}|${bbox.map(function (v) { return Number(v).toFixed(3); }).join(",")}`;
          if (dedupe.has(key)) {
            if (qNo > 0) {
              const existingRow = dedupeRowByKey.get(key);
              if (existingRow && parseWordIndexQNo(existingRow.qNo) <= 0) {
                existingRow.qNo = qNo;
              }
            }
            return;
          }
          dedupe.add(key);
          const pageKey = String(page);
          if (!Array.isArray(pages[pageKey])) pages[pageKey] = [];
          const row = { text, bbox };
          if (qNo > 0) row.qNo = qNo;
          pages[pageKey].push(row);
          dedupeRowByKey.set(key, row);
        };

        const addRowsFromCollection = function (rows, fallbackPage, options) {
          const opts = options && typeof options === "object" ? options : {};
          const lookup = opts.lookup || null;
          const fallbackQNo = parseWordIndexQNo(opts.fallbackQNo);
          if (!Array.isArray(rows)) return;
          for (let i = 0; i < rows.length; i += 1) {
            const parsed = parseWordIndexRow(rows[i], fallbackPage);
            if (!parsed) continue;
            let qNo = parseWordIndexQNo(parsed.qNo);
            if (qNo <= 0 && fallbackQNo > 0) {
              qNo = fallbackQNo;
            }
            if (qNo <= 0 && lookup) {
              qNo = getWordQNoFromLookup(parsed, lookup);
            }
            if (qNo > 0) {
              parsed.qNo = qNo;
            }
            addParsedRow(parsed);
          }
        };

        const addPageMap = function (pageMap, lookup) {
          if (!pageMap || typeof pageMap !== "object") return;
          const keys = Object.keys(pageMap);
          for (let i = 0; i < keys.length; i += 1) {
            const key = keys[i];
            const page = normalizeWordIndexPage(key);
            if (!page) continue;
            addRowsFromCollection(pageMap[key], page, { lookup });
          }
        };

        const addCardRows = function (cardList, options) {
          const opts = options && typeof options === "object" ? options : {};
          const fallbackQNo = parseWordIndexQNo(opts.fallbackQNo);
          const lookup = opts.lookup || null;
          if (!Array.isArray(cardList)) return;
          for (let i = 0; i < cardList.length; i += 1) {
            const card = cardList[i] && typeof cardList[i] === "object" ? cardList[i] : null;
            if (!card) continue;
            const cardPage = normalizeWordIndexPage(card.page);
            const cardOwnQNo = parseWordIndexQNo(getWordIndexQNoFromObject(card));
            const cardQNo = cardOwnQNo > 0 ? cardOwnQNo : fallbackQNo;
            addRowsFromCollection(card.tokens, cardPage, {
              fallbackQNo: cardQNo,
              lookup
            });

            const lineText = normalizeCapturedWord(
              card.text != null
                ? card.text
                : (card.sentence != null ? card.sentence : "")
            );
            const lineBBox = normalizeWordIndexBBox(card.bbox);
            if (lineText && lineBBox && cardPage) {
              addParsedRow({
                text: lineText,
                bbox: lineBBox,
                page: cardPage,
                qNo: cardQNo
              });
            }
          }
        };

        const addProblemPayloads = function (value, lookup) {
          if (!value) return;
          const list = [];
          if (Array.isArray(value)) {
            for (let i = 0; i < value.length; i += 1) list.push({ key: "", item: value[i] });
          } else if (typeof value === "object") {
            const keys = Object.keys(value);
            for (let i = 0; i < keys.length; i += 1) {
              list.push({ key: keys[i], item: value[keys[i]] });
            }
          }

          for (let i = 0; i < list.length; i += 1) {
            const entry = list[i] && typeof list[i] === "object" ? list[i] : null;
            const item = entry && entry.item && typeof entry.item === "object" ? entry.item : null;
            if (!item) continue;
            const fromItem = parseWordIndexQNo(getWordIndexQNoFromObject(item));
            const fromKey = entry ? parseWordIndexQNo(entry.key) : 0;
            const payloadQNo = fromItem > 0 ? fromItem : fromKey;
            addCardRows(item.sentence_cards, { fallbackQNo: payloadQNo, lookup });
            addCardRows(item.choice_cards, { fallbackQNo: payloadQNo, lookup });
            addCardRows(item.paragraph_cards, { fallbackQNo: payloadQNo, lookup });
            addCardRows(item.cards, { fallbackQNo: payloadQNo, lookup });
            addRowsFromCollection(item.tokens, normalizeWordIndexPage(item.page), {
              fallbackQNo: payloadQNo,
              lookup
            });
          }
        };

        for (let i = 0; i < objects.length; i += 1) {
          const obj = objects[i];
          const lookup = buildWordIndexLookup(obj);
          const beforePageMapRows = dedupe.size;
          addPageMap(obj.pages, lookup);
          addPageMap(obj.page_words, lookup);
          addPageMap(obj.pageWords, lookup);
          const hasWordMapLookup = lookup.wordToProblem.size > 0 || lookup.wordToLine.size > 0;
          if (dedupe.size > beforePageMapRows && hasWordMapLookup) {
            continue;
          }
          addRowsFromCollection(obj.words, null, { lookup });
          addCardRows(obj.sentence_cards, { lookup });
          addCardRows(obj.choice_cards, { lookup });
          addCardRows(obj.paragraph_cards, { lookup });
          addProblemPayloads(obj.problems, lookup);
          addProblemPayloads(obj.problem_payloads, lookup);
          addProblemPayloads(obj.problemPayloads, lookup);
        }

        const pageKeys = Object.keys(pages);
        for (let i = 0; i < pageKeys.length; i += 1) {
          const key = pageKeys[i];
          pages[key].sort(function (a, b) {
            const ay = Number(a && a.bbox ? a.bbox[1] : Number.POSITIVE_INFINITY);
            const by = Number(b && b.bbox ? b.bbox[1] : Number.POSITIVE_INFINITY);
            if (ay !== by) return ay - by;
            const ax = Number(a && a.bbox ? a.bbox[0] : Number.POSITIVE_INFINITY);
            const bx = Number(b && b.bbox ? b.bbox[0] : Number.POSITIVE_INFINITY);
            return ax - bx;
          });
        }

        return {
          raw: rawData,
          pages
        };
      }

      function makeLiveRowLogPreview(row, idx) {
        const safeRow = row && typeof row === "object" ? row : {};
        const payloadField = getPayloadFieldFromReceiveRow(safeRow);
        const payloadRaw = payloadField ? payloadField.value : "";
        const payloadText = toSafeText(payloadRaw);
        return {
          idx: idx + 1,
          LSASId: toSafeText(safeRow.LSASId),
          LiveSchedule: toSafeText(safeRow.LiveSchedule),
          UpdatedAt: toSafeText(safeRow.UpdatedAt),
          QLevel: toSafeText(safeRow.QLevel),
          QYear: toSafeText(safeRow.QYear),
          QMonth: toSafeText(safeRow.QMonth),
          QNo: toSafeText(getRawQNoFromAny(safeRow)),
          Lap: toSafeText(getRawLapFromAny(safeRow)),
          SessionNo: toSafeText(getRawSessionNoFromAny(safeRow)),
          PayloadFieldKey: payloadField ? payloadField.key : "",
          HasPayloadJson: !!payloadText,
          PayloadJsonLen: payloadText.length,
          ServedFileURL: trimForLog(safeRow.ServedFileURL, 180)
        };
      }

      function formatMonthDayWeekKorean(year, month, day) {
        const y = Number(year);
        const m = Number(month);
        const d = Number(day);
        if (!Number.isFinite(y) || !Number.isFinite(m) || !Number.isFinite(d)) return "";
        const date = new Date(y, m - 1, d);
        if (
          date.getFullYear() !== y ||
          date.getMonth() !== (m - 1) ||
          date.getDate() !== d
        ) {
          return "";
        }
        const weekdays = ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"];
        return `${m}월${d}일 ${weekdays[date.getDay()]}`;
      }

      function formatLiveScheduleLabel(value) {
        const text = toSafeText(value).trim();
        if (!text) return "";

        const match = text.match(/(\d{4})\D+(\d{1,2})\D+(\d{1,2})/);
        if (match) {
          const formatted = formatMonthDayWeekKorean(match[1], match[2], match[3]);
          if (formatted) return formatted;
        }

        const parsed = new Date(text);
        if (Number.isNaN(parsed.getTime())) return "";
        return formatMonthDayWeekKorean(
          parsed.getFullYear(),
          parsed.getMonth() + 1,
          parsed.getDate()
        );
      }

      function parseScheduleDate(value) {
        if (value instanceof Date && !Number.isNaN(value.getTime())) {
          return new Date(value.getTime());
        }
        const text = toSafeText(value).trim();
        if (!text) return null;

        const match = text.match(
          /(\d{4})\D+(\d{1,2})\D+(\d{1,2})(?:\D+(\d{1,2}))?(?:\D+(\d{1,2}))?(?:\D+(\d{1,2}))?/
        );
        if (match) {
          const y = Number(match[1]);
          const m = Number(match[2]);
          const d = Number(match[3]);
          const h = Number(match[4] || 0);
          const min = Number(match[5] || 0);
          const sec = Number(match[6] || 0);
          const date = new Date(y, m - 1, d, h, min, sec);
          if (!Number.isNaN(date.getTime())) return date;
        }

        const parsed = new Date(text);
        if (Number.isNaN(parsed.getTime())) return null;
        return parsed;
      }

      function getThisWeekStartMs(baseDate) {
        const d = new Date(baseDate);
        d.setHours(0, 0, 0, 0);
        const day = d.getDay();
        const diffToMonday = (day + 6) % 7;
        d.setDate(d.getDate() - diffToMonday);
        return d.getTime();
      }

      function normalizeSessionExpandStep(step) {
        return Math.min(Math.max(Number(step) || 0, 0), 2);
      }

      function getVisibleSessionsByExpandStep(step, sessions) {
        const normalizedStep = normalizeSessionExpandStep(step);
        const sourceSessions = Array.isArray(sessions) ? sessions : classSessions;
        const weekStartMs = getThisWeekStartMs(new Date());
        const twoWeeksStart = new Date(weekStartMs);
        twoWeeksStart.setDate(twoWeeksStart.getDate() - 14);
        const monthStart = new Date(weekStartMs);
        monthStart.setMonth(monthStart.getMonth() - 1);

        const minMsByStep = [
          weekStartMs,
          twoWeeksStart.getTime(),
          monthStart.getTime()
        ];
        const minMs = minMsByStep[normalizedStep];

        return sourceSessions.filter(function (session) {
          const ms = Number(session && session.sessionDateMs);
          if (!Number.isFinite(ms)) return normalizedStep >= 2;
          return ms >= minMs;
        });
      }

      function getNextSessionExpandStep(currentStep, sessions) {
        const normalizedStep = normalizeSessionExpandStep(currentStep);
        const currentCount = getVisibleSessionsByExpandStep(normalizedStep, sessions).length;
        for (let nextStep = normalizedStep + 1; nextStep <= 2; nextStep += 1) {
          const nextCount = getVisibleSessionsByExpandStep(nextStep, sessions).length;
          if (nextCount > currentCount) return nextStep;
        }
        return null;
      }

      function buildSessionBuckets(sessions) {
        const source = Array.isArray(sessions) ? sessions : classSessions;
        const reviewSessions = [];
        const submittedSessions = [];
        const submittedTrackKeySet = new Set();

        source.forEach(function (session) {
          if (!isSubmittedSessionNo(getSessionNoFromAny(session))) return;
          if (getLapTurnFromAny(session) <= 1) return;
          const key = buildReviewTrackKey(session);
          if (key) submittedTrackKeySet.add(key);
        });

        source.forEach(function (session) {
          if (isReviewSessionForList(session)) {
            const key = buildReviewTrackKey(session);
            if (key && submittedTrackKeySet.has(key)) return;
            reviewSessions.push(session);
            return;
          }
          if (isSubmittedSessionNo(getSessionNoFromAny(session))) {
            submittedSessions.push(session);
          }
        });

        return { reviewSessions, submittedSessions };
      }

      function getSessionScopeByTabAndStep(tab, step, sessions) {
        const tabKey = tab === "submitted" ? "submitted" : "review";
        const normalizedStep = normalizeSessionExpandStep(step);
        const buckets = buildSessionBuckets(sessions);
        const activeSessions = tabKey === "submitted" ? buckets.submittedSessions : buckets.reviewSessions;
        const visibleSessions = getVisibleSessionsByExpandStep(normalizedStep, activeSessions);
        const nextExpandStep = getNextSessionExpandStep(normalizedStep, activeSessions);
        return {
          tab: tabKey,
          step: normalizedStep,
          buckets,
          activeSessions,
          visibleSessions,
          nextExpandStep
        };
      }

      function getSessionLoadMoreLabel(nextStep) {
        if (nextStep === 1) return "더보기 (지난 2주)";
        if (nextStep === 2) return "더보기 (한달)";
        return "더보기";
      }

      function parsePositivePage(value) {
        const n = Number(value);
        if (!Number.isFinite(n)) return null;
        const page = Math.trunc(n);
        return page > 0 ? page : null;
      }

      function extractQNoFromPayload(payloadObj) {
        if (!payloadObj || typeof payloadObj !== "object") return DEFAULT_PAYLOAD_QNO;
        const metaObj = payloadObj.meta && typeof payloadObj.meta === "object" ? payloadObj.meta : null;
        const candidates = [
          getRawQNoFromAny(payloadObj),
          metaObj && getRawQNoFromAny(metaObj)
        ];
        for (let i = 0; i < candidates.length; i += 1) {
          const parsed = parseQNoForPayload(candidates[i]);
          if (parsed > 0) return parsed;
        }
        return DEFAULT_PAYLOAD_QNO;
      }

      function extractLapFromPayload(payloadObj) {
        if (!payloadObj || typeof payloadObj !== "object") return DEFAULT_PAYLOAD_LAP;
        const metaObj = payloadObj.meta && typeof payloadObj.meta === "object" ? payloadObj.meta : null;
        const candidates = [
          getRawLapFromAny(payloadObj),
          metaObj && getRawLapFromAny(metaObj)
        ];
        for (let i = 0; i < candidates.length; i += 1) {
          if (!hasMeaningfulText(candidates[i])) continue;
          return normalizeLapForPayload(candidates[i]);
        }
        return DEFAULT_PAYLOAD_LAP;
      }

      function extractPreferredPageFromPayload(payloadObj) {
        if (!payloadObj || typeof payloadObj !== "object") return null;

        const metaObj = payloadObj.meta && typeof payloadObj.meta === "object" ? payloadObj.meta : null;
        if (metaObj) {
          const page = parsePositivePage(metaObj.page);
          if (page) return page;
        }

        if (Array.isArray(payloadObj.pairs)) {
          for (let i = 0; i < payloadObj.pairs.length; i += 1) {
            const row = payloadObj.pairs[i] && typeof payloadObj.pairs[i] === "object" ? payloadObj.pairs[i] : null;
            if (!row) continue;
            const p1 = parsePositivePage(row.page);
            if (p1) return p1;
            const rowMeta = row.meta && typeof row.meta === "object" ? row.meta : null;
            if (rowMeta) {
              const p2 = parsePositivePage(rowMeta.page);
              if (p2) return p2;
            }
          }
        }

        if (Array.isArray(payloadObj.words)) {
          for (let i = 0; i < payloadObj.words.length; i += 1) {
            const row = payloadObj.words[i] && typeof payloadObj.words[i] === "object" ? payloadObj.words[i] : null;
            if (!row) continue;
            const rowMeta = row.meta && typeof row.meta === "object" ? row.meta : null;
            if (rowMeta) {
              const p = parsePositivePage(rowMeta.page);
              if (p) return p;
            }
          }
        }

        const directCandidates = [
          payloadObj.current_page,
          payloadObj.currentPage,
          payloadObj.page,
          payloadObj.source_page,
          payloadObj.sourcePage
        ];
        for (let i = 0; i < directCandidates.length; i += 1) {
          const page = parsePositivePage(directCandidates[i]);
          if (page) return page;
        }

        return null;
      }

      function scrollPdfToPage(pageNumber) {
        const page = parsePositivePage(pageNumber);
        if (!page) return false;
        if (previewPages.hidden) return false;

        const wraps = previewPages.querySelectorAll(".pdf-page");
        if (!wraps || !wraps.length) return false;

        const idx = Math.min(page - 1, wraps.length - 1);
        const target = wraps[idx];
        if (!target) return false;

        const top = Math.max(0, target.offsetTop - 8);
        previewPages.scrollTo({ top, behavior: "auto" });
        return true;
      }

      function jumpToPreferredPage(pageNumber) {
        const page = parsePositivePage(pageNumber);
        if (!page) return false;

        if (!previewPages.hidden) {
          const moved = scrollPdfToPage(page);
          if (!moved) return false;
          // 렌더 직후 레이아웃 지연 대비 1회 재시도
          setTimeout(function () {
            scrollPdfToPage(page);
          }, 80);
          return true;
        }

        if (!previewFrame.hidden && lastBlobUrl) {
          const nextSrc = buildIframeBlobSrc(lastBlobUrl, page);
          if (previewFrame.src !== nextSrc) {
            previewFrame.src = nextSrc;
          }
          return true;
        }
        return false;
      }

      function buildTabsFromPayload(payloadObj) {
        const safe = payloadObj && typeof payloadObj === "object" ? payloadObj : {};

        if (Array.isArray(safe.tabs) && safe.tabs.length) {
          return normalizeSessionTabs(safe.tabs);
        }

        const blankText = toSafeText(safe.text || safe.blankText);
        if (String(safe.template || "").toLowerCase() === "blank" || blankText) {
          return normalizeSessionTabs([{ type: "blank", blankText }]);
        }

        const pairWords = Array.isArray(safe.pairs) ? safe.pairs.map(function (row) {
          const safeRow = row && typeof row === "object" ? row : {};
          return {
            word: toSafeText(safeRow.word),
            meaning: toSafeText(safeRow.meaning)
          };
        }) : [];
        const directWords = Array.isArray(safe.words) ? safe.words.map(function (row) {
          const safeRow = row && typeof row === "object" ? row : {};
          return {
            word: toSafeText(safeRow.word),
            meaning: toSafeText(safeRow.meaning)
          };
        }) : [];
        const words = (pairWords.length ? pairWords : directWords).filter(function (row) {
          return !!(row.word || row.meaning);
        });
        const sentences = Array.isArray(safe.sentences) ? safe.sentences.map(function (row) {
          const safeRow = row && typeof row === "object" ? row : {};
          return {
            sentence: toSafeText(safeRow.sentence)
          };
        }).filter(function (row) {
          return !!row.sentence;
        }) : [];

        if (words.length || sentences.length) {
          return normalizeSessionTabs([{ type: "two_three", words, sentences }]);
        }

        return normalizeSessionTabs([{ type: "blank", blankText: "" }]);
      }

      function parseTemplateLabel(payloadObj) {
        const safe = payloadObj && typeof payloadObj === "object" ? payloadObj : {};
        const template = toSafeText(safe.template).trim();
        if (!template) return "";
        if (/^blank$/i.test(template)) return "1st Try ( Skim / Scan / Brainstorm )";
        const compactTemplate = template.replace(/\s+/g, "");
        if (compactTemplate === "단어찾고번역") return "2nd & 3rd Try ( Vocab + Translation)";
        return "";
      }

      function buildTwoThreeTabSnapshot(tabs) {
        const safeTabs = Array.isArray(tabs) ? tabs : [];
        const typeList = safeTabs.map(function (tab) {
          return tab && typeof tab === "object" ? String(tab.type || "") : "";
        });
        const twoThreeTab = safeTabs.find(function (tab) {
          return tab && tab.type === "two_three";
        });
        if (!twoThreeTab || !twoThreeTab.twoThree || typeof twoThreeTab.twoThree !== "object") {
          return {
            tabTypes: typeList,
            hasTwoThree: false
          };
        }

        const words = Array.isArray(twoThreeTab.twoThree.words) ? twoThreeTab.twoThree.words : [];
        const sentences = Array.isArray(twoThreeTab.twoThree.sentences) ? twoThreeTab.twoThree.sentences : [];
        const wordPreview = words.slice(0, 10).map(function (row, idx) {
          const safeRow = row && typeof row === "object" ? row : {};
          return {
            slot: idx + 1,
            word: toSafeText(safeRow.word),
            meaning: toSafeText(safeRow.meaning)
          };
        });
        const sentencePreview = sentences.slice(0, 5).map(function (row, idx) {
          const safeRow = row && typeof row === "object" ? row : {};
          return {
            slot: idx + 1,
            sentence: toSafeText(safeRow.sentence)
          };
        });
        return {
          tabTypes: typeList,
          hasTwoThree: true,
          wordsCount: words.length,
          sentencesCount: sentences.length,
          wordPreview,
          sentencePreview
        };
      }

      function applyPayloadToSession(session, payloadObj) {
        if (!session || !payloadObj || typeof payloadObj !== "object") return;

        session.tabs = buildTabsFromPayload(payloadObj);
        session.targetPage = extractPreferredPageFromPayload(payloadObj);
        session.templateLabel = parseTemplateLabel(payloadObj);
        session.qNo = extractQNoFromPayload(payloadObj);
        session.lap = extractLapFromPayload(payloadObj);
        session.note = session.templateLabel || "";

        const activeIndex = Number(payloadObj.activeTabIndex);
        if (Number.isFinite(activeIndex)) {
          session.activeTabIndex = activeIndex;
        }

        if (payloadObj.overlaySide === "left" || payloadObj.overlaySide === "right") {
          session.overlaySide = payloadObj.overlaySide;
        }

        if (DEBUG_LIVE_FETCH_LOG) {
          trace("info", "session payload applied -> tab snapshot", {
            sessionTitle: getSessionDateLabel(session),
            template: toSafeText(payloadObj.template),
            templateLabel: session.templateLabel,
            snapshot: buildTwoThreeTabSnapshot(session.tabs)
          });
        }
      }

      function makeSessionFromRow(row, idx) {
        const safeRow = row && typeof row === "object" ? row : {};
        const qLevelRaw = toSafeText(safeRow.QLevel).trim();
        const qLevelUpper = qLevelRaw.toUpperCase();
        const grade = qLevelUpper && qLevelUpper !== "BLANK" ? normalizeStorageGrade(qLevelRaw) : DEFAULT_GRADE;
        const year = normalizeMockYear(safeRow.QYear);
        const examKey = monthToExamKey(safeRow.QMonth);
        const scheduleDateObj = parseScheduleDate(safeRow.LiveSchedule) || parseScheduleDate(safeRow.UpdatedAt);
        const liveScheduleLabel = formatLiveScheduleLabel(safeRow.LiveSchedule);
        const updatedAtLabel = formatLiveScheduleLabel(safeRow.UpdatedAt);

        const session = {
          _row: safeRow,
          date: liveScheduleLabel || updatedAtLabel || `LSAS #${toSafeText(safeRow.LSASId) || String(idx + 1)}`,
          sessionDateMs: scheduleDateObj ? scheduleDateObj.getTime() : null,
          note: "",
          templateLabel: "",
          qNo: parseQNoForPayload(getRawQNoFromAny(safeRow)),
          lap: normalizeLapForPayload(getRawLapFromAny(safeRow)),
          mock: {
            grade,
            year,
            examKey,
            typeLabel: DEFAULT_TYPE_LABEL
          },
          overlaySide: "right",
          openMemo: true,
          activeTabIndex: 0,
          tabs: [{ type: "blank", blankText: "" }],
          targetPage: null,
          servedFileURL: toSafeText(safeRow.ServedFileURL),
          _payloadLoaded: false,
          _payloadLoadingPromise: null
        };

        const inlinePayload = extractPayloadFromReceiveRow(safeRow);
        if (inlinePayload) {
          applyPayloadToSession(session, inlinePayload);
          session._payloadLoaded = true;
        }

        return session;
      }

      async function ensureSessionPayloadLoaded(session) {
        if (!session) return;
        if (session._payloadLoaded) return;
        if (session._payloadLoadingPromise) {
          await session._payloadLoadingPromise;
          return;
        }

        const servedFileURL = toSafeText(session.servedFileURL).trim();
        if (!servedFileURL) {
          session._payloadLoaded = true;
          return;
        }

        session._payloadLoadingPromise = (async function () {
          try {
            if (DEBUG_LIVE_FETCH_LOG) {
              trace("info", "session payload request", {
                url: servedFileURL,
                sessionTitle: getSessionDateLabel(session)
              });
            }
            const res = await fetch(servedFileURL, { cache: "no-store" });
            if (!res.ok) {
              throw new Error(`HTTP ${res.status}`);
            }
            const payloadText = await res.text();
            if (DEBUG_LIVE_FETCH_LOG) {
              trace("info", "session payload response", {
                status: res.status,
                ok: res.ok,
                url: servedFileURL,
                rawLength: payloadText.length,
                rawPreview: trimForLog(payloadText, 600)
              });
            }
            if (payloadText) {
              const payloadObj = JSON.parse(payloadText);
              if (DEBUG_LIVE_FETCH_LOG) {
                trace("info", "session payload parsed", {
                  url: servedFileURL,
                  keys: Object.keys(payloadObj || {}),
                  template: toSafeText(payloadObj.template),
                  tabs: Array.isArray(payloadObj && payloadObj.tabs) ? payloadObj.tabs.length : 0,
                  pairs: Array.isArray(payloadObj && payloadObj.pairs) ? payloadObj.pairs.length : 0,
                  words: Array.isArray(payloadObj && payloadObj.words) ? payloadObj.words.length : 0,
                  sentences: Array.isArray(payloadObj && payloadObj.sentences) ? payloadObj.sentences.length : 0,
                  targetPage: extractPreferredPageFromPayload(payloadObj),
                  pairsPreview: Array.isArray(payloadObj && payloadObj.pairs)
                    ? payloadObj.pairs.slice(0, 10).map(function (row, idx) {
                      const safeRow = row && typeof row === "object" ? row : {};
                      return {
                        slot: idx + 1,
                        word: toSafeText(safeRow.word),
                        meaning: toSafeText(safeRow.meaning),
                        page: safeRow.meta && typeof safeRow.meta === "object" ? toSafeText(safeRow.meta.page) : ""
                      };
                    })
                    : [],
                  wordsPreview: Array.isArray(payloadObj && payloadObj.words)
                    ? payloadObj.words.slice(0, 10).map(function (row, idx) {
                      const safeRow = row && typeof row === "object" ? row : {};
                      return {
                        slot: idx + 1,
                        word: toSafeText(safeRow.word),
                        meaning: toSafeText(safeRow.meaning)
                      };
                    })
                    : []
                });
              }
              applyPayloadToSession(session, payloadObj);
            }
            session._payloadLoaded = true;
          } catch (err) {
            session._payloadLoaded = false;
            trace("warn", `payload load failed: ${servedFileURL}`, err);
          } finally {
            session._payloadLoadingPromise = null;
          }
        })();

        await session._payloadLoadingPromise;
      }

      async function fetchLiveSessions(force) {
        if (isSessionListLoading) return;
        if (!force && sessionListLoadedOnce) return;

        if (!FIXED_STUDENT_ID) {
          classSessions = [];
          resetSessionListHydrationState();
          sessionListError = "URL에 id(UserId) 파라미터가 필요합니다.";
          sessionListLoadedOnce = true;
          setSessionSubLabel("id required");
          renderSessionList();
          return;
        }

        isSessionListLoading = true;
        sessionListError = "";
        setSessionSubLabel("loading...");
        renderSessionList();

        const url = new URL(LIVE_RECEIVE_URL);
        url.searchParams.set("userId", FIXED_STUDENT_ID);
        url.searchParams.set("limit", String(LIVE_RECEIVE_LIMIT));

        try {
          if (DEBUG_LIVE_FETCH_LOG) {
            trace("info", "live receive request", {
              url: url.toString(),
              userId: FIXED_STUDENT_ID,
              limit: LIVE_RECEIVE_LIMIT
            });
          }
          const res = await fetch(url.toString(), { cache: "no-store" });
          const rawText = await res.text();
          if (DEBUG_LIVE_FETCH_LOG) {
            trace("info", "live receive response", {
              status: res.status,
              ok: res.ok,
              rawLength: rawText.length,
              rawPreview: trimForLog(rawText, 600)
            });
          }
          let payload;
          try {
            payload = rawText ? JSON.parse(rawText) : [];
          } catch (parseErr) {
            payload = [];
            if (DEBUG_LIVE_FETCH_LOG) {
              trace("warn", "live receive parse failed", {
                error: String(parseErr && parseErr.message ? parseErr.message : parseErr || "unknown parse error"),
                rawPreview: trimForLog(rawText, 600)
              });
            }
          }

          if (!res.ok) {
            const message = payload && typeof payload.message === "string"
              ? payload.message
              : (rawText || `HTTP ${res.status}`);
            throw new Error(`HTTP ${res.status}: ${message}`);
          }

          const rows = parseReceiveRows(payload);
          const rowsForStudent = rows.filter(function (row) {
            const sessionNo = getSessionNoFromAny(row);
            return isReviewSessionNo(sessionNo) || isSubmittedSessionNo(sessionNo);
          });
          const mappedSessions = rowsForStudent.map(makeSessionFromRow);
          const reviewCount = mappedSessions.filter(function (session) {
            return isReviewSessionForList(session);
          }).length;
          const submittedCount = mappedSessions.filter(function (session) {
            return isSubmittedSessionNo(getSessionNoFromAny(session));
          }).length;
          if (DEBUG_LIVE_FETCH_LOG) {
            trace(
              "info",
              `live receive rows parsed: ${rows.length} (review: ${reviewCount}, submitted: ${submittedCount})`,
              rows.slice(0, 10).map(makeLiveRowLogPreview)
            );
          }
          sessionListExpandStep = 0;
          classSessions = mappedSessions;
          resetSessionListHydrationState();
          if (DEBUG_LIVE_FETCH_LOG) {
            trace("info", "session mapped preview", classSessions.slice(0, 10).map(function (session, idx) {
              const mockInfo = session && session.mock ? session.mock : {};
              return {
                idx: idx + 1,
                title: getSessionDateLabel(session),
                grade: mockInfo.grade || "",
                year: mockInfo.year || "",
                examKey: mockInfo.examKey || "",
                note: trimForLog(session ? session.note : "", 120),
                servedFileURL: trimForLog(session ? session.servedFileURL : "", 180)
              };
            }));
          }
          sessionListLoadedOnce = true;
          sessionListError = "";
          setSessionSubLabel(`review ${reviewCount} · submitted ${submittedCount}`);
          trace("info", `session list loaded: ${classSessions.length}`);
        } catch (err) {
          classSessions = [];
          resetSessionListHydrationState();
          sessionListError = String(err && err.message ? err.message : err || "unknown error");
          sessionListLoadedOnce = true;
          setSessionSubLabel("load failed");
          trace("error", "session list load failed", err);
        } finally {
          isSessionListLoading = false;
          renderSessionList();
          void hydrateSessionListForCurrentScope("fetch");
          updateOverlayQuestionNoBar();
        }
      }

      function renderSessionList() {
        sessionList.innerHTML = "";

        if (isSessionListLoading) {
          renderSessionListMessage("수업 목록 불러오는 중...");
          return;
        }
        if (sessionListError) {
          renderSessionListMessage(`불러오기 실패: ${sessionListError}`);
          return;
        }
        if (!classSessions.length) {
          if (FIXED_STUDENT_ID) {
            setSessionSubLabel("review 0 · submitted 0");
          }
          renderSessionListMessage(FIXED_STUDENT_ID ? "저장된 수업 세션이 없습니다." : "URL에 ?id=UserId 가 필요합니다.");
          return;
        }

        const buckets = buildSessionBuckets(classSessions);
        const reviewSessions = buckets.reviewSessions;
        const submittedSessions = buckets.submittedSessions;

        if (!reviewSessions.length && !submittedSessions.length) {
          setSessionSubLabel("review 0 · submitted 0");
          renderSessionListMessage("표시할 수업 세션이 없습니다.");
          return;
        }
        setSessionSubLabel(`review ${reviewSessions.length} · submitted ${submittedSessions.length}`);

        function appendSessionItem(session, options) {
          const opts = options && typeof options === "object" ? options : {};
          const isDisabled = !!opts.disabled;
          const originalIdx = classSessions.indexOf(session);
          const sessionKey = getSessionKey(session, originalIdx >= 0 ? originalIdx : 0);
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "session-item-btn";
          if (isDisabled) {
            btn.classList.add("is-disabled");
            btn.disabled = true;
          } else if (sessionKey === selectedSessionId) {
            btn.classList.add("is-selected");
          }

          const title = document.createElement("div");
          title.className = "session-item-title";
          title.textContent = getSessionDateLabel(session) || "수업 일정";

          const mockInfo = session.mock || {};
          const metaParts = [];
          const sessionNo = getSessionNoFromAny(session);
          if (Number.isFinite(sessionNo) && sessionNo > 1 && !isSubmittedSessionNo(sessionNo)) {
            metaParts.push(`Session ${sessionNo}`);
          }
          if (mockInfo.grade) metaParts.push(getGradeLabel(mockInfo.grade));
          if (mockInfo.year) metaParts.push(mockInfo.year);
          if (mockInfo.examKey) metaParts.push(getExamLabel(mockInfo.examKey, mockInfo.grade));
          if (mockInfo.typeLabel && mockInfo.typeLabel !== DEFAULT_TYPE_LABEL) metaParts.push(mockInfo.typeLabel);
          const meta = document.createElement("div");
          meta.className = "session-item-meta";
          meta.textContent = metaParts.filter(Boolean).join(" · ");

          const note = document.createElement("div");
          note.className = "session-item-note";
          note.textContent = session.note || "";

          btn.appendChild(title);
          if (meta.textContent) btn.appendChild(meta);
          if (note.textContent) btn.appendChild(note);

          const qNoLabel = getSessionQuestionNoLabel(session);
          const qNoEl = document.createElement("div");
          qNoEl.className = "session-item-qno";
          if (qNoLabel === "-") qNoEl.classList.add("is-empty");
          const qNoPrefixEl = document.createElement("span");
          qNoPrefixEl.className = "session-item-qno-prefix";
          qNoPrefixEl.textContent = "Q.";
          const qNoValueEl = document.createElement("span");
          qNoValueEl.className = "session-item-qno-value";
          qNoValueEl.textContent = qNoLabel;
          qNoEl.appendChild(qNoPrefixEl);
          qNoEl.appendChild(qNoValueEl);
          btn.appendChild(qNoEl);

          const ribbons = Array.isArray(opts.ribbons)
            ? opts.ribbons
            : (opts.ribbonText ? [{ text: opts.ribbonText, className: opts.ribbonClass || "" }] : []);
          if (ribbons.length) {
            btn.classList.add("has-ribbon");
            for (let rIdx = 0; rIdx < ribbons.length; rIdx += 1) {
              const ribbonSpec = ribbons[rIdx] && typeof ribbons[rIdx] === "object" ? ribbons[rIdx] : {};
              const ribbon = document.createElement("span");
              ribbon.className = "session-item-ribbon";
              if (ribbonSpec.className) ribbon.classList.add(ribbonSpec.className);
              if (ribbonSpec.secondary) ribbon.classList.add("is-secondary");
              ribbon.textContent = toSafeText(ribbonSpec.text) || "";
              btn.appendChild(ribbon);
            }
          }

          if (!isDisabled) {
            btn.addEventListener("click", function () {
              applySessionPreset(session, sessionKey);
            });
          }
          sessionList.appendChild(btn);
        }

        const isSubmittedTab = sessionViewTab === "submitted";
        const activeSessions = isSubmittedTab ? submittedSessions : reviewSessions;
        const visibleSessions = getVisibleSessionsByExpandStep(sessionListExpandStep, activeSessions);
        const nextExpandStep = getNextSessionExpandStep(sessionListExpandStep, activeSessions);
        if (!activeSessions.length) {
          renderSessionListMessage(
            isSubmittedTab
              ? "제출 기록이 없습니다."
              : "REVIEW 세션이 없습니다."
          );
          return;
        }

        if (!visibleSessions.length) {
          renderSessionListMessage(
            sessionListExpandStep === 0
              ? (isSubmittedTab ? "이번 주 제출 기록이 없습니다." : "이번 주 REVIEW 세션이 없습니다.")
              : "표시할 수업 세션이 없습니다."
          );
        }

        visibleSessions.forEach(function (session) {
          const isSubmitted = isSubmittedTab;
          const lapTurn = getLapTurnFromAny(session);
          const ribbonSpecs = isSubmitted
            ? (lapTurn > 1
              ? [
                { className: "is-afterclass", text: "수업 후" },
                { className: "is-submitted", text: "제출완료", secondary: true }
              ]
              : [{ className: "is-submitted", text: "제출완료" }])
            : [{ className: "is-afterclass", text: "수업 후" }];
          appendSessionItem(session, {
            disabled: isSubmitted,
            ribbons: ribbonSpecs
          });
        });

        if (nextExpandStep !== null) {
          const moreBtn = document.createElement("button");
          moreBtn.type = "button";
          moreBtn.className = "session-item-btn session-load-more-btn";
          moreBtn.textContent = getSessionLoadMoreLabel(nextExpandStep);
          moreBtn.addEventListener("click", function (event) {
            event.preventDefault();
            event.stopPropagation();
            sessionListExpandStep = nextExpandStep;
            renderSessionList();
            void hydrateSessionListForCurrentScope("load-more");
          });
          sessionList.appendChild(moreBtn);
        }
      }

      async function applySessionPreset(session, sessionKey) {
        if (!session) return;
        if (shouldAskDiscardDraftForSession(sessionKey)) {
          const proceed = confirmDiscardWorkingDraft();
          if (!proceed) {
            trace("info", "session load canceled by user: local draft kept");
            return;
          }
        }
        await ensureSessionPayloadLoaded(session);

        const mockInfo = session.mock || {};
        selectedSessionTargetPage = parsePositivePage(session.targetPage);
        stopThreePenDrawing();

        selectedSessionId = sessionKey || "";
        selectedSessionTitle = getSessionDateLabel(session);

        const gradeValue = mockInfo.grade || DEFAULT_GRADE;
        ensureSelectValue(gradeSel, gradeValue, getGradeLabel(gradeValue));
        refreshYearExamTypeOptions();
        if (mockInfo.year) {
          ensureSelectValue(yearSel, mockInfo.year, mockInfo.year);
        }
        if (mockInfo.examKey) {
          ensureSelectValue(examSel, mockInfo.examKey, getExamLabel(mockInfo.examKey, gradeValue));
        }
        ensureSelectValue(
          typeSel,
          mockInfo.typeLabel || DEFAULT_TYPE_LABEL,
          mockInfo.typeLabel || DEFAULT_TYPE_LABEL
        );

        overlaySide = session.overlaySide === "left" ? "left" : "right";
        applyOverlaySide();

        const normalizedTabs = normalizeSessionTabs(session.tabs);
        memoTabs.length = 0;
        normalizedTabs.forEach(function (tab) {
          memoTabs.push(tab);
        });
        if (DEBUG_LIVE_FETCH_LOG) {
          trace("info", "applySessionPreset -> normalized tab snapshot", {
            sessionTitle: getSessionDateLabel(session),
            selectedSessionId,
            servedFileURL: toSafeText(session.servedFileURL),
            snapshot: buildTwoThreeTabSnapshot(memoTabs)
          });
        }
        nextMemoTabId = memoTabs.length + 1;
        const nextIndex = Number(session.activeTabIndex);
        activeMemoTabIndex = Number.isFinite(nextIndex)
          ? Math.min(Math.max(nextIndex, 0), memoTabs.length - 1)
          : 0;
        renderActiveMemoPane();
        renderMemoTabbar();
        closeFontPopup();
        closeTabTypePopup();
        renderSessionList();
        updateTopbarStatus();
        closeSessionPopup();
        markMemoDirty("session-preset");

        const canTryPdf = !!(mockInfo.year && mockInfo.examKey);
        const loaded = canTryPdf ? await tryLoadPdf() : false;
        if (session.openMemo && (loaded || !canTryPdf)) {
          toggleMemoOverlay(true);
        }
      }

      function updateTopbarStatus() {
        const parts = [];
        if (selectedSessionTitle) {
          parts.push(selectedSessionTitle);
        }
        const gradeLabel = gradeSel.options && gradeSel.selectedIndex >= 0
          ? gradeSel.options[gradeSel.selectedIndex].text
          : "";
        if (gradeLabel) parts.push(gradeLabel);
        if (yearSel.value) parts.push(yearSel.value);
        if (examSel.value) parts.push(getExamLabel(examSel.value, gradeSel.value));
        topbarStatus.classList.toggle("is-local-draft", hasLocalDraftSnapshot);
        topbarStatus.classList.toggle("is-writing", hasLocalDraftSnapshot);
        topbarStatus.innerHTML = "";

        if (!hasLocalDraftSnapshot && !parts.length) {
          topbarStatus.textContent = "학년 · 연도 선택";
          return;
        }

        if (hasLocalDraftSnapshot) {
          const writing = document.createElement("span");
          writing.className = "topbar-status-writing";
          writing.textContent = "[작성중]";
          topbarStatus.appendChild(writing);
        }

        if (parts.length) {
          if (hasLocalDraftSnapshot) {
            const sep = document.createElement("span");
            sep.className = "topbar-status-sep";
            sep.textContent = "·";
            topbarStatus.appendChild(sep);
          }
          const main = document.createElement("span");
          main.className = "topbar-status-main";
          main.textContent = parts.join(" · ");
          topbarStatus.appendChild(main);
        }
      }

      function clearSessionSelection() {
        if (!selectedSessionId && !selectedSessionTitle) return;
        selectedSessionId = "";
        selectedSessionTitle = "";
        selectedSessionTargetPage = null;
        renderSessionList();
        updateOverlayQuestionNoBar();
      }

      function setSelectOptions(selectEl, options, placeholderLabel) {
        const html = [];
        if (placeholderLabel) {
          html.push(`<option value="">${placeholderLabel}</option>`);
        }
        for (const opt of options) {
          html.push(`<option value="${opt.value}">${opt.label}</option>`);
        }
        selectEl.innerHTML = html.join("");
      }

      function buildPublicUrl(filename, gradeValue) {
        const folder = normalizeStorageGrade(gradeValue || DEFAULT_GRADE);
        return `${SUPABASE_BASE}/${BUCKET}/${folder}/${filename}`;
      }

      async function loadWordIndexForFile(fileInfo) {
        activeWordIndex = null;
        if (!fileInfo || !fileInfo.filename) return null;
        const pdfFilename = String(fileInfo.filename);
        const stem = pdfFilename.replace(/\.pdf$/i, "");
        if (!stem || stem === pdfFilename) return null;
        const indexName = `${stem}_wordsx.json`;
        const legacyIndexName = `${stem}_words.json`;
        const dotIndexName = `${stem}.wordsx.json`;
        const legacyDotIndexName = `${stem}.words.json`;

        const candidates = [];
        const pushCandidate = function (value) {
          const next = String(value || "").trim();
          if (!next) return;
          if (!candidates.includes(next)) candidates.push(next);
        };

        // 1) current origin (local server)
        pushCandidate(indexName);
        pushCandidate(dotIndexName);
        pushCandidate(legacyIndexName);
        pushCandidate(legacyDotIndexName);

        // 2) same Supabase object path as the selected PDF (extension only swapped)
        const pdfUrl = String(fileInfo.url || "").trim();
        const pushUrlIndexCandidates = function (baseUrl) {
          const base = String(baseUrl || "").trim();
          if (!base) return;
          pushCandidate(`${base}_wordsx.json`);
          pushCandidate(`${base}.wordsx.json`);
          pushCandidate(`${base}_words.json`);
          pushCandidate(`${base}.words.json`);
        };
        if (pdfUrl) {
          if (/\.pdf($|[?#])/i.test(pdfUrl)) {
            pushUrlIndexCandidates(pdfUrl.replace(/\.pdf(?=($|[?#]))/i, ""));
          } else {
            pushUrlIndexCandidates(pdfUrl);
          }
        }

        // 3) explicit public-url candidates
        pushCandidate(buildPublicUrl(indexName, fileInfo.grade));
        pushCandidate(buildPublicUrl(dotIndexName, fileInfo.grade));
        pushCandidate(buildPublicUrl(legacyIndexName, fileInfo.grade));
        pushCandidate(buildPublicUrl(legacyDotIndexName, fileInfo.grade));

        for (let i = 0; i < candidates.length; i += 1) {
          const url = candidates[i];
          try {
            const res = await fetch(url);
            if (!res.ok) continue;
            const data = await res.json();
            const normalized = normalizeWordIndexData(data);
            const normalizedPages = normalized && normalized.pages && typeof normalized.pages === "object"
              ? normalized.pages
              : {};
            const pageCount = Object.keys(normalizedPages).length;
            if (!pageCount) continue;
            const rowCount = Object.keys(normalizedPages).reduce(function (acc, key) {
              const rows = Array.isArray(normalizedPages[key]) ? normalizedPages[key].length : 0;
              return acc + rows;
            }, 0);
            activeWordIndex = normalized;
            trace("info", `word-index loaded: ${url} (${pageCount}p / ${rowCount} rows)`);
            return normalized;
          } catch (_err) {
            // try next candidate
          }
        }

        trace("warn", `word-index not found: ${indexName} (fallback: ${dotIndexName}, ${legacyIndexName}, ${legacyDotIndexName})`);
        return null;
      }

      function buildFilename(grade, year, examKey, typeLabel) {
        const exam = EXAM_META.find(item => item.key === examKey);
        const type = TYPE_META.find(item => item.label === typeLabel);
        if (!exam || !type) return "";
        return `${grade}_${year}_${exam.token}${type.suffix}.pdf`;
      }

      function refreshYearExamTypeOptions() {
        const years = YEAR_CANDIDATES.slice().sort().reverse();
        setSelectOptions(
          yearSel,
          years.map(y => ({ value: y, label: y })),
          "연도 선택"
        );
        if (!yearSel.value || !years.includes(yearSel.value)) {
          yearSel.value = years.includes("2023to2024") ? "2023to2024" : (years[0] || "");
        }

        const examOptions = getExamOptionsForGrade(gradeSel.value || DEFAULT_GRADE);
        setSelectOptions(examSel, examOptions, "몇평 선택");
        if (!examSel.value || !examOptions.some(opt => opt.value === examSel.value)) {
          examSel.value = examOptions.some(opt => opt.value === "november")
            ? "november"
            : (examOptions[0] ? examOptions[0].value : "");
        }

        const typeOptions = TYPE_META.map(meta => ({ value: meta.label, label: meta.label }));
        setSelectOptions(typeSel, typeOptions, "유형 선택");
        if (!typeSel.value || !typeOptions.some(opt => opt.value === typeSel.value)) {
          typeSel.value = "시험지";
        }
      }

      function initializeFileMap() {
        setSelectOptions(gradeSel, GRADE_OPTIONS, "학년 선택");
        gradeSel.value = DEFAULT_GRADE;
        refreshYearExamTypeOptions();
        openBtn.disabled = false;
        updateTopbarStatus();
        trace("info", "mode=direct-request");
      }

      function getSelectedFileInfo() {
        const grade = gradeSel.value || DEFAULT_GRADE;
        const year = yearSel.value;
        const examKey = examSel.value;
        const typeLabel = typeSel.value;
        if (!grade || !year || !examKey || !typeLabel) return null;

        const filename = buildFilename(grade, year, examKey, typeLabel);
        if (!filename) return null;
        return {
          grade,
          year,
          examKey,
          typeLabel,
          filename,
          url: buildPublicUrl(filename, grade)
        };
      }

      async function fetchPdfBlob(url) {
        const res = await fetch(url);
        if (!res.ok) {
          const err = new Error(`HTTP ${res.status}`);
          err.httpStatus = res.status;
          throw err;
        }
        return res.blob();
      }

      async function tryLoadPdf() {
        const fileInfo = getSelectedFileInfo();
        if (!fileInfo) {
          resetPdfPreviewToEmpty("선택한 조건의 PDF가 없습니다.");
          trace("warn", "selected combo is incomplete");
          return false;
        }

        openBtn.disabled = true;
        newTabBtn.hidden = true;
        lastPdfUrl = fileInfo.url;
        topbarStatus.textContent = "PDF 불러오는 중...";
        trace("info", `load start: ${fileInfo.filename}`);

        try {
          const pdfBlob = await fetchPdfBlob(fileInfo.url);
          trace("info", `download ok: ${fileInfo.filename} (${Math.round(pdfBlob.size / 1024)}KB)`);
          const wordIndex = await loadWordIndexForFile(fileInfo);
          let renderResult = null;
          if (wordIndex && window.pdfjsLib) {
            try {
              renderResult = await renderPdfPagesWithTextLayer(pdfBlob, {
                preferredPage: selectedSessionTargetPage
              });
            } catch (renderErr) {
              trace("warn", `word-index renderer failed -> iframe fallback: ${fileInfo.filename}`, renderErr);
              showPdfWithIframeBlob(pdfBlob, selectedSessionTargetPage);
            }
          } else {
            showPdfWithIframeBlob(pdfBlob, selectedSessionTargetPage);
          }
          if (DEBUG_SCROLL_DIAG) {
            trace("info", "diag/post-load", {
              frameHidden: previewFrame.hidden,
              pagesHidden: previewPages.hidden,
              emptyHidden: previewEmpty.hidden,
              host: getScrollHostMetrics(previewPages)
            });
          }
          newTabBtn.hidden = false;
          if (selectedSessionTargetPage && !(renderResult && renderResult.jumpedToPreferredDuringRender)) {
            requestAnimationFrame(function () {
              const moved = jumpToPreferredPage(selectedSessionTargetPage);
              if (moved) {
                trace("info", `session page jump: p.${selectedSessionTargetPage}`);
              }
            });
          }
          updateTopbarStatus();
          trace("info", `load success: ${fileInfo.filename}`);
          return true;
        } catch (err) {
          const code = Number(err && err.httpStatus);
          if (code === 400 || code === 404) {
            resetPdfPreviewToEmpty("해당 조합의 PDF가 아직 없습니다.");
            updateTopbarStatus();
            trace("warn", `missing file: ${fileInfo.filename}`);
            return false;
          }

          resetPdfPreviewToEmpty("PDF를 불러오지 못했습니다.");
          updateTopbarStatus();
          trace("error", `load failed: ${fileInfo.filename}`, err);
          return false;
        } finally {
          openBtn.disabled = false;
        }
      }

      yearSel.addEventListener("change", function () {
        clearSessionSelection();
        updateTopbarStatus();
        markMemoDirty("select-year");
      });

      examSel.addEventListener("change", function () {
        clearSessionSelection();
        updateTopbarStatus();
        markMemoDirty("select-exam");
      });

      gradeSel.addEventListener("change", function () {
        clearSessionSelection();
        refreshYearExamTypeOptions();
        updateTopbarStatus();
        markMemoDirty("select-grade");
      });

      typeSel.addEventListener("change", function () {
        clearSessionSelection();
        updateTopbarStatus();
        markMemoDirty("select-type");
      });

      openBtn.addEventListener("click", async function () {
        const proceed = confirmDiscardWorkingNotesForLoad();
        if (!proceed) return;
        closePickerPopup();
        await tryLoadPdf();
      });

      pickerToggleBtn.addEventListener("click", togglePickerPopup);
      pickerBackdrop.addEventListener("click", closePickerPopup);
      topbarStatus.addEventListener("click", function (event) {
        event.stopPropagation();
        toggleSessionPopup();
      });
      sessionBackdrop.addEventListener("click", closeSessionPopup);
      sessionTabReviewBtn.addEventListener("click", function (event) {
        event.stopPropagation();
        setSessionViewTab("review");
      });
      sessionTabSubmittedBtn.addEventListener("click", function (event) {
        event.stopPropagation();
        setSessionViewTab("submitted");
      });
      tabCloseConfirmBackdrop.addEventListener("click", closeTabCloseConfirm);
      tabCloseCancelBtn.addEventListener("click", closeTabCloseConfirm);
      tabCloseOkBtn.addEventListener("click", function () {
        const targetIndex = Number(pendingCloseTabIndex);
        closeTabCloseConfirm();
        if (!Number.isFinite(targetIndex)) return;
        closeMemoTabConfirmed(Math.trunc(targetIndex));
      });
      memoToggleBtn.addEventListener("click", function () {
        toggleMemoOverlay();
      });
      submitMenuBtn.addEventListener("click", function (event) {
        event.stopPropagation();
        toggleSubmitPopup();
      });
      submitActiveBtn.addEventListener("click", function () {
        closeSubmitPopup();
        void sendCurrentSessionToServer("active");
      });
      submitAllBtn.addEventListener("click", function () {
        closeSubmitPopup();
        void sendCurrentSessionToServer("all");
      });
      printMenuBtn.addEventListener("click", function (event) {
        event.stopPropagation();
        togglePrintPopup();
      });
      printReadyBtn.addEventListener("click", function () {
        closePrintPopup();
        window.alert("준비중입니다.");
      });
      overlayCloseBtn.addEventListener("click", function () {
        toggleMemoOverlay(false);
      });
      overlayTwoFlipTriangleBtn.addEventListener("click", function (event) {
        event.stopPropagation();
        flipOverlaySide();
      });
      overlayFontOpenBtn.addEventListener("click", function (event) {
        event.stopPropagation();
        toggleFontPopup();
      });
      overlayAddTabBtn.addEventListener("click", function (event) {
        event.stopPropagation();
        toggleTabTypePopup();
      });
      overlayMemoText.addEventListener("input", saveActiveMemoText);
      blankPenToggleBtn.addEventListener("click", function () {
        setBlankPenMode();
      });
      blankPenClearBtn.addEventListener("click", function () {
        clearActiveBlankInk();
      });
      blankDrawCanvas.addEventListener("pointerdown", handleBlankPenPointerDown);
      blankDrawCanvas.addEventListener("pointermove", handleBlankPenPointerMove);
      blankDrawCanvas.addEventListener("pointerup", handleBlankPenPointerEnd);
      blankDrawCanvas.addEventListener("pointercancel", handleBlankPenPointerEnd);
      overlayFontIncBtn.addEventListener("click", function () {
        memoFontSize = Math.min(36, memoFontSize + 1);
        applyMemoFontSize();
      });
      overlayFontDecBtn.addEventListener("click", function () {
        memoFontSize = Math.max(10, memoFontSize - 1);
        applyMemoFontSize();
      });
      overlayTypeOptionBtns.forEach(function (btn) {
        btn.addEventListener("click", function () {
          const type = btn.getAttribute("data-type") || "blank";
          addMemoTab(type);
        });
      });
      overlayThreePenToggleBtn.addEventListener("click", function () {
        setThreePenMode();
      });
      overlayThreePenClearBtn.addEventListener("click", function () {
        clearActiveThreeInk();
      });
      overlayDictToggleBtn.addEventListener("click", function () {
        toggleDictPanel();
      });
      overlayDictZoomInBtn.addEventListener("click", function () {
        adjustDictZoom(1);
      });
      overlayDictZoomOutBtn.addEventListener("click", function () {
        adjustDictZoom(-1);
      });
      overlayDictOpenBtn.addEventListener("click", function () {
        const url = overlayDictOpenBtn.dataset.url || buildNaverDictUrl(lastCapturedWord);
        if (!url) return;
        window.open(url, "_blank", "noopener,noreferrer");
      });

      newTabBtn.addEventListener("click", function () {
        const target = lastBlobUrl || lastPdfUrl;
        if (!target) return;
        window.open(target, "_blank", "noopener,noreferrer");
      });

      const previewScrollHost = previewPages;
      if (previewScrollHost) {
        attachPreviewScrollDiagnostics(previewScrollHost);
        previewScrollHost.addEventListener("scroll", function () {
          lastPreviewScrollAt = Date.now();
          hideWordTooltip();
        }, { passive: true });
      }
      window.addEventListener("resize", function () {
        lockPreviewViewportHeight("resize");
        if (isBlankPenMode && getActiveBlankTab() && !overlayBlankPane.hidden) {
          redrawBlankCanvas();
        }
      });
      window.addEventListener("beforeunload", function () {
        saveLocalDraftNow("beforeunload");
      });

      document.addEventListener("click", function (event) {
        const target = event.target;
        if (!(target instanceof Node)) return;

        if (!overlayFontPopup.hidden && !overlayFontPopup.contains(target) && target !== overlayFontOpenBtn) {
          closeFontPopup();
        }
        if (!overlayTabTypePopup.hidden && !overlayTabTypePopup.contains(target) && target !== overlayAddTabBtn) {
          closeTabTypePopup();
        }
        if (!submitMenuPopup.hidden && !submitMenuPopup.contains(target) && target !== submitMenuBtn) {
          closeSubmitPopup();
        }
        if (!printMenuPopup.hidden && !printMenuPopup.contains(target) && target !== printMenuBtn) {
          closePrintPopup();
        }
        const clickedInsideSessionPopup = eventPathIncludesNode(event, sessionPopup);
        const clickedSessionToggle = eventPathIncludesNode(event, topbarStatus);
        if (!sessionPopup.hidden && !clickedInsideSessionPopup && !clickedSessionToggle) {
          closeSessionPopup();
        }
      });

      document.addEventListener("keydown", function (event) {
        if (event.key !== "Escape") return;
        if (!tabCloseConfirmPopup.hidden) {
          closeTabCloseConfirm();
          return;
        }
        if (!submitMenuPopup.hidden) {
          closeSubmitPopup();
          return;
        }
        if (!printMenuPopup.hidden) {
          closePrintPopup();
          return;
        }
        if (!sessionPopup.hidden) {
          closeSessionPopup();
          return;
        }
        if (!pickerPopup.hidden) {
          closePickerPopup();
          return;
        }
        if (!overlayFontPopup.hidden) {
          closeFontPopup();
          return;
        }
        if (!overlayTabTypePopup.hidden) {
          closeTabTypePopup();
          return;
        }
        if (isMemoOpen()) {
          toggleMemoOverlay(false);
        }
      });

      initializeFileMap();
      setSubmitButtonsUi("idle", "제출");
      updateSessionTabUi();
      const restoredLocalDraft = restoreLocalDraftFromStorage();
      if (restoredLocalDraft) {
        toggleMemoOverlay(true);
        if (getSelectedFileInfo()) {
          void tryLoadPdf();
        } else {
          trace("warn", "local draft restored but selected mock combo is incomplete");
        }
      }
      renderSessionList();
      void fetchLiveSessions(true);
      applyMemoFontSize();
      applyDictZoom();
      applyOverlaySide();
      switchMemoTab(activeMemoTabIndex);
      renderMemoTabbar();
      updateTopbarStatus();
    })();
  </script>
</body>
</html>
