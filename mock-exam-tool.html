<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>모의고사 전용도구</title>
  <link rel="stylesheet" href="styles-frame.css" />
  <link rel="stylesheet" href="nav-buttons.css" />
  <style>
    [hidden] {
      display: none !important;
    }

    *,
    *::before,
    *::after {
      -webkit-tap-highlight-color: transparent;
    }

    :root {
      --topbar-bg: #2e2b27;
      --topbar-border: #b08d57;
      --icon-ink: #f0e6d2;
      --icon-hover: #3a352f;
      --icon-active: #4a433a;

      --panel-bg: #0b0f16;
      --panel-border-a: #ffae42;
      --panel-border-b: #ffd27f;
      --combo-bg: #141c26;
      --combo-ink: #ffd27f;
      --combo-border: #ffae42;
      --combo-hover-bg: #1d2835;
      --button-ink: #0b0f16;

      --workspace-bg: #111722;
      --workspace-border: rgba(255, 210, 127, 0.22);
      --memo-font-size: 15px;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      background: #f0eee9;
    }

    .main-page {
      position: relative;
      width: min(1120px, 96vw);
      height: min(840px, 92vh);
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid rgba(0, 0, 0, 0.14);
      box-shadow: 0 12px 26px rgba(0, 0, 0, 0.14);
      background: #ddd7ca;
    }

    #cafe_int {
      position: absolute;
      inset: 12px;
      border-radius: 14px;
      overflow: hidden;
      background: linear-gradient(180deg, #f5efe2 0%, #e8dfcf 100%);
      border: 1px solid rgba(0, 0, 0, 0.18);
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      z-index: 1;
    }

    .exam-topbar {
      width: 100%;
      height: 60px;
      box-sizing: border-box;
      background: var(--topbar-bg);
      border-bottom: 2px solid var(--topbar-border);
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 10px 10px 20px;
      position: relative;
      z-index: 30;
    }

    .topbar-icon-btn {
      width: 45px;
      height: 45px;
      border-radius: 8px;
      border: none;
      background: transparent;
      color: var(--icon-ink);
      font-size: 20px;
      font-weight: 700;
      line-height: 1;
      cursor: pointer;
      transition: background 0.18s ease, box-shadow 0.18s ease;
      flex: 0 0 auto;
    }

    .topbar-icon-btn:hover {
      background: var(--icon-hover);
    }

    .topbar-icon-btn.is-active {
      background: var(--icon-active);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.2);
    }

    .topbar-status {
      width: min(380px, 50vw);
      min-width: 210px;
      height: 45px;
      border-radius: 8px;
      border: 1px solid rgba(176, 141, 87, 0.7);
      background: linear-gradient(180deg, #fff0c8 0%, #f0d2a0 100%);
      color: #2e2b27;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      padding: 0 26px 0 10px;
      font-size: 11px;
      font-weight: 700;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      position: relative;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      outline: none;
    }

    .topbar-status::after {
      content: "▾";
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 10px;
      opacity: 0.75;
      pointer-events: none;
    }

    .topbar-status:hover {
      background: linear-gradient(180deg, #fff4d6 0%, #f4dbb1 100%);
    }

    .topbar-status.is-active {
      box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.45);
    }

    .topbar-spacer {
      flex: 1;
      min-width: 0;
    }

    .topbar-power-btn {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.65);
      background: var(--topbar-bg);
      color: var(--icon-ink);
      font-size: 16px;
      font-weight: 800;
      cursor: pointer;
      flex: 0 0 auto;
    }

    .pdf-picker-backdrop {
      position: absolute;
      inset: 60px 0 0;
      z-index: 40;
      background: transparent;
    }

    .pdf-picker-popup {
      position: absolute;
      top: 68px;
      left: 20px;
      right: 20px;
      z-index: 45;
    }

    .session-picker-backdrop {
      position: absolute;
      inset: 60px 0 0;
      z-index: 46;
      background: transparent;
    }

    .session-picker-popup {
      position: absolute;
      top: 68px;
      right: 18px;
      width: min(430px, calc(100% - 36px));
      z-index: 48;
    }

    .session-picker-card {
      width: 100%;
      box-sizing: border-box;
      border-radius: 12px;
      border: 1px solid rgba(176, 141, 87, 0.7);
      background:
        radial-gradient(220px 100px at 8% -20%, rgba(255, 189, 216, 0.45), transparent 70%),
        radial-gradient(280px 120px at 100% 125%, rgba(255, 225, 166, 0.32), transparent 75%),
        linear-gradient(180deg, #fff8ed 0%, #ffefd8 100%);
      box-shadow: 0 10px 22px rgba(24, 20, 16, 0.24);
      overflow: hidden;
    }

    .session-picker-head {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(86, 74, 55, 0.2);
      background: linear-gradient(180deg, rgba(255, 238, 206, 0.95) 0%, rgba(255, 226, 177, 0.9) 100%);
    }

    .session-picker-title {
      color: #4d3b2b;
      font-size: 13px;
      font-weight: 800;
      letter-spacing: 0.2px;
    }

    .session-picker-sub {
      color: rgba(77, 59, 43, 0.75);
      font-size: 11px;
      font-weight: 600;
    }

    .session-picker-list {
      max-height: min(46vh, 360px);
      overflow: auto;
      padding: 10px;
      box-sizing: border-box;
      display: grid;
      gap: 8px;
    }

    .session-item-btn {
      width: 100%;
      border-radius: 10px;
      border: 1px solid rgba(126, 104, 76, 0.25);
      background: rgba(255, 255, 255, 0.72);
      cursor: pointer;
      text-align: left;
      padding: 9px 10px;
      box-sizing: border-box;
      transition: border-color 0.16s ease, transform 0.16s ease, background 0.16s ease;
    }

    .session-item-btn:hover {
      border-color: rgba(255, 158, 98, 0.7);
      background: rgba(255, 250, 242, 0.98);
      transform: translateY(-1px);
    }

    .session-item-btn.is-selected {
      border-color: rgba(255, 154, 76, 0.95);
      background:
        linear-gradient(180deg, rgba(255, 236, 210, 0.98) 0%, rgba(255, 226, 191, 0.98) 100%);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.66);
    }

    .session-item-title {
      color: #443425;
      font-size: 12px;
      font-weight: 800;
      line-height: 1.35;
    }

    .session-item-meta {
      margin-top: 3px;
      color: rgba(58, 44, 30, 0.88);
      font-size: 11px;
      font-weight: 700;
      line-height: 1.4;
    }

    .session-item-note {
      margin-top: 4px;
      color: rgba(64, 48, 33, 0.7);
      font-size: 10px;
      line-height: 1.3;
    }

    .pdf-picker-wrap {
      width: 100%;
      margin: 0;
      box-sizing: border-box;
      background: var(--panel-bg);
      border: 2px solid transparent;
      border-radius: 10px;
      background-image:
        linear-gradient(var(--panel-bg), var(--panel-bg)),
        linear-gradient(135deg, var(--panel-border-a) 0%, var(--panel-border-b) 48%, var(--panel-border-a) 100%);
      background-origin: border-box;
      background-clip: padding-box, border-box;
      padding: 8px;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
    }

    @media (min-width: 860px) {
      .pdf-picker-wrap {
        grid-template-columns: repeat(5, minmax(0, 1fr));
      }

      .pdf-open-btn {
        grid-column: auto;
      }
    }

    .pdf-picker-wrap select {
      width: 100%;
      height: 34px;
      border-radius: 6px;
      border: 1px solid var(--combo-border);
      background: var(--combo-bg);
      color: var(--combo-ink);
      font-size: 12px;
      font-weight: 700;
      padding: 0 8px;
      box-sizing: border-box;
      outline: none;
    }

    .pdf-picker-wrap select:hover {
      background: var(--combo-hover-bg);
      border-color: var(--panel-border-b);
    }

    .pdf-open-btn {
      grid-column: span 2;
      height: 34px;
      border-radius: 6px;
      border: 1px solid var(--combo-border);
      background: linear-gradient(135deg, #ffd27f 0%, #ffae42 100%);
      color: var(--button-ink);
      font-size: 13px;
      font-weight: 800;
      cursor: pointer;
    }

    .pdf-open-btn:hover {
      background: linear-gradient(135deg, #fff0b3 0%, #ffcf70 100%);
    }

    .workspace {
      width: calc(100% - 24px);
      flex: 1;
      margin: 12px auto 14px;
      border-radius: 12px;
      border: 1px solid var(--workspace-border);
      background:
        radial-gradient(130px 70px at 15% 15%, rgba(255, 210, 127, 0.16), transparent 75%),
        radial-gradient(220px 120px at 88% 98%, rgba(255, 174, 66, 0.11), transparent 75%),
        var(--workspace-bg);
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      color: #ebd9a7;
      text-align: center;
      padding: 14px;
      position: relative;
    }

    .workspace--has-pdf {
      justify-content: flex-start;
      align-items: stretch;
      gap: 0;
      padding: 10px;
    }

    .pdf-preview {
      width: 100%;
      height: 100%;
      flex: 1;
      min-height: 0;
      border: 1px solid rgba(255, 210, 127, 0.35);
      border-radius: 10px;
      background: #101722;
      overflow: hidden;
      position: relative;
      touch-action: pan-y;
    }

    .pdf-pages {
      width: 100%;
      height: 100%;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 10px 0 16px;
      box-sizing: border-box;
      position: relative;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
      touch-action: pan-y;
    }

    .pdf-page {
      position: relative;
      width: fit-content;
      margin: 0 auto 12px;
      background: #fff;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.16);
    }

    .pdf-page canvas {
      display: block;
      width: 100%;
      height: auto;
      background: #fff;
      touch-action: pan-y;
      cursor: default;
      image-rendering: auto;
    }

    .pdf-text-layer {
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      line-height: 1;
      user-select: none;
      -webkit-user-select: none;
      touch-action: pan-y;
      pointer-events: auto;
    }

    .pdf-text-layer span {
      color: transparent;
      position: absolute;
      white-space: pre;
      cursor: default;
      transform-origin: 0 0;
      touch-action: pan-y;
      -webkit-tap-highlight-color: transparent;
      pointer-events: none;
    }

    .pdf-text-layer span:hover {
      background: rgba(255, 204, 112, 0.34);
    }

    .pdf-text-layer ::selection {
      background: rgba(255, 183, 85, 0.55);
    }

    .pdf-preview iframe {
      width: 100%;
      height: 100%;
      border: none;
      background: #101722;
      position: absolute;
      inset: 0;
    }

    .pdf-word-tooltip {
      position: fixed;
      z-index: 220;
      max-width: min(300px, 72vw);
      background: rgba(17, 14, 11, 0.94);
      color: #fff1cf;
      border: 1px solid rgba(255, 192, 102, 0.72);
      border-radius: 8px;
      padding: 6px 8px;
      box-sizing: border-box;
      font-size: 12px;
      line-height: 1.4;
      box-shadow: 0 5px 16px rgba(0, 0, 0, 0.26);
      pointer-events: none;
      opacity: 0;
      transform: translateY(2px);
      transition: opacity 0.1s ease, transform 0.1s ease;
      white-space: pre-wrap;
    }

    .pdf-word-tooltip.is-visible {
      opacity: 1;
      transform: translateY(0);
    }

    .overlay-memo {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      width: 50%;
      min-width: 320px;
      z-index: 90;
      display: flex;
      flex-direction: column;
      background: rgba(255, 255, 255, 0.98);
      border-left: 2px solid #b08d57;
      border-right: 2px solid #b08d57;
      box-sizing: border-box;
      transform: translateX(102%);
      opacity: 0;
      pointer-events: none;
      transition: transform 0.2s ease, opacity 0.2s ease;
    }

    .overlay-memo.is-left {
      left: 0;
      right: auto;
      transform: translateX(-102%);
    }

    .overlay-memo.is-open {
      transform: translateX(0);
      opacity: 1;
      pointer-events: auto;
    }

    .overlay-memo-topbar {
      height: 70px;
      background-color: #2e2b27;
      border-bottom: 2px solid #b08d57;
      color: #f0e6d2;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 10px;
      box-sizing: border-box;
      flex: 0 0 auto;
    }

    .overlay-memo-title {
      font-size: 20px;
      font-weight: 700;
      letter-spacing: 0.01em;
      color: #f0e6d2;
      margin-right: 6px;
      white-space: nowrap;
    }

    .overlay-memo-close {
      width: 24px;
      height: 24px;
      border: none;
      background: transparent;
      color: #f0e6d2;
      font-size: 16px;
      cursor: pointer;
      flex: 0 0 auto;
      padding: 0;
    }

    .overlay-memo-close:hover {
      color: #ff6666;
    }

    .overlay-memo-topbar-spacer {
      flex: 1;
      min-width: 0;
    }

    .overlay-memo-tool-btn {
      height: 32px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.24);
      background-color: #4a463f;
      color: #f0e6d2;
      font-size: 13px;
      font-weight: 700;
      padding: 0 10px;
      cursor: pointer;
      flex: 0 0 auto;
    }

    .overlay-memo-tool-btn:hover {
      background-color: #5c574e;
    }

    .overlay-mini-popup {
      position: absolute;
      top: 76px;
      right: 12px;
      z-index: 8;
      background: #2e2b27;
      border: 1px solid rgba(255, 255, 255, 0.58);
      border-radius: 8px;
      padding: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.32);
    }

    .overlay-mini-popup[hidden] {
      display: none;
    }

    .overlay-mini-step-btn {
      width: 30px;
      height: 30px;
      border: none;
      border-radius: 6px;
      background: #4a463f;
      color: #f0e6d2;
      font-size: 17px;
      cursor: pointer;
      padding: 0;
    }

    .overlay-mini-step-btn:hover {
      background: #5c574e;
    }

    .overlay-font-size-value {
      min-width: 46px;
      text-align: center;
      font-size: 12px;
      font-weight: 700;
      color: #f0e6d2;
      letter-spacing: 0.01em;
    }

    .overlay-memo-body {
      flex: 1;
      min-height: 0;
      background-color: #fdf3e7;
      display: flex;
      position: relative;
    }

    .overlay-pane {
      flex: 1;
      min-height: 0;
      width: 100%;
      display: flex;
    }

    .overlay-pane[hidden] {
      display: none;
    }

    .overlay-blank-pane {
      position: relative;
      overflow: hidden;
      background: #fdf3e7;
    }

    .overlay-blank-controls {
      position: absolute;
      top: 8px;
      right: 10px;
      z-index: 6;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .overlay-blank-tool-btn {
      height: 28px;
      border-radius: 8px;
      border: 1px solid rgba(46, 43, 39, 0.26);
      background: rgba(255, 255, 255, 0.92);
      color: #2e2b27;
      font-size: 11px;
      font-weight: 700;
      padding: 0 10px;
      cursor: pointer;
      box-sizing: border-box;
      transition: background 0.14s ease, border-color 0.14s ease;
      line-height: 1;
    }

    .overlay-blank-tool-btn:hover {
      background: #fff6e7;
      border-color: rgba(46, 43, 39, 0.4);
    }

    .overlay-blank-tool-btn.is-on {
      background: linear-gradient(180deg, #ffe09a 0%, #f4bf5a 100%);
      border-color: rgba(141, 95, 28, 0.72);
      color: #2c2217;
    }

    .overlay-blank-tool-btn:disabled {
      opacity: 0.5;
      cursor: default;
    }

    .overlay-memo-textarea {
      flex: 1;
      min-height: 0;
      width: 100%;
      box-sizing: border-box;
      resize: none;
      border: none;
      outline: none;
      padding: 12px;
      font-size: var(--memo-font-size);
      line-height: 1.45;
      background: #fdf3e7;
      color: #2e2b27;
      font-family: "Malgun Gothic", "Apple SD Gothic Neo", sans-serif;
      padding-top: 44px;
    }

    .overlay-memo-textarea::placeholder {
      color: rgba(46, 43, 39, 0.38);
    }

    .overlay-blank-pane.is-pen-mode .overlay-memo-textarea {
      display: none;
    }

    .overlay-blank-draw-wrap {
      position: absolute;
      inset: 0;
      z-index: 4;
      background: #fdf3e7;
      border-top: 1px solid rgba(46, 43, 39, 0.08);
      touch-action: none;
    }

    .overlay-blank-draw-wrap[hidden] {
      display: none;
    }

    .overlay-blank-draw-canvas {
      width: 100%;
      height: 100%;
      display: block;
      background:
        linear-gradient(180deg, rgba(140, 116, 86, 0.06) 0, rgba(140, 116, 86, 0.06) 1px, transparent 1px, transparent 34px);
      background-size: 100% 34px;
      cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='18' height='18' viewBox='0 0 18 18'%3E%3Cpath d='M2 16l3.2-.8 8.6-8.6-2.4-2.4-8.6 8.6L2 16z' fill='%232f2a24' stroke='%23f4c36d' stroke-width='.8'/%3E%3Cpath d='M11.4 2.2l2.4 2.4 1.2-1.2c.7-.7.7-1.8 0-2.5-.7-.7-1.8-.7-2.5 0l-1.1 1.3z' fill='%23463b2c'/%3E%3C/svg%3E") 2 16, pointer;
      touch-action: none;
    }

    .overlay-two-three {
      display: grid;
      grid-template-columns: 3fr 7fr;
      gap: 0;
      width: 100%;
      height: 100%;
      position: relative;
    }

    .overlay-two-three.is-flipped {
      grid-template-columns: 7fr 3fr;
    }

    .overlay-two-col {
      display: flex;
      flex-direction: column;
      min-height: 0;
      overflow: hidden;
    }

    .overlay-two-col--twoT {
      background: #fdf3e7;
      color: #2e2b27;
    }

    .overlay-two-col--threeT {
      background: #463b2c;
      color: #f7f2e8;
      border-left: 1px solid rgba(42, 30, 23, 0.95);
    }

    .overlay-two-three.is-flipped .overlay-two-col--threeT {
      border-left: none;
      border-right: 1px solid rgba(42, 30, 23, 0.95);
      order: 1;
    }

    .overlay-two-three.is-flipped .overlay-two-col--twoT {
      order: 2;
    }

    .overlay-two-head {
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 0 8px;
      font-size: 11px;
      font-weight: 700;
      border-bottom: 1px solid rgba(42, 30, 23, 0.25);
      box-sizing: border-box;
    }

    .overlay-two-head-label {
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .overlay-two-head-toggle {
      height: 24px;
      min-width: 70px;
      border-radius: 8px;
      border: 1px solid rgba(120, 84, 39, 0.58);
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.42) 0%, rgba(255, 255, 255, 0.06) 42%, rgba(0, 0, 0, 0.06) 100%),
        linear-gradient(180deg, #fff2ce 0%, #e8c788 100%);
      color: #3b2c22;
      font-size: 10px;
      font-weight: 800;
      letter-spacing: 0.01em;
      cursor: pointer;
      flex: 0 0 auto;
      padding: 0 10px;
      box-sizing: border-box;
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.58),
        0 1px 2px rgba(0, 0, 0, 0.22);
      transition: filter 0.16s ease, transform 0.16s ease;
    }

    .overlay-two-head-toggle:hover {
      filter: brightness(1.05);
    }

    .overlay-two-head-toggle.is-on {
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.36) 0%, rgba(255, 255, 255, 0.04) 40%, rgba(0, 0, 0, 0.08) 100%),
        linear-gradient(180deg, #ffd97d 0%, #f0b145 100%);
      border-color: #ad6f1d;
      color: #2f241a;
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.48),
        0 1px 3px rgba(0, 0, 0, 0.3);
    }

    .overlay-two-col--threeT .overlay-two-head {
      border-bottom-color: rgba(247, 242, 232, 0.18);
    }

    .overlay-three-head-tools {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      flex: 0 0 auto;
    }

    .overlay-three-head-pen-toggle {
      height: 24px;
      min-width: 56px;
      border-radius: 8px;
      border: 1px solid rgba(247, 242, 232, 0.26);
      background: rgba(77, 65, 50, 0.92);
      color: #f2e8d4;
      font-size: 10px;
      font-weight: 800;
      cursor: pointer;
      padding: 0 9px;
      box-sizing: border-box;
      flex: 0 0 auto;
    }

    .overlay-three-head-pen-toggle:hover {
      background: rgba(94, 80, 62, 0.95);
    }

    .overlay-three-head-pen-toggle.is-on {
      background: linear-gradient(180deg, #ffd27c 0%, #f2b14d 100%);
      border-color: rgba(156, 102, 24, 0.76);
      color: #2c2116;
    }

    .overlay-three-head-pen-toggle:disabled {
      opacity: 0.44;
      cursor: default;
    }

    .overlay-three-head-clear-btn {
      height: 24px;
      min-width: 56px;
      border-radius: 8px;
      border: 1px solid rgba(247, 242, 232, 0.24);
      background: rgba(71, 59, 46, 0.9);
      color: #f2e8d4;
      font-size: 10px;
      font-weight: 800;
      cursor: pointer;
      padding: 0 9px;
      box-sizing: border-box;
      flex: 0 0 auto;
    }

    .overlay-three-head-clear-btn:hover {
      background: rgba(90, 74, 58, 0.94);
    }

    .overlay-three-head-clear-btn:disabled {
      opacity: 0.38;
      cursor: default;
    }

    .overlay-two-col--threeT .overlay-two-head.is-dict-mode {
      background: linear-gradient(180deg, #15120f 0%, #090807 100%);
      color: #f4e9cc;
      border-bottom-color: rgba(244, 233, 204, 0.22);
      text-shadow: 0 1px 0 rgba(0, 0, 0, 0.52);
    }

    .overlay-two-scroll {
      flex: 1;
      min-height: 0;
      width: 100%;
      overflow-y: auto;
      box-sizing: border-box;
      padding: 8px 8px 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: stretch;
    }

    #mock-overlay-two-right-list {
      padding-right: 16px;
    }

    .overlay-two-scroll::-webkit-scrollbar {
      width: 8px;
    }

    .overlay-two-scroll::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 999px;
    }

    .overlay-dict-panel {
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
      background: #17120e;
    }

    .overlay-dict-panel:not([hidden]) {
      animation: overlay-dict-slide-up 0.24s ease-out;
    }

    @keyframes overlay-dict-slide-up {
      from {
        opacity: 0;
        transform: translateY(16px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .overlay-dict-toolbar {
      height: 30px;
      border-bottom: 1px solid rgba(247, 242, 232, 0.18);
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 0 8px;
      box-sizing: border-box;
      background: rgba(20, 14, 10, 0.86);
    }

    .overlay-dict-current {
      flex: 1;
      min-width: 0;
      font-size: 10px;
      color: rgba(247, 242, 232, 0.86);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .overlay-dict-open {
      height: 22px;
      border-radius: 999px;
      border: 1px solid rgba(247, 242, 232, 0.28);
      background: #4a463f;
      color: #f0e6d2;
      font-size: 10px;
      font-weight: 700;
      padding: 0 8px;
      cursor: pointer;
      flex: 0 0 auto;
    }

    .overlay-dict-open:disabled {
      opacity: 0.42;
      cursor: default;
    }

    .overlay-dict-zoom-btn {
      width: 22px;
      height: 22px;
      border-radius: 6px;
      border: 1px solid rgba(247, 242, 232, 0.24);
      background: rgba(87, 78, 67, 0.96);
      color: #f0e6d2;
      font-size: 13px;
      font-weight: 700;
      cursor: pointer;
      padding: 0;
      line-height: 1;
      flex: 0 0 auto;
    }

    .overlay-dict-zoom-btn:hover {
      background: rgba(106, 95, 82, 0.98);
    }

    .overlay-dict-zoom-value {
      min-width: 36px;
      text-align: center;
      font-size: 10px;
      color: rgba(247, 242, 232, 0.92);
      font-weight: 700;
      letter-spacing: 0.01em;
      flex: 0 0 auto;
    }

    .overlay-dict-frame {
      width: 100%;
      flex: 1;
      min-height: 0;
      border: none;
      background: #fff;
    }

    .overlay-card {
      border-radius: 8px;
      overflow: hidden;
      box-sizing: border-box;
      flex: 0 0 auto;
      width: 100%;
    }

    .overlay-card--twoT {
      background: #f3e5bb;
      border: 2px solid #d6b97f;
      min-height: 84px;
    }

    .overlay-card--twoT.is-captured {
      border-color: #efaf47;
      box-shadow: 0 0 0 2px rgba(239, 175, 71, 0.26);
    }

    .overlay-card--threeT {
      background: #3b2a1f;
      border: 1px solid #2a1e17;
      min-height: 86px;
    }

    .overlay-two-three.is-three-pen-mode .overlay-card--threeT {
      min-height: 212px;
    }

    .overlay-card-inner {
      box-sizing: border-box;
      padding: 7px;
      display: grid;
      gap: 7px;
    }

    .overlay-card-inner--twoT {
      background: linear-gradient(180deg, #fff6d6 0%, #edd8a2 100%);
      border: 1px solid #e4c98e;
      border-radius: 6px;
    }

    .overlay-card-inner--threeT {
      background: #3f2d22;
      border: 1px solid #201711;
      border-radius: 5px;
    }

    .overlay-card-row {
      display: flex;
      align-items: flex-start;
      gap: 6px;
    }

    .overlay-card-row--threeT {
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 2px;
    }

    .overlay-three-card-tools {
      margin-left: auto;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      flex: 0 0 auto;
    }

    .overlay-three-card-tool-btn {
      height: 20px;
      min-width: 44px;
      border-radius: 6px;
      border: 1px solid rgba(247, 242, 232, 0.3);
      background: rgba(76, 62, 48, 0.92);
      color: #f6ead5;
      font-size: 9px;
      font-weight: 800;
      padding: 0 6px;
      cursor: pointer;
      box-sizing: border-box;
      line-height: 1;
    }

    .overlay-three-card-tool-btn:hover {
      background: rgba(96, 79, 61, 0.96);
    }

    .overlay-card-row .overlay-card-input,
    .overlay-card-row .overlay-card-textarea {
      flex: 1;
      min-width: 0;
      width: 100%;
      max-width: 100%;
    }

    .overlay-card-row--twoT {
      display: grid;
      grid-template-columns: 14px minmax(0, 1fr);
      align-items: center;
      gap: 6px;
    }

    .overlay-card-index {
      flex: 0 0 auto;
      min-width: 20px;
      height: 20px;
      border-radius: 4px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: 800;
      letter-spacing: 0.02em;
    }

    .overlay-card-index--twoT {
      background: rgba(42, 30, 23, 0.08);
      color: #2e2b27;
      border: 1px solid rgba(42, 30, 23, 0.2);
      min-width: 12px;
      width: 12px;
      height: 12px;
      font-size: 8px;
      border-radius: 3px;
    }

    .overlay-card-index--threeT {
      background: #2a1e17;
      color: #f7f2e8;
      border: 1px solid #1b130e;
    }

    .overlay-card-input,
    .overlay-card-textarea {
      border: none;
      outline: none;
      box-sizing: border-box;
      font-family: "Malgun Gothic", "Apple SD Gothic Neo", sans-serif;
      font-size: var(--memo-font-size);
      width: 100%;
      max-width: 100%;
    }

    .overlay-card-input {
      height: 30px;
      border-radius: 5px;
      padding: 3px 6px;
    }

    .overlay-card-textarea {
      min-height: 48px;
      border-radius: 5px;
      padding: 5px 6px;
      resize: vertical;
      line-height: 1.45;
    }

    .overlay-card-input--twoT,
    .overlay-card-textarea--twoT {
      background: #fff9e9;
      color: #2e2b27;
      border: 1px solid #d6b97f;
      font-size: calc(var(--memo-font-size) - 1px) !important;
      line-height: 1.35;
    }

    .overlay-card-input--twoT {
      height: 32px !important;
      padding: 3px 8px !important;
    }

    .overlay-card-textarea--twoT {
      min-height: 44px !important;
      padding: 5px 8px !important;
      resize: vertical;
    }

    .overlay-card-textarea--threeT {
      min-height: 30px;
      padding: 5px 6px;
      resize: vertical;
    }

    .overlay-card-textarea--threeT-sentence {
      min-height: 32px !important;
      max-height: 90px;
    }

    .overlay-two-three.is-three-pen-mode .overlay-card-textarea--threeT-sentence {
      display: none;
      min-height: 68px !important;
      max-height: 180px;
    }

    .overlay-card-input--threeT,
    .overlay-card-textarea--threeT {
      background: #2f221a;
      color: #f7f2e8;
      border: 1px solid #1c140f;
    }

    .overlay-card-input--threeT::placeholder,
    .overlay-card-textarea--threeT::placeholder {
      color: rgba(247, 242, 232, 0.45);
    }

    .overlay-card-input--twoT::placeholder,
    .overlay-card-textarea--twoT::placeholder {
      color: rgba(46, 43, 39, 0.38);
    }

    .overlay-three-ink-wrap {
      margin-top: 6px;
      height: 86px;
      border: 1px solid rgba(247, 242, 232, 0.26);
      border-radius: 6px;
      background: rgba(246, 239, 225, 0.06);
      overflow: hidden;
      touch-action: none;
      display: none;
      position: relative;
    }

    .overlay-two-three.is-three-pen-mode .overlay-three-ink-wrap {
      display: block;
      margin-top: 0;
      height: 182px;
    }

    .overlay-three-ink-canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
      cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='18' height='18' viewBox='0 0 18 18'%3E%3Cpath d='M2 16l3.2-.8 8.6-8.6-2.4-2.4-8.6 8.6L2 16z' fill='%23f7f2e8' stroke='%233b2a1f' stroke-width='.8'/%3E%3Cpath d='M11.4 2.2l2.4 2.4 1.2-1.2c.7-.7.7-1.8 0-2.5-.7-.7-1.8-.7-2.5 0l-1.1 1.3z' fill='%23f2b14d'/%3E%3C/svg%3E") 2 16, pointer;
      background:
        linear-gradient(180deg, rgba(244, 230, 205, 0.06) 0, rgba(244, 230, 205, 0.06) 1px, transparent 1px, transparent 26px);
      background-size: 100% 26px;
    }

    .overlay-side-flip {
      position: absolute;
      top: 50%;
      left: -12px;
      width: 12px;
      height: 44px;
      transform: translateY(-50%);
      border: none;
      background: #d6b97f;
      clip-path: polygon(100% 0, 0 50%, 100% 100%);
      cursor: pointer;
      padding: 0;
      z-index: 95;
      opacity: 0.94;
    }

    .overlay-side-flip:hover {
      background: #c4a96b;
      opacity: 1;
    }

    .overlay-memo.is-left .overlay-side-flip {
      left: auto;
      right: -12px;
      transform: translateY(-50%) rotate(180deg);
    }

    .overlay-memo-tabbar {
      height: 42px;
      background-color: #2e2b27;
      border-top: 2px solid #b08d57;
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 5px;
      box-sizing: border-box;
      flex: 0 0 auto;
    }

    .overlay-tab-list {
      display: flex;
      align-items: center;
      gap: 5px;
      min-width: 0;
      overflow-x: auto;
      flex: 1;
    }

    .overlay-tab-list::-webkit-scrollbar {
      height: 6px;
    }

    .overlay-tab-list::-webkit-scrollbar-thumb {
      background: rgba(240, 230, 210, 0.35);
      border-radius: 999px;
    }

    .overlay-tab-item {
      display: inline-flex;
      align-items: center;
      flex: 0 0 auto;
      gap: 0;
    }

    .overlay-tab-btn {
      width: 30px;
      height: 30px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 700;
    }

    .overlay-tab-btn.is-active {
      background-color: #2e2b27;
      color: #f0e6d2;
    }

    .overlay-tab-btn.is-active:hover {
      background-color: #3a3733;
    }

    .overlay-tab-btn.is-inactive {
      background-color: #4a463f;
      color: #d0c9b9;
    }

    .overlay-tab-btn.is-inactive:hover {
      background-color: #5c574e;
      color: #f0e6d2;
    }

    .overlay-tab-close {
      width: 20px;
      height: 30px;
      border: none;
      background: transparent;
      color: #f0e6d2;
      cursor: pointer;
      font-size: 12px;
      padding: 0;
    }

    .overlay-tab-close:hover {
      color: #ff6666;
    }

    .overlay-tab-add {
      width: 32px;
      height: 30px;
      border: none;
      border-radius: 6px;
      background-color: #4a463f;
      color: #f0e6d2;
      font-size: 17px;
      line-height: 1;
      cursor: pointer;
      flex: 0 0 auto;
    }

    .overlay-tab-add:hover {
      background-color: #5c574e;
    }

    .overlay-tab-type-popup {
      position: absolute;
      right: 10px;
      bottom: 52px;
      z-index: 8;
      background: #2e2b27;
      border: 1px solid rgba(255, 255, 255, 0.58);
      border-radius: 8px;
      padding: 6px;
      display: grid;
      gap: 6px;
      min-width: 164px;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.32);
    }

    .overlay-tab-type-popup[hidden] {
      display: none;
    }

    .overlay-type-option {
      border: none;
      border-radius: 6px;
      background: #4a463f;
      color: #f0e6d2;
      height: 32px;
      font-size: 12px;
      font-weight: 700;
      cursor: pointer;
      text-align: left;
      padding: 0 10px;
    }

    .overlay-type-option:hover {
      background: #5c574e;
    }

    .pdf-preview-empty {
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: rgba(235, 217, 167, 0.75);
      padding: 12px;
      text-align: center;
      box-sizing: border-box;
      position: absolute;
      inset: 0;
    }

    .pdf-quick-link {
      position: absolute;
      top: 16px;
      right: 16px;
      z-index: 4;
      color: #ffe9bb;
      font-size: 12px;
      text-decoration: underline;
      cursor: pointer;
      border: none;
      background: rgba(0, 0, 0, 0.24);
      border-radius: 8px;
      padding: 5px 8px;
    }

    #back-to-tray-btn {
      position: absolute;
      bottom: 18px;
      left: 18px;
      z-index: 999;
    }
  </style>
</head>
<body>
  <div class="main-page">
    <div id="cafe_int">
      <div class="exam-topbar">
        <button id="mock-topbar-picker-btn" class="topbar-icon-btn" type="button" title="PDF 불러오기">📂</button>
        <button id="mock-topbar-memo-btn" class="topbar-icon-btn" type="button" title="오버레이 메모">📝</button>
        <div class="topbar-spacer"></div>
        <button id="mock-topbar-status" class="topbar-status" type="button">고3 · 연도 선택</button>
        <button class="topbar-power-btn" type="button" title="전원">⏻</button>
      </div>
      <div id="mock-session-backdrop" class="session-picker-backdrop" hidden></div>
      <div id="mock-session-popup" class="session-picker-popup" hidden>
        <div class="session-picker-card">
          <div class="session-picker-head">
            <span class="session-picker-title">오늘 수업 리스트</span>
            <span class="session-picker-sub">sample presets</span>
          </div>
          <div id="mock-session-list" class="session-picker-list"></div>
        </div>
      </div>

      <div id="mock-workspace" class="workspace workspace--has-pdf">
        <button id="mock-pdf-open-newtab" class="pdf-quick-link" type="button" hidden>새 탭에서 열기</button>
        <div class="pdf-preview">
          <div id="pdf-preview-empty" class="pdf-preview-empty">상단에서 시험 구성을 고른 뒤<br />PDF 불러오기를 눌러주세요.</div>
          <div id="mock-pdf-pages" class="pdf-pages" hidden></div>
          <iframe id="mock-pdf-frame" title="모의고사 PDF 미리보기" hidden></iframe>
        </div>
      </div>

      <div id="mock-overlay-memo" class="overlay-memo" aria-hidden="true">
        <div class="overlay-memo-topbar">
          <span class="overlay-memo-title">NOTES : 필기</span>
          <button id="mock-overlay-close-btn" class="overlay-memo-close" type="button" aria-label="메모 닫기">✕</button>
          <div class="overlay-memo-topbar-spacer"></div>
          <button id="mock-overlay-font-open" class="overlay-memo-tool-btn" type="button">A+-</button>
          <div id="mock-overlay-font-popup" class="overlay-mini-popup" hidden>
            <button id="mock-overlay-font-dec" class="overlay-mini-step-btn" type="button" aria-label="폰트 줄이기">-</button>
            <div id="mock-overlay-font-size-value" class="overlay-font-size-value">16px</div>
            <button id="mock-overlay-font-inc" class="overlay-mini-step-btn" type="button" aria-label="폰트 키우기">+</button>
          </div>
        </div>
        <button id="mock-overlay-two-flip-triangle" class="overlay-side-flip" type="button" aria-label="오버레이 좌우 전환" title="오버레이 좌우 전환"></button>
        <div class="overlay-memo-body">
          <div id="mock-overlay-blank-pane" class="overlay-pane overlay-blank-pane">
            <div class="overlay-blank-controls">
              <button id="mock-blank-pen-toggle" class="overlay-blank-tool-btn" type="button" aria-pressed="false" title="필기 모드">
                펜
              </button>
              <button id="mock-blank-pen-clear" class="overlay-blank-tool-btn" type="button" title="필기 지우기">
                지우기
              </button>
            </div>
            <textarea id="mock-overlay-memo-text" class="overlay-memo-textarea" placeholder="메모를 적어주세요..."></textarea>
            <div id="mock-blank-draw-wrap" class="overlay-blank-draw-wrap" hidden>
              <canvas id="mock-blank-draw-canvas" class="overlay-blank-draw-canvas"></canvas>
            </div>
          </div>
          <div id="mock-overlay-two-three-pane" class="overlay-pane overlay-two-three" hidden>
            <div class="overlay-two-col overlay-two-col--twoT">
              <div class="overlay-two-head">
                <span class="overlay-two-head-label">2T · 단어/뜻</span>
                <button
                  id="mock-overlay-dict-toggle"
                  class="overlay-two-head-toggle"
                  type="button"
                  aria-pressed="false"
                  title="3T 영역 사전 검색 토글"
                >
                  검색창
                </button>
              </div>
              <div id="mock-overlay-two-left-list" class="overlay-two-scroll"></div>
            </div>
            <div id="mock-overlay-three-col" class="overlay-two-col overlay-two-col--threeT">
              <div id="mock-overlay-three-head" class="overlay-two-head">
                <span id="mock-overlay-three-head-label" class="overlay-two-head-label">3T · 문장/분석</span>
                <div class="overlay-three-head-tools">
                  <button id="mock-overlay-three-pen-toggle" class="overlay-three-head-pen-toggle" type="button" aria-pressed="false">
                    펜
                  </button>
                  <button id="mock-overlay-three-pen-clear" class="overlay-three-head-clear-btn" type="button" disabled title="3T 필기 지우기">
                    지우기
                  </button>
                </div>
              </div>
              <div id="mock-overlay-two-right-list" class="overlay-two-scroll"></div>
              <div id="mock-overlay-dict-panel" class="overlay-dict-panel" hidden>
                <div class="overlay-dict-toolbar">
                  <span id="mock-overlay-dict-current" class="overlay-dict-current">단어를 클릭하면 검색됩니다.</span>
                  <button id="mock-overlay-dict-zoom-out" class="overlay-dict-zoom-btn" type="button" aria-label="검색창 축소">-</button>
                  <span id="mock-overlay-dict-zoom-value" class="overlay-dict-zoom-value">100%</span>
                  <button id="mock-overlay-dict-zoom-in" class="overlay-dict-zoom-btn" type="button" aria-label="검색창 확대">+</button>
                  <button id="mock-overlay-dict-open" class="overlay-dict-open" type="button" disabled>새 탭</button>
                </div>
                <iframe
                  id="mock-overlay-dict-frame"
                  class="overlay-dict-frame"
                  title="네이버 영한 검색"
                  referrerpolicy="no-referrer-when-downgrade"
                ></iframe>
              </div>
            </div>
          </div>
        </div>
        <div class="overlay-memo-tabbar">
          <div id="mock-overlay-tab-list" class="overlay-tab-list"></div>
          <button id="mock-overlay-add-tab" class="overlay-tab-add" type="button" aria-label="메모 탭 추가">＋</button>
          <div id="mock-overlay-tab-type-popup" class="overlay-tab-type-popup" hidden>
            <button class="overlay-type-option" type="button" data-type="blank">blank</button>
            <button class="overlay-type-option" type="button" data-type="two_three">two three page</button>
          </div>
        </div>
      </div>

      <div id="mock-picker-backdrop" class="pdf-picker-backdrop" hidden></div>
      <div id="mock-picker-popup" class="pdf-picker-popup" hidden>
        <div class="pdf-picker-wrap" aria-label="PDF 불러오기">
          <select id="mock-grade-select" aria-label="학년">
            <option value="">학년 로딩중...</option>
          </select>
          <select id="mock-year-select" aria-label="연도">
            <option value="">연도 로딩중...</option>
          </select>
          <select id="mock-exam-select" aria-label="몇평">
            <option value="">몇평 선택</option>
          </select>
          <select id="mock-type-select" aria-label="유형">
            <option value="">유형 선택</option>
          </select>
          <button id="mock-pdf-open-btn" class="pdf-open-btn" type="button">PDF 불러오기</button>
        </div>
      </div>
    </div>

    <button
      id="back-to-tray-btn"
      class="nav-mainhall-btn"
      data-nav-mainhall="homework-tray_v1.html"
      data-nav-replace="true"
    >
      ⬅ 테이블로 돌아가기
    </button>
  </div>

  <script src="nav-buttons.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script>
    (function () {
      const pickerToggleBtn = document.getElementById("mock-topbar-picker-btn");
      const memoToggleBtn = document.getElementById("mock-topbar-memo-btn");
      const pickerPopup = document.getElementById("mock-picker-popup");
      const pickerBackdrop = document.getElementById("mock-picker-backdrop");
      const sessionPopup = document.getElementById("mock-session-popup");
      const sessionBackdrop = document.getElementById("mock-session-backdrop");
      const sessionList = document.getElementById("mock-session-list");
      const overlayMemo = document.getElementById("mock-overlay-memo");
      const overlayCloseBtn = document.getElementById("mock-overlay-close-btn");
      const overlayFontOpenBtn = document.getElementById("mock-overlay-font-open");
      const overlayFontPopup = document.getElementById("mock-overlay-font-popup");
      const overlayFontDecBtn = document.getElementById("mock-overlay-font-dec");
      const overlayFontIncBtn = document.getElementById("mock-overlay-font-inc");
      const overlayFontSizeValue = document.getElementById("mock-overlay-font-size-value");
      const overlayBlankPane = document.getElementById("mock-overlay-blank-pane");
      const overlayTwoThreePane = document.getElementById("mock-overlay-two-three-pane");
      const overlayTwoFlipTriangleBtn = document.getElementById("mock-overlay-two-flip-triangle");
      const overlayMemoText = document.getElementById("mock-overlay-memo-text");
      const blankPenToggleBtn = document.getElementById("mock-blank-pen-toggle");
      const blankPenClearBtn = document.getElementById("mock-blank-pen-clear");
      const blankDrawWrap = document.getElementById("mock-blank-draw-wrap");
      const blankDrawCanvas = document.getElementById("mock-blank-draw-canvas");
      const overlayTwoLeftList = document.getElementById("mock-overlay-two-left-list");
      const overlayTwoRightList = document.getElementById("mock-overlay-two-right-list");
      const overlayThreeCol = document.getElementById("mock-overlay-three-col");
      const overlayThreeHead = document.getElementById("mock-overlay-three-head");
      const overlayThreeHeadLabel = document.getElementById("mock-overlay-three-head-label");
      const overlayThreePenToggleBtn = document.getElementById("mock-overlay-three-pen-toggle");
      const overlayThreePenClearBtn = document.getElementById("mock-overlay-three-pen-clear");
      const overlayDictToggleBtn = document.getElementById("mock-overlay-dict-toggle");
      const overlayDictPanel = document.getElementById("mock-overlay-dict-panel");
      const overlayDictFrame = document.getElementById("mock-overlay-dict-frame");
      const overlayDictCurrent = document.getElementById("mock-overlay-dict-current");
      const overlayDictZoomOutBtn = document.getElementById("mock-overlay-dict-zoom-out");
      const overlayDictZoomInBtn = document.getElementById("mock-overlay-dict-zoom-in");
      const overlayDictZoomValue = document.getElementById("mock-overlay-dict-zoom-value");
      const overlayDictOpenBtn = document.getElementById("mock-overlay-dict-open");
      const overlayTabList = document.getElementById("mock-overlay-tab-list");
      const overlayAddTabBtn = document.getElementById("mock-overlay-add-tab");
      const overlayTabTypePopup = document.getElementById("mock-overlay-tab-type-popup");
      const overlayTypeOptionBtns = Array.from(document.querySelectorAll("#mock-overlay-tab-type-popup [data-type]"));
      const topbarStatus = document.getElementById("mock-topbar-status");
      const openBtn = document.getElementById("mock-pdf-open-btn");
      const gradeSel = document.getElementById("mock-grade-select");
      const yearSel = document.getElementById("mock-year-select");
      const examSel = document.getElementById("mock-exam-select");
      const typeSel = document.getElementById("mock-type-select");
      const previewPages = document.getElementById("mock-pdf-pages");
      const previewFrame = document.getElementById("mock-pdf-frame");
      const previewEmpty = document.getElementById("pdf-preview-empty");
      const newTabBtn = document.getElementById("mock-pdf-open-newtab");

      const SUPABASE_ORIGIN = "https://yslwgaephsnbfoiqnpuw.supabase.co";
      const SUPABASE_BASE = `${SUPABASE_ORIGIN}/storage/v1/object/public`;
      const BUCKET = "ksat-moi-sets";
      const FOLDER = "High3";
      const GRADE_OPTIONS = [{ value: "High3", label: "고3" }];

      const YEAR_CANDIDATES = (function () {
        const years = [];
        const startYear = 2017;
        const latestStartYear = new Date().getFullYear() - 1; // 예: 2026 -> 2025to2026
        for (let y = startYear; y <= latestStartYear; y += 1) {
          years.push(`${y}to${y + 1}`);
        }
        return years;
      })();

      const EXAM_META = [
        { key: "march", label: "3평", token: "march" },
        { key: "april", label: "4평", token: "april" },
        { key: "june", label: "6평", token: "june" },
        { key: "july", label: "7평", token: "july" },
        { key: "october", label: "10평", token: "october" },
        { key: "november", label: "수능", token: "november" }
      ];

      const TYPE_META = [
        { label: "시험지", suffix: "" },
        { label: "대본", suffix: "_script" },
        { label: "해설", suffix: "_answer" }
      ];
      const DEFAULT_TYPE_LABEL = "시험지";
      const FIXED_STUDENT_ID = new URLSearchParams(window.location.search).get("id") || "";
      const PDFJS_WORKER_SRC = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";
      const RENDER_QUALITY_BOOST = 1.35;
      const THREE_PEN_COLOR = "#f3e8d2";
      const THREE_PEN_WIDTH_SCALE = 0.72;
      const NAVER_EN_KO_SEARCH_BASE = "https://en.dict.naver.com/#/search?query=";
      const DICT_ZOOM_MIN = 0.8;
      const DICT_ZOOM_MAX = 1.8;
      const DICT_ZOOM_STEP = 0.1;

      let lastBlobUrl = "";
      let lastPdfUrl = "";
      let memoFontSize = 15;
      let overlaySide = "right";
      let nextMemoTabId = 2;
      const DEFAULT_TWO_T_CARD_COUNT = 50;
      const DEFAULT_THREE_T_CARD_COUNT = 15;
      const memoTabs = [{
        id: 1,
        type: "blank",
        blankText: "",
        twoThree: null,
        blankInk: []
      }];
      let activeMemoTabIndex = 0;
      const TAB_TYPE_LABEL = {
        blank: "blank",
        two_three: "two three page"
      };
      const SAMPLE_CLASS_SESSIONS = [
        {
          date: "2026-02-13 09:00",
          note: "단어 체크 + 수능 지문 감각 유지",
          mock: { year: "2023to2024", examKey: "november" },
          overlaySide: "right",
          openMemo: true,
          activeTabIndex: 0,
          tabs: [
            {
              type: "two_three",
              words: [
                { word: "cherish", meaning: "소중히 여기다" },
                { word: "vivid", meaning: "생생한, 선명한" },
                { word: "crucial", meaning: "아주 중요한" },
                { word: "tremble", meaning: "떨다, 떨리다" },
                { word: "fragile", meaning: "깨지기 쉬운, 약한" },
                { word: "nurture", meaning: "양육하다, 키우다" },
                { word: "cozy", meaning: "아늑한" },
                { word: "polish", meaning: "다듬다, 윤을 내다" }
              ],
              sentences: [
                { sentence: "A cozy routine can make hard study days feel softer." },
                { sentence: "The teacher's vivid examples helped her keep each idea." },
                { sentence: "Consistency is crucial when preparing for mock exams." },
                { sentence: "He polished his weak part before the timed drill." },
                { sentence: "Even a fragile confidence can grow with steady practice." },
                { sentence: "They nurtured calm focus by checking one paragraph at a time." }
              ]
            },
            {
              type: "blank",
              blankText: "today plan\n1) 31번 근거문장 표시\n2) 낯선 어휘 8개 외우기\n3) 마지막 10분 검토 루틴"
            }
          ]
        },
        {
          date: "2026-02-13 11:00",
          note: "듣기 대본 기반 표현 정리",
          mock: { year: "2017to2018", examKey: "july", typeLabel: "대본" },
          overlaySide: "left",
          openMemo: true,
          activeTabIndex: 0,
          tabs: [
            {
              type: "two_three",
              words: [
                { word: "clarify", meaning: "명확히 하다" },
                { word: "observe", meaning: "관찰하다" },
                { word: "stitch", meaning: "꿰매다, 이어붙이다" },
                { word: "steady", meaning: "안정적인, 꾸준한" },
                { word: "gentle", meaning: "부드러운" },
                { word: "boost", meaning: "끌어올리다" }
              ],
              sentences: [
                { sentence: "Please clarify the main point before moving to details." },
                { sentence: "She observed the speaker's tone and matched the intent." },
                { sentence: "A steady speaking pace boosts listening accuracy." },
                { sentence: "Gentle repetition can stitch fragmented clues together." }
              ]
            },
            {
              type: "blank",
              blankText: "체크\n- 끊어 듣기 단위 표시\n- 접속부사 들리면 바로 메모"
            }
          ]
        },
        {
          date: "2026-02-13 19:00",
          note: "해설 기반 오답 복원",
          mock: { year: "2017to2018", examKey: "october", typeLabel: "해설" },
          overlaySide: "right",
          openMemo: true,
          activeTabIndex: 0,
          tabs: [
            {
              type: "two_three",
              words: [
                { word: "pinpoint", meaning: "정확히 찾아내다" },
                { word: "distort", meaning: "왜곡하다" },
                { word: "anchor", meaning: "기준점, 고정하다" },
                { word: "derive", meaning: "이끌어내다" },
                { word: "resolve", meaning: "해결하다, 결심하다" }
              ],
              sentences: [
                { sentence: "Pinpoint the exact line that supports your option." },
                { sentence: "If one phrase distorts meaning, eliminate the choice." },
                { sentence: "Anchor every answer in a concrete textual clue." },
                { sentence: "Derive the tone before deciding author's attitude." },
                { sentence: "Resolve uncertainty by checking contrast markers twice." }
              ]
            },
            {
              type: "blank",
              blankText: "오답복원\n- 선지별 반박 근거 1개씩\n- 정답 근거는 문장 번호로 적기"
            }
          ]
        }
      ];
      let selectedSessionId = "";
      let selectedSessionTitle = "";
      let pdfRenderToken = 0;
      let lastPreviewScrollAt = 0;
      let activeWordIndex = null;
      let wordMeaningMap = new Map();
      let wordTooltipEl = null;
      let isDictModeOn = false;
      let lastCapturedWord = "";
      let dictZoom = 1;
      let isBlankPenMode = false;
      let isThreeTPenMode = false;
      const threePenState = {
        drawing: false,
        pointerId: null,
        card: null,
        canvas: null,
        lastPoint: null
      };
      const blankPenState = {
        drawing: false,
        pointerId: null,
        stroke: null,
        lastPoint: null
      };
      const DEBUG_SCROLL_DIAG = false;

      if (
        !pickerToggleBtn ||
        !memoToggleBtn ||
        !pickerPopup ||
        !pickerBackdrop ||
        !sessionPopup ||
        !sessionBackdrop ||
        !sessionList ||
        !overlayMemo ||
        !overlayCloseBtn ||
        !overlayFontOpenBtn ||
        !overlayFontPopup ||
        !overlayFontDecBtn ||
        !overlayFontIncBtn ||
        !overlayFontSizeValue ||
        !overlayBlankPane ||
        !overlayTwoThreePane ||
        !overlayTwoFlipTriangleBtn ||
        !overlayMemoText ||
        !blankPenToggleBtn ||
        !blankPenClearBtn ||
        !blankDrawWrap ||
        !blankDrawCanvas ||
        !overlayTwoLeftList ||
        !overlayTwoRightList ||
        !overlayThreeCol ||
        !overlayThreeHead ||
        !overlayThreeHeadLabel ||
        !overlayThreePenToggleBtn ||
        !overlayThreePenClearBtn ||
        !overlayDictToggleBtn ||
        !overlayDictPanel ||
        !overlayDictFrame ||
        !overlayDictCurrent ||
        !overlayDictZoomOutBtn ||
        !overlayDictZoomInBtn ||
        !overlayDictZoomValue ||
        !overlayDictOpenBtn ||
        !overlayTabList ||
        !overlayAddTabBtn ||
        !overlayTabTypePopup ||
        !overlayTypeOptionBtns.length ||
        !topbarStatus ||
        !openBtn ||
        !gradeSel ||
        !yearSel ||
        !examSel ||
        !typeSel ||
        !previewPages ||
        !previewFrame ||
        !previewEmpty ||
        !newTabBtn
      ) return;

      function showPanel(el) {
        el.hidden = false;
        el.style.display = "";
      }

      function hidePanel(el) {
        el.hidden = true;
        el.style.display = "none";
      }

      function setBtnActive(btn, active) {
        btn.classList.toggle("is-active", !!active);
      }

      function closePickerPopup() {
        pickerPopup.hidden = true;
        pickerBackdrop.hidden = true;
        setBtnActive(pickerToggleBtn, false);
      }

      function openPickerPopup() {
        closeSessionPopup();
        pickerPopup.hidden = false;
        pickerBackdrop.hidden = false;
        setBtnActive(pickerToggleBtn, true);
      }

      function togglePickerPopup() {
        if (pickerPopup.hidden) {
          openPickerPopup();
        } else {
          closePickerPopup();
        }
      }

      function closeSessionPopup() {
        sessionPopup.hidden = true;
        sessionBackdrop.hidden = true;
        setBtnActive(topbarStatus, false);
      }

      function openSessionPopup() {
        closePickerPopup();
        sessionPopup.hidden = false;
        sessionBackdrop.hidden = false;
        setBtnActive(topbarStatus, true);
      }

      function toggleSessionPopup() {
        if (sessionPopup.hidden) {
          openSessionPopup();
        } else {
          closeSessionPopup();
        }
      }

      function closeFontPopup() {
        overlayFontPopup.hidden = true;
      }

      function toggleFontPopup() {
        overlayFontPopup.hidden = !overlayFontPopup.hidden;
        if (!overlayFontPopup.hidden) {
          closeTabTypePopup();
        }
      }

      function closeTabTypePopup() {
        overlayTabTypePopup.hidden = true;
      }

      function toggleTabTypePopup() {
        overlayTabTypePopup.hidden = !overlayTabTypePopup.hidden;
        if (!overlayTabTypePopup.hidden) {
          closeFontPopup();
        }
      }

      function applyOverlaySide() {
        const isLeft = overlaySide === "left";
        overlayMemo.classList.toggle("is-left", isLeft);
        overlayTwoThreePane.classList.toggle("is-flipped", isLeft);
      }

      function flipOverlaySide() {
        overlaySide = overlaySide === "right" ? "left" : "right";
        applyOverlaySide();
      }

      function isMemoOpen() {
        return overlayMemo.classList.contains("is-open");
      }

      function makeDefaultTwoTCards() {
        return Array.from({ length: DEFAULT_TWO_T_CARD_COUNT }, function () {
          return {
            word: "",
            meaning: ""
          };
        });
      }

      function makeDefaultThreeTCards() {
        return Array.from({ length: DEFAULT_THREE_T_CARD_COUNT }, function () {
          return {
            sentence: "",
            ink: []
          };
        });
      }

      function ensureThreeSentenceInk(card) {
        if (!card || typeof card !== "object") return [];
        if (!Array.isArray(card.ink)) {
          card.ink = [];
        }

        const normalized = [];
        for (let i = 0; i < card.ink.length; i += 1) {
          const rawStroke = card.ink[i];
          if (!rawStroke || !Array.isArray(rawStroke.points)) continue;

          const safeStroke = (typeof rawStroke === "object") ? rawStroke : { points: [] };
          const safePoints = [];
          for (let j = 0; j < rawStroke.points.length; j += 1) {
            const pt = rawStroke.points[j];
            if (!pt) continue;
            const xNum = Number(pt.x);
            const yNum = Number(pt.y);
            if (!Number.isFinite(xNum) || !Number.isFinite(yNum)) continue;
            const pNum = Number(pt.p);
            const pressure = Number.isFinite(pNum)
              ? Math.max(0.05, Math.min(1, pNum))
              : 0.5;
            safePoints.push({
              x: Math.max(0, Math.min(1, xNum)),
              y: Math.max(0, Math.min(1, yNum)),
              p: pressure
            });
          }

          if (!safePoints.length) continue;
          safeStroke.points = safePoints;
          normalized.push(safeStroke);
        }

        card.ink = normalized;
        return normalized;
      }

      function ensureTwoThreeData(tab) {
        if (!tab) return null;
        if (!tab.twoThree) {
          tab.twoThree = {
            words: makeDefaultTwoTCards(),
            sentences: makeDefaultThreeTCards()
          };
        }

        if (Array.isArray(tab.twoThree.cards) && tab.twoThree.cards.length) {
          const legacyCards = tab.twoThree.cards;
          tab.twoThree.words = legacyCards.slice(0, DEFAULT_TWO_T_CARD_COUNT).map(function (row) {
            return {
              word: row && typeof row.word === "string" ? row.word : "",
              meaning: row && typeof row.meaning === "string" ? row.meaning : ""
            };
          });
          tab.twoThree.sentences = legacyCards.slice(0, DEFAULT_THREE_T_CARD_COUNT).map(function (row) {
            return {
              sentence: row && typeof row.sentence === "string" ? row.sentence : "",
              ink: Array.isArray(row && row.ink) ? row.ink : []
            };
          });
          delete tab.twoThree.cards;
        }

        if (!Array.isArray(tab.twoThree.words)) {
          tab.twoThree.words = makeDefaultTwoTCards();
        }
        if (!Array.isArray(tab.twoThree.sentences)) {
          tab.twoThree.sentences = makeDefaultThreeTCards();
        }
        while (tab.twoThree.words.length < DEFAULT_TWO_T_CARD_COUNT) {
          tab.twoThree.words.push({ word: "", meaning: "" });
        }
        while (tab.twoThree.sentences.length < DEFAULT_THREE_T_CARD_COUNT) {
          tab.twoThree.sentences.push({ sentence: "", ink: [] });
        }
        if (tab.twoThree.words.length > DEFAULT_TWO_T_CARD_COUNT) {
          tab.twoThree.words = tab.twoThree.words.slice(0, DEFAULT_TWO_T_CARD_COUNT);
        }
        if (tab.twoThree.sentences.length > DEFAULT_THREE_T_CARD_COUNT) {
          tab.twoThree.sentences = tab.twoThree.sentences.slice(0, DEFAULT_THREE_T_CARD_COUNT);
        }
        for (let i = 0; i < tab.twoThree.sentences.length; i += 1) {
          const sentenceCard = tab.twoThree.sentences[i];
          if (!sentenceCard || typeof sentenceCard !== "object") {
            tab.twoThree.sentences[i] = { sentence: "", ink: [] };
            continue;
          }
          if (typeof sentenceCard.sentence !== "string") {
            sentenceCard.sentence = "";
          }
          ensureThreeSentenceInk(sentenceCard);
        }
        return tab.twoThree;
      }

      function getActiveMemoTab() {
        return memoTabs[activeMemoTabIndex] || null;
      }

      function saveActiveMemoText() {
        const tab = getActiveMemoTab();
        if (!tab) return;
        if (tab.type === "blank") {
          tab.blankText = overlayMemoText.value;
        }
      }

      function applyMemoFontSize() {
        const px = `${memoFontSize}px`;
        overlayMemo.style.setProperty("--memo-font-size", px);
        overlayFontSizeValue.textContent = px;
      }

      function getActiveBlankTab() {
        const tab = getActiveMemoTab();
        return tab && tab.type === "blank" ? tab : null;
      }

      function ensureBlankInk(tab) {
        if (!tab) return [];
        if (!Array.isArray(tab.blankInk)) {
          tab.blankInk = [];
        }

        const normalized = [];
        for (let i = 0; i < tab.blankInk.length; i += 1) {
          const rawStroke = tab.blankInk[i];
          if (!rawStroke || !Array.isArray(rawStroke.points)) continue;

          const safeStroke = (typeof rawStroke === "object") ? rawStroke : { points: [] };
          const safePoints = [];
          for (let j = 0; j < rawStroke.points.length; j += 1) {
            const pt = rawStroke.points[j];
            if (!pt) continue;
            const xNum = Number(pt.x);
            const yNum = Number(pt.y);
            if (!Number.isFinite(xNum) || !Number.isFinite(yNum)) continue;
            const pNum = Number(pt.p);
            const pressure = Number.isFinite(pNum)
              ? Math.max(0.05, Math.min(1, pNum))
              : 0.5;
            safePoints.push({
              x: Math.max(0, Math.min(1, xNum)),
              y: Math.max(0, Math.min(1, yNum)),
              p: pressure
            });
          }

          if (!safePoints.length) continue;
          safeStroke.points = safePoints;
          normalized.push(safeStroke);
        }

        tab.blankInk = normalized;
        return normalized;
      }

      function getBlankPenPressure(event) {
        const pressure = Number(event.pressure);
        if (Number.isFinite(pressure) && pressure > 0) {
          return Math.max(0.05, Math.min(1, pressure));
        }
        if (event.pointerType === "pen") return 0.28;
        if (event.pointerType === "touch") return 0.45;
        return event.buttons ? 0.55 : 0.35;
      }

      function setupBlankCanvasContext() {
        const rect = blankDrawCanvas.getBoundingClientRect();
        if (!Number.isFinite(rect.width) || !Number.isFinite(rect.height) || rect.width < 8 || rect.height < 8) {
          return null;
        }
        const cssWidth = Math.max(1, Math.floor(rect.width));
        const cssHeight = Math.max(1, Math.floor(rect.height));
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const targetW = Math.floor(cssWidth * dpr);
        const targetH = Math.floor(cssHeight * dpr);
        if (blankDrawCanvas.width !== targetW || blankDrawCanvas.height !== targetH) {
          blankDrawCanvas.width = targetW;
          blankDrawCanvas.height = targetH;
        }

        const ctx = blankDrawCanvas.getContext("2d");
        if (!ctx) return null;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        return {
          ctx,
          width: cssWidth,
          height: cssHeight
        };
      }

      function bindBlankPenWindowListeners() {
        window.addEventListener("pointermove", handleBlankPenPointerMove, { passive: false });
        window.addEventListener("pointerup", handleBlankPenPointerEnd, { passive: false });
        window.addEventListener("pointercancel", handleBlankPenPointerEnd, { passive: false });
      }

      function unbindBlankPenWindowListeners() {
        window.removeEventListener("pointermove", handleBlankPenPointerMove);
        window.removeEventListener("pointerup", handleBlankPenPointerEnd);
        window.removeEventListener("pointercancel", handleBlankPenPointerEnd);
      }

      function drawInkDot(ctx, point, width, height, color, widthScale) {
        const px = point.x * width;
        const py = point.y * height;
        const scale = Math.max(0.45, Math.min(1.4, Number(widthScale) || 1));
        const penW = (0.9 + (3.8 - 0.9) * Math.max(0.05, Math.min(1, point.p || 0.5))) * scale;
        ctx.fillStyle = color || "#2f2a24";
        ctx.beginPath();
        ctx.arc(px, py, Math.max(0.55, penW * 0.5), 0, Math.PI * 2);
        ctx.fill();
      }

      function drawInkSegment(ctx, p1, p2, width, height, color, widthScale) {
        const x1 = p1.x * width;
        const y1 = p1.y * height;
        const x2 = p2.x * width;
        const y2 = p2.y * height;
        const pressure = ((p1.p || 0.5) + (p2.p || 0.5)) * 0.5;
        const scale = Math.max(0.45, Math.min(1.4, Number(widthScale) || 1));
        const penW = (0.9 + (3.8 - 0.9) * Math.max(0.05, Math.min(1, pressure))) * scale;

        ctx.strokeStyle = color || "#2f2a24";
        ctx.lineWidth = penW;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }

      function redrawBlankCanvas() {
        const tab = getActiveBlankTab();
        const setup = setupBlankCanvasContext();
        if (!setup) return;

        const ink = tab ? ensureBlankInk(tab) : [];
        const ctx = setup.ctx;
        const width = setup.width;
        const height = setup.height;
        ctx.clearRect(0, 0, width, height);

        for (let i = 0; i < ink.length; i += 1) {
          const points = ink[i].points;
          if (!points || !points.length) continue;
          if (points.length === 1) {
            drawInkDot(ctx, points[0], width, height);
            continue;
          }
          for (let j = 1; j < points.length; j += 1) {
            drawInkSegment(ctx, points[j - 1], points[j], width, height);
          }
        }
      }

      function updateBlankPenUi() {
        const tab = getActiveBlankTab();
        const isBlankTab = !!tab && !overlayBlankPane.hidden;

        blankPenToggleBtn.hidden = !isBlankTab;
        blankPenClearBtn.hidden = !isBlankTab;

        const penOn = isBlankTab && isBlankPenMode;
        overlayBlankPane.classList.toggle("is-pen-mode", penOn);
        blankDrawWrap.hidden = !penOn;
        blankPenToggleBtn.classList.toggle("is-on", penOn);
        blankPenToggleBtn.setAttribute("aria-pressed", penOn ? "true" : "false");
        blankPenToggleBtn.textContent = penOn ? "펜 ON" : "펜";

        const ink = tab ? ensureBlankInk(tab) : [];
        blankPenClearBtn.disabled = !isBlankTab || ink.length === 0;

        if (penOn) {
          overlayMemoText.blur();
          redrawBlankCanvas();
        }
      }

      function setBlankPenMode(forceOn) {
        const next = typeof forceOn === "boolean" ? forceOn : !isBlankPenMode;
        isBlankPenMode = !!next;
        if (!isBlankPenMode) {
          blankPenState.drawing = false;
          blankPenState.pointerId = null;
          blankPenState.stroke = null;
          blankPenState.lastPoint = null;
          unbindBlankPenWindowListeners();
        }
        updateBlankPenUi();
      }

      function clearActiveBlankInk() {
        const tab = getActiveBlankTab();
        if (!tab) return;
        tab.blankInk = [];
        redrawBlankCanvas();
        updateBlankPenUi();
      }

      function getBlankCanvasPoint(event) {
        const rect = blankDrawCanvas.getBoundingClientRect();
        const localX = Math.max(0, Math.min(rect.width, event.clientX - rect.left));
        const localY = Math.max(0, Math.min(rect.height, event.clientY - rect.top));
        const safeW = Math.max(1, rect.width);
        const safeH = Math.max(1, rect.height);
        return {
          x: localX / safeW,
          y: localY / safeH,
          p: getBlankPenPressure(event)
        };
      }

      function handleBlankPenPointerDown(event) {
        if (!isBlankPenMode) return;
        const tab = getActiveBlankTab();
        if (!tab) return;

        event.preventDefault();
        const ink = ensureBlankInk(tab);
        const point = getBlankCanvasPoint(event);
        const stroke = { points: [point] };
        ink.push(stroke);

        blankPenState.drawing = true;
        blankPenState.pointerId = event.pointerId;
        blankPenState.stroke = stroke;
        blankPenState.lastPoint = point;
        bindBlankPenWindowListeners();

        if (typeof blankDrawCanvas.setPointerCapture === "function") {
          try {
            blankDrawCanvas.setPointerCapture(event.pointerId);
          } catch (_err) {}
        }

        const setup = setupBlankCanvasContext();
        if (setup) {
          drawInkDot(setup.ctx, point, setup.width, setup.height);
        }
        updateBlankPenUi();
      }

      function handleBlankPenPointerMove(event) {
        if (!blankPenState.drawing || blankPenState.pointerId !== event.pointerId) return;
        if (!isBlankPenMode) return;

        event.preventDefault();
        const nextPoint = getBlankCanvasPoint(event);
        if (!blankPenState.stroke) return;
        blankPenState.stroke.points.push(nextPoint);

        const setup = setupBlankCanvasContext();
        if (setup && blankPenState.lastPoint) {
          drawInkSegment(setup.ctx, blankPenState.lastPoint, nextPoint, setup.width, setup.height);
        }
        blankPenState.lastPoint = nextPoint;
      }

      function handleBlankPenPointerEnd(event) {
        if (!blankPenState.drawing || blankPenState.pointerId !== event.pointerId) return;
        event.preventDefault();

        if (typeof blankDrawCanvas.releasePointerCapture === "function") {
          try {
            blankDrawCanvas.releasePointerCapture(event.pointerId);
          } catch (_err) {}
        }

        blankPenState.drawing = false;
        blankPenState.pointerId = null;
        blankPenState.stroke = null;
        blankPenState.lastPoint = null;
        unbindBlankPenWindowListeners();
        updateBlankPenUi();
      }

      function setupThreeInkCanvas(canvas) {
        if (!canvas) return null;
        const rect = canvas.getBoundingClientRect();
        if (!Number.isFinite(rect.width) || !Number.isFinite(rect.height) || rect.width < 8 || rect.height < 8) {
          return null;
        }
        const cssWidth = Math.max(1, Math.floor(rect.width));
        const cssHeight = Math.max(1, Math.floor(rect.height));
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const targetW = Math.floor(cssWidth * dpr);
        const targetH = Math.floor(cssHeight * dpr);
        if (canvas.width !== targetW || canvas.height !== targetH) {
          canvas.width = targetW;
          canvas.height = targetH;
        }

        const ctx = canvas.getContext("2d");
        if (!ctx) return null;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        return {
          ctx,
          width: cssWidth,
          height: cssHeight
        };
      }

      function redrawThreeInkCanvas(canvas, sentenceCard) {
        const setup = setupThreeInkCanvas(canvas);
        if (!setup) return;
        const strokes = ensureThreeSentenceInk(sentenceCard);
        const ctx = setup.ctx;
        const width = setup.width;
        const height = setup.height;
        ctx.clearRect(0, 0, width, height);

        for (let i = 0; i < strokes.length; i += 1) {
          const points = strokes[i].points;
          if (!points || !points.length) continue;
          if (points.length === 1) {
            drawInkDot(ctx, points[0], width, height, THREE_PEN_COLOR, THREE_PEN_WIDTH_SCALE);
            continue;
          }
          for (let j = 1; j < points.length; j += 1) {
            drawInkSegment(ctx, points[j - 1], points[j], width, height, THREE_PEN_COLOR, THREE_PEN_WIDTH_SCALE);
          }
        }
      }

      function getThreeCanvasPoint(canvas, event) {
        const rect = canvas.getBoundingClientRect();
        const localX = Math.max(0, Math.min(rect.width, event.clientX - rect.left));
        const localY = Math.max(0, Math.min(rect.height, event.clientY - rect.top));
        const safeW = Math.max(1, rect.width);
        const safeH = Math.max(1, rect.height);
        return {
          x: localX / safeW,
          y: localY / safeH,
          p: getBlankPenPressure(event)
        };
      }

      function stopThreePenDrawing() {
        if (threePenState.drawing && threePenState.canvas && typeof threePenState.canvas.releasePointerCapture === "function") {
          try {
            threePenState.canvas.releasePointerCapture(threePenState.pointerId);
          } catch (_err) {}
        }
        threePenState.drawing = false;
        threePenState.pointerId = null;
        threePenState.card = null;
        threePenState.canvas = null;
        threePenState.lastPoint = null;
      }

      function updateThreePenUi() {
        const tab = getActiveMemoTab();
        const isTwoThree = !!tab && tab.type === "two_three" && !overlayTwoThreePane.hidden;
        const allowPen = isTwoThree && !isDictModeOn;
        if (!allowPen && isThreeTPenMode) {
          isThreeTPenMode = false;
          stopThreePenDrawing();
        }

        overlayThreePenToggleBtn.hidden = !isTwoThree;
        overlayThreePenToggleBtn.disabled = !allowPen;
        overlayThreePenToggleBtn.classList.toggle("is-on", allowPen && isThreeTPenMode);
        overlayThreePenToggleBtn.setAttribute("aria-pressed", (allowPen && isThreeTPenMode) ? "true" : "false");
        overlayThreePenToggleBtn.textContent = allowPen && isThreeTPenMode ? "펜 ON" : "펜";

        overlayThreePenClearBtn.hidden = !isTwoThree;
        overlayThreePenClearBtn.disabled = !isTwoThree;

        overlayTwoThreePane.classList.toggle("is-three-pen-mode", allowPen && isThreeTPenMode);
      }

      function setThreePenMode(forceOn) {
        const tab = getActiveMemoTab();
        if (!tab || tab.type !== "two_three") return;
        if (isDictModeOn) return;
        const next = typeof forceOn === "boolean" ? forceOn : !isThreeTPenMode;
        isThreeTPenMode = !!next;
        if (!isThreeTPenMode) {
          stopThreePenDrawing();
        }
        renderTwoThreeCards();
      }

      function clearActiveThreeInk() {
        const tab = getActiveMemoTab();
        if (!tab || tab.type !== "two_three") return;
        const twoThree = ensureTwoThreeData(tab);
        if (!twoThree || !Array.isArray(twoThree.sentences)) return;

        let changed = false;
        for (let idx = 0; idx < twoThree.sentences.length; idx += 1) {
          const sentenceCard = twoThree.sentences[idx];
          const strokes = ensureThreeSentenceInk(sentenceCard);
          if (strokes.length > 0) {
            sentenceCard.ink = [];
            changed = true;
          }
        }

        if (!changed) return;
        stopThreePenDrawing();
        renderTwoThreeCards();
      }

      function clearThreeCardInk(sentenceCard, canvas) {
        if (!sentenceCard) return;
        const strokes = ensureThreeSentenceInk(sentenceCard);
        if (!strokes.length) return;
        if (threePenState.card === sentenceCard) {
          stopThreePenDrawing();
        }
        sentenceCard.ink = [];
        redrawThreeInkCanvas(canvas, sentenceCard);
      }

      function undoThreeCardInk(sentenceCard, canvas) {
        if (!sentenceCard) return;
        const strokes = ensureThreeSentenceInk(sentenceCard);
        if (!strokes.length) return;
        if (threePenState.card === sentenceCard) {
          stopThreePenDrawing();
        }
        strokes.pop();
        redrawThreeInkCanvas(canvas, sentenceCard);
      }

      function handleThreeInkPointerDown(event, sentenceCard, canvas) {
        if (!isThreeTPenMode || isDictModeOn) return;
        event.preventDefault();

        const strokes = ensureThreeSentenceInk(sentenceCard);
        const point = getThreeCanvasPoint(canvas, event);
        const stroke = { points: [point] };
        strokes.push(stroke);

        threePenState.drawing = true;
        threePenState.pointerId = event.pointerId;
        threePenState.card = sentenceCard;
        threePenState.canvas = canvas;
        threePenState.lastPoint = point;

        if (typeof canvas.setPointerCapture === "function") {
          try {
            canvas.setPointerCapture(event.pointerId);
          } catch (_err) {}
        }

        const setup = setupThreeInkCanvas(canvas);
        if (setup) {
          drawInkDot(setup.ctx, point, setup.width, setup.height, THREE_PEN_COLOR, THREE_PEN_WIDTH_SCALE);
        }
      }

      function handleThreeInkPointerMove(event, sentenceCard, canvas) {
        if (!threePenState.drawing || threePenState.pointerId !== event.pointerId) return;
        if (!isThreeTPenMode || isDictModeOn) return;
        if (threePenState.canvas !== canvas || threePenState.card !== sentenceCard) return;

        event.preventDefault();
        const nextPoint = getThreeCanvasPoint(canvas, event);
        const strokes = ensureThreeSentenceInk(sentenceCard);
        const activeStroke = strokes[strokes.length - 1];
        if (!activeStroke || !Array.isArray(activeStroke.points)) return;
        activeStroke.points.push(nextPoint);

        const setup = setupThreeInkCanvas(canvas);
        if (setup && threePenState.lastPoint) {
          drawInkSegment(setup.ctx, threePenState.lastPoint, nextPoint, setup.width, setup.height, THREE_PEN_COLOR, THREE_PEN_WIDTH_SCALE);
        }
        threePenState.lastPoint = nextPoint;
      }

      function handleThreeInkPointerEnd(event, sentenceCard, canvas) {
        if (!threePenState.drawing || threePenState.pointerId !== event.pointerId) return;
        if (threePenState.canvas !== canvas || threePenState.card !== sentenceCard) return;
        event.preventDefault();
        stopThreePenDrawing();
      }

      function buildNaverDictUrl(word) {
        const clean = normalizeCapturedWord(word);
        if (!clean) return "https://en.dict.naver.com/";
        return `${NAVER_EN_KO_SEARCH_BASE}${encodeURIComponent(clean)}`;
      }

      function clampDictZoom(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) return dictZoom;
        return Math.max(DICT_ZOOM_MIN, Math.min(DICT_ZOOM_MAX, numeric));
      }

      function applyDictZoom() {
        overlayDictZoomValue.textContent = `${Math.round(dictZoom * 100)}%`;
        overlayDictFrame.style.zoom = String(dictZoom);
      }

      function adjustDictZoom(direction) {
        const delta = direction > 0 ? DICT_ZOOM_STEP : -DICT_ZOOM_STEP;
        const next = clampDictZoom(dictZoom + delta);
        if (Math.abs(next - dictZoom) < 0.001) return;
        dictZoom = next;
        applyDictZoom();
      }

      function refreshDictPanel() {
        const tab = getActiveMemoTab();
        const isTwoThree = !!tab && tab.type === "two_three" && !overlayTwoThreePane.hidden;
        const shouldShowDict = isTwoThree && isDictModeOn;

        overlayDictToggleBtn.classList.toggle("is-on", shouldShowDict);
        overlayDictToggleBtn.setAttribute("aria-pressed", shouldShowDict ? "true" : "false");
        overlayDictToggleBtn.textContent = shouldShowDict ? "🔎 검색중" : "🔎 검색";
        overlayDictToggleBtn.title = shouldShowDict ? "검색창 끄기" : "검색창 켜기";

        overlayTwoRightList.hidden = shouldShowDict;
        overlayDictPanel.hidden = !shouldShowDict;
        overlayThreeCol.classList.toggle("is-dict-mode", shouldShowDict);
        overlayThreeHead.classList.toggle("is-dict-mode", shouldShowDict);
        overlayThreeHeadLabel.textContent = shouldShowDict ? "단어 검색창" : "3T · 문장/분석";
        updateThreePenUi();

        if (!shouldShowDict) return;

        let clean = normalizeCapturedWord(lastCapturedWord);
        if (!clean && tab && tab.type === "two_three") {
          const twoThree = ensureTwoThreeData(tab);
          if (twoThree && Array.isArray(twoThree.words)) {
            for (let i = 0; i < twoThree.words.length; i += 1) {
              const fromCard = normalizeCapturedWord(twoThree.words[i] && twoThree.words[i].word);
              if (fromCard) {
                clean = fromCard;
                lastCapturedWord = fromCard;
                break;
              }
            }
          }
        }

        const targetUrl = buildNaverDictUrl(clean);
        if (overlayDictFrame.dataset.loadedUrl !== targetUrl) {
          overlayDictFrame.src = targetUrl;
          overlayDictFrame.dataset.loadedUrl = targetUrl;
        }
        overlayDictCurrent.textContent = clean ? `검색어: ${clean}` : "단어를 클릭하면 검색됩니다.";
        overlayDictOpenBtn.disabled = !clean;
        overlayDictOpenBtn.dataset.url = targetUrl;
        applyDictZoom();
      }

      function toggleDictPanel(forceOn) {
        const next = typeof forceOn === "boolean" ? forceOn : !isDictModeOn;
        isDictModeOn = !!next;
        refreshDictPanel();
      }

      function pushWordToDictSearch(word) {
        const clean = normalizeCapturedWord(word);
        if (!clean) return;
        lastCapturedWord = clean;
        if (!isDictModeOn) return;
        refreshDictPanel();
      }

      function findNextTwoTWordSlot(words) {
        for (let i = 0; i < words.length; i += 1) {
          const row = words[i] || {};
          if (!normalizeCapturedWord(row.word || "")) {
            return i;
          }
        }
        return -1;
      }

      function applyCapturedWordToTwoTView(slotIndex, word) {
        if (overlayTwoThreePane.hidden) return;

        const inputEl = overlayTwoLeftList.querySelector(`.overlay-card-input--twoT[data-two-t-slot="${slotIndex}"]`);
        if (inputEl) {
          inputEl.value = word;
        }

        const cardEl = overlayTwoLeftList.querySelector(`.overlay-card--twoT[data-two-t-card="${slotIndex}"]`);
        if (cardEl) {
          cardEl.classList.remove("is-captured");
          requestAnimationFrame(function () {
            cardEl.classList.add("is-captured");
            cardEl.scrollIntoView({ block: "nearest", behavior: "smooth" });
            window.setTimeout(function () {
              cardEl.classList.remove("is-captured");
            }, 460);
          });
        }
      }

      function buildTwoTCard(card, idx) {
        const outer = document.createElement("div");
        outer.className = "overlay-card overlay-card--twoT";
        outer.dataset.twoTCard = String(idx);
        const inner = document.createElement("div");
        inner.className = "overlay-card-inner overlay-card-inner--twoT";

        const row = document.createElement("div");
        row.className = "overlay-card-row overlay-card-row--twoT";

        const idxEl = document.createElement("span");
        idxEl.className = "overlay-card-index overlay-card-index--twoT";
        idxEl.textContent = String(idx + 1);

        const wordInput = document.createElement("input");
        wordInput.type = "text";
        wordInput.className = "overlay-card-input overlay-card-input--twoT";
        wordInput.dataset.twoTSlot = String(idx);
        wordInput.placeholder = "단어";
        wordInput.value = card.word || "";
        wordInput.addEventListener("input", function () {
          card.word = wordInput.value;
          rebuildWordMeaningMap();
        });

        row.appendChild(idxEl);
        row.appendChild(wordInput);

        const meaningArea = document.createElement("textarea");
        meaningArea.className = "overlay-card-textarea overlay-card-textarea--twoT";
        meaningArea.placeholder = "뜻/메모";
        meaningArea.value = card.meaning || "";
        meaningArea.addEventListener("input", function () {
          card.meaning = meaningArea.value;
          rebuildWordMeaningMap();
        });

        inner.appendChild(row);
        inner.appendChild(meaningArea);
        outer.appendChild(inner);
        return outer;
      }

      function buildThreeTCard(card, idx) {
        const outer = document.createElement("div");
        outer.className = "overlay-card overlay-card--threeT";
        const inner = document.createElement("div");
        inner.className = "overlay-card-inner overlay-card-inner--threeT";

        const row = document.createElement("div");
        row.className = "overlay-card-row overlay-card-row--threeT";

        const idxEl = document.createElement("span");
        idxEl.className = "overlay-card-index overlay-card-index--threeT";
        idxEl.textContent = String(idx + 1).padStart(2, "0");

        const tools = document.createElement("div");
        tools.className = "overlay-three-card-tools";

        const undoBtn = document.createElement("button");
        undoBtn.className = "overlay-three-card-tool-btn";
        undoBtn.type = "button";
        undoBtn.textContent = "Undo";

        const clearBtn = document.createElement("button");
        clearBtn.className = "overlay-three-card-tool-btn";
        clearBtn.type = "button";
        clearBtn.textContent = "지우기";

        const sentenceInput = document.createElement("textarea");
        sentenceInput.className = "overlay-card-textarea overlay-card-textarea--threeT overlay-card-textarea--threeT-sentence";
        sentenceInput.placeholder = "문장";
        sentenceInput.value = card.sentence || "";
        sentenceInput.readOnly = isThreeTPenMode;
        sentenceInput.addEventListener("input", function () {
          card.sentence = sentenceInput.value;
        });

        row.appendChild(idxEl);
        tools.appendChild(undoBtn);
        tools.appendChild(clearBtn);
        row.appendChild(tools);

        inner.appendChild(row);
        inner.appendChild(sentenceInput);

        const inkWrap = document.createElement("div");
        inkWrap.className = "overlay-three-ink-wrap";
        const inkCanvas = document.createElement("canvas");
        inkCanvas.className = "overlay-three-ink-canvas";
        inkCanvas.addEventListener("pointerdown", function (event) {
          handleThreeInkPointerDown(event, card, inkCanvas);
        });
        inkCanvas.addEventListener("pointermove", function (event) {
          handleThreeInkPointerMove(event, card, inkCanvas);
        });
        inkCanvas.addEventListener("pointerup", function (event) {
          handleThreeInkPointerEnd(event, card, inkCanvas);
        });
        inkCanvas.addEventListener("pointercancel", function (event) {
          handleThreeInkPointerEnd(event, card, inkCanvas);
        });
        undoBtn.addEventListener("click", function () {
          undoThreeCardInk(card, inkCanvas);
        });
        clearBtn.addEventListener("click", function () {
          clearThreeCardInk(card, inkCanvas);
        });
        inkWrap.appendChild(inkCanvas);
        inner.appendChild(inkWrap);
        outer.appendChild(inner);

        requestAnimationFrame(function () {
          redrawThreeInkCanvas(inkCanvas, card);
        });
        return outer;
      }

      function renderTwoThreeCards() {
        const tab = getActiveMemoTab();
        if (!tab || tab.type !== "two_three") return;
        const twoThree = ensureTwoThreeData(tab);
        if (!twoThree) return;

        overlayTwoThreePane.classList.toggle("is-flipped", overlaySide === "left");
        updateThreePenUi();
        overlayTwoLeftList.innerHTML = "";
        overlayTwoRightList.innerHTML = "";

        for (let idx = 0; idx < twoThree.words.length; idx += 1) {
          const wordCard = twoThree.words[idx];
          overlayTwoLeftList.appendChild(buildTwoTCard(wordCard, idx));
        }
        for (let idx = 0; idx < twoThree.sentences.length; idx += 1) {
          const sentCard = twoThree.sentences[idx];
          overlayTwoRightList.appendChild(buildThreeTCard(sentCard, idx));
        }
        refreshDictPanel();
      }

      function renderActiveMemoPane() {
        const tab = getActiveMemoTab();
        const isTwoThree = !!tab && tab.type === "two_three";
        rebuildWordMeaningMap();
        overlayBlankPane.hidden = isTwoThree;
        overlayTwoThreePane.hidden = !isTwoThree;

        if (!tab) {
          updateBlankPenUi();
          return;
        }
        if (isTwoThree) {
          ensureTwoThreeData(tab);
          renderTwoThreeCards();
        } else {
          overlayMemoText.value = tab.blankText || "";
          refreshDictPanel();
        }
        updateThreePenUi();
        updateBlankPenUi();
      }

      function renderMemoTabbar() {
        overlayTabList.innerHTML = "";
        for (let idx = 0; idx < memoTabs.length; idx += 1) {
          const item = memoTabs[idx];
          const wrapper = document.createElement("div");
          wrapper.className = "overlay-tab-item";

          const tabBtn = document.createElement("button");
          tabBtn.type = "button";
          tabBtn.className = `overlay-tab-btn ${idx === activeMemoTabIndex ? "is-active" : "is-inactive"}`;
          tabBtn.textContent = String(item.id);
          tabBtn.title = TAB_TYPE_LABEL[item.type] || item.type;
          tabBtn.addEventListener("click", function () {
            switchMemoTab(idx);
          });

          const closeBtn = document.createElement("button");
          closeBtn.type = "button";
          closeBtn.className = "overlay-tab-close";
          closeBtn.textContent = "✕";
          closeBtn.title = "탭 닫기";
          closeBtn.addEventListener("click", function () {
            closeMemoTab(idx);
          });

          wrapper.appendChild(tabBtn);
          wrapper.appendChild(closeBtn);
          overlayTabList.appendChild(wrapper);
        }
      }

      function switchMemoTab(index) {
        if (index < 0 || index >= memoTabs.length) return;
        stopThreePenDrawing();
        saveActiveMemoText();
        activeMemoTabIndex = index;
        renderActiveMemoPane();
        renderMemoTabbar();
      }

      function addMemoTab(tabType) {
        stopThreePenDrawing();
        saveActiveMemoText();
        const type = tabType === "two_three" ? "two_three" : "blank";
        memoTabs.push({
          id: nextMemoTabId,
          type,
          blankText: "",
          blankInk: [],
          twoThree: type === "two_three" ? {
            words: makeDefaultTwoTCards(),
            sentences: makeDefaultThreeTCards()
          } : null
        });
        nextMemoTabId += 1;
        activeMemoTabIndex = memoTabs.length - 1;
        renderActiveMemoPane();
        renderMemoTabbar();
        closeTabTypePopup();
      }

      function closeMemoTab(index) {
        if (index < 0 || index >= memoTabs.length) return;
        stopThreePenDrawing();
        saveActiveMemoText();
        if (memoTabs.length === 1) {
          memoTabs[0].blankText = "";
          memoTabs[0].blankInk = [];
          memoTabs[0].twoThree = null;
          renderActiveMemoPane();
          return;
        }
        memoTabs.splice(index, 1);
        if (activeMemoTabIndex >= memoTabs.length) {
          activeMemoTabIndex = memoTabs.length - 1;
        } else if (index < activeMemoTabIndex) {
          activeMemoTabIndex -= 1;
        }
        renderActiveMemoPane();
        renderMemoTabbar();
      }

      function toggleMemoOverlay(forceVisible) {
        const shouldShow = typeof forceVisible === "boolean" ? forceVisible : !isMemoOpen();
        if (shouldShow && !pickerPopup.hidden) {
          closePickerPopup();
        }
        if (shouldShow && !sessionPopup.hidden) {
          closeSessionPopup();
        }
        overlayMemo.classList.toggle("is-open", shouldShow);
        overlayMemo.setAttribute("aria-hidden", shouldShow ? "false" : "true");
        setBtnActive(memoToggleBtn, shouldShow);
        if (!shouldShow) {
          stopThreePenDrawing();
          blankPenState.drawing = false;
          blankPenState.pointerId = null;
          blankPenState.stroke = null;
          blankPenState.lastPoint = null;
          unbindBlankPenWindowListeners();
          closeFontPopup();
          closeTabTypePopup();
        }
      }

      function trace(level, message, meta) {
        const fn = (console && typeof console[level] === "function") ? console[level] : console.log;
        if (meta !== undefined) {
          fn(`[mock-exam-tool] ${message}`, meta);
        } else {
          fn(`[mock-exam-tool] ${message}`);
        }
      }

      function describeNodeForDiag(node) {
        if (!(node instanceof Element)) return String(node);
        const id = node.id ? `#${node.id}` : "";
        let cls = "";
        if (node.classList && node.classList.length) {
          cls = "." + Array.from(node.classList).slice(0, 3).join(".");
        }
        return `${node.tagName.toLowerCase()}${id}${cls}`;
      }

      function getScrollHostMetrics(host) {
        if (!host) return null;
        const cs = window.getComputedStyle(host);
        return {
          node: describeNodeForDiag(host),
          clientH: host.clientHeight,
          scrollH: host.scrollHeight,
          scrollTop: host.scrollTop,
          canScrollY: host.scrollHeight > host.clientHeight + 1,
          overflowY: cs.overflowY,
          touchAction: cs.touchAction,
          pointerEvents: cs.pointerEvents
        };
      }

      function lockPreviewViewportHeight(reason) {
        const previewBox = previewPages.parentElement;
        if (!previewBox) return;

        const workspace = document.getElementById("mock-workspace");
        let target = 0;
        if (workspace) {
          const wsRect = workspace.getBoundingClientRect();
          const topPad = 8;
          const bottomPad = 12;
          target = wsRect.height - topPad - bottomPad;
        }
        if (!Number.isFinite(target) || target <= 0) {
          target = window.innerHeight - 220;
        }
        target = Math.max(260, Math.min(760, Math.floor(target)));

        previewBox.style.height = `${target}px`;
        previewBox.style.maxHeight = `${target}px`;
        previewPages.style.height = "100%";
        previewPages.style.maxHeight = "100%";
        previewPages.style.minHeight = "0";

        if (DEBUG_SCROLL_DIAG) {
          trace("info", `diag/layout-${reason}`, {
            target,
            previewBox: getScrollHostMetrics(previewBox),
            host: getScrollHostMetrics(previewPages)
          });
        }
      }

      function attachPreviewScrollDiagnostics(host) {
        if (!DEBUG_SCROLL_DIAG || !host) return;
        let lastEmitAt = 0;
        const emit = function (stage, payload) {
          const now = Date.now();
          if (stage === "scroll" && now - lastEmitAt < 120) return;
          lastEmitAt = now;
          trace("info", `diag/${stage}`, payload);
        };

        emit("init", getScrollHostMetrics(host));

        host.addEventListener("scroll", function () {
          emit("scroll", {
            top: host.scrollTop,
            left: host.scrollLeft,
            maxY: Math.max(0, host.scrollHeight - host.clientHeight)
          });
        }, { passive: true });

        host.addEventListener("wheel", function (event) {
          const before = host.scrollTop;
          const target = describeNodeForDiag(event.target);
          requestAnimationFrame(function () {
            const topEl = document.elementFromPoint(event.clientX, event.clientY);
            emit("wheel", {
              deltaY: event.deltaY,
              before,
              after: host.scrollTop,
              target,
              topElement: describeNodeForDiag(topEl),
              defaultPrevented: event.defaultPrevented
            });
          });
        }, { passive: true });

        host.addEventListener("touchstart", function (event) {
          const t = event.touches && event.touches[0];
          emit("touchstart", {
            target: describeNodeForDiag(event.target),
            x: t ? t.clientX : null,
            y: t ? t.clientY : null
          });
        }, { passive: true });

        host.addEventListener("touchmove", function (event) {
          const before = host.scrollTop;
          const t = event.touches && event.touches[0];
          const x = t ? t.clientX : 0;
          const y = t ? t.clientY : 0;
          requestAnimationFrame(function () {
            const topEl = document.elementFromPoint(x, y);
            emit("touchmove", {
              before,
              after: host.scrollTop,
              target: describeNodeForDiag(event.target),
              topElement: describeNodeForDiag(topEl),
              defaultPrevented: event.defaultPrevented
            });
          });
        }, { passive: true });

        host.addEventListener("pointerdown", function (event) {
          emit("pointerdown", {
            target: describeNodeForDiag(event.target),
            pointerType: event.pointerType,
            x: event.clientX,
            y: event.clientY
          });
        }, { passive: true });
      }

      function clearBlobUrl() {
        if (!lastBlobUrl) return;
        try {
          URL.revokeObjectURL(lastBlobUrl);
        } catch (_err) {}
        lastBlobUrl = "";
      }

      function getSupabaseKey() {
        const fromWindow = window.SUPABASE_ANON_KEY || window.__SUPABASE_ANON_KEY__;
        if (fromWindow) return String(fromWindow).trim();

        const fromLocal = localStorage.getItem("SUPABASE_ANON_KEY");
        if (fromLocal) return String(fromLocal).trim();

        const fromQuery = new URLSearchParams(window.location.search).get("sbkey");
        if (fromQuery) return String(fromQuery).trim();

        return "";
      }

      function resetPdfPreviewToEmpty(message) {
        pdfRenderToken += 1;
        hideWordTooltip();
        clearBlobUrl();
        if (message) {
          previewEmpty.textContent = message;
        }
        previewPages.innerHTML = "";
        hidePanel(previewPages);
        hidePanel(previewFrame);
        previewFrame.removeAttribute("src");
        showPanel(previewEmpty);
        newTabBtn.hidden = true;
      }

      function showPdfWithIframeBlob(blob) {
        hideWordTooltip();
        clearBlobUrl();
        lastBlobUrl = URL.createObjectURL(blob);
        previewFrame.src = `${lastBlobUrl}#toolbar=0&navpanes=0&statusbar=0&messages=0&view=FitH`;
        showPanel(previewFrame);
        hidePanel(previewPages);
        hidePanel(previewEmpty);
        lockPreviewViewportHeight("iframe");
      }

      function normalizeCapturedWord(raw) {
        const text = String(raw || "").trim();
        if (!text) return "";
        const cleaned = text
          .replace(/[’`]/g, "'")
          .replace(/^[^\p{L}\p{N}]+|[^\p{L}\p{N}]+$/gu, "");
        if (!cleaned || /\s/.test(cleaned) || cleaned.length > 64) return "";
        return cleaned;
      }

      function normalizeMeaningMapKey(raw) {
        const clean = normalizeCapturedWord(raw);
        return clean ? clean.toLowerCase() : "";
      }

      function rebuildWordMeaningMap() {
        const map = new Map();
        for (let i = 0; i < memoTabs.length; i += 1) {
          const tab = memoTabs[i];
          if (!tab || tab.type !== "two_three") continue;
          const twoThree = tab.twoThree && typeof tab.twoThree === "object" ? tab.twoThree : null;
          const words = twoThree && Array.isArray(twoThree.words) ? twoThree.words : [];
          for (let j = 0; j < words.length; j += 1) {
            const row = words[j] || {};
            const key = normalizeMeaningMapKey(row.word);
            const meaning = String(row.meaning || "").trim();
            if (!key || !meaning) continue;
            map.set(key, meaning);
          }
        }
        wordMeaningMap = map;
      }

      function findMeaningForWord(word) {
        const key = normalizeMeaningMapKey(word);
        if (!key) return "";
        return wordMeaningMap.get(key) || "";
      }

      function ensureWordTooltip() {
        if (wordTooltipEl) return wordTooltipEl;
        const el = document.createElement("div");
        el.className = "pdf-word-tooltip";
        el.setAttribute("aria-hidden", "true");
        document.body.appendChild(el);
        wordTooltipEl = el;
        return wordTooltipEl;
      }

      function hideWordTooltip() {
        if (!wordTooltipEl) return;
        wordTooltipEl.classList.remove("is-visible");
        wordTooltipEl.setAttribute("aria-hidden", "true");
      }

      function showWordTooltip(text, clientX, clientY) {
        const content = String(text || "").trim();
        if (!content) {
          hideWordTooltip();
          return;
        }

        const el = ensureWordTooltip();
        el.textContent = content;
        el.classList.add("is-visible");
        el.setAttribute("aria-hidden", "false");

        const pad = 10;
        const offset = 14;
        let left = clientX + offset;
        let top = clientY + offset;

        const rect = el.getBoundingClientRect();
        if (left + rect.width + pad > window.innerWidth) {
          left = Math.max(pad, clientX - rect.width - offset);
        }
        if (top + rect.height + pad > window.innerHeight) {
          top = Math.max(pad, clientY - rect.height - offset);
        }

        el.style.left = `${Math.round(left)}px`;
        el.style.top = `${Math.round(top)}px`;
      }

      function findWordByApproxOffset(text, approxOffset) {
        const src = String(text || "");
        if (!src) return "";
        const regex = /[A-Za-z][A-Za-z0-9'-]*/g;
        let bestWord = "";
        let bestDistance = Number.POSITIVE_INFINITY;
        let match = regex.exec(src);
        while (match) {
          const start = match.index;
          const end = start + match[0].length;
          const mid = (start + end) / 2;
          const dist = Math.abs(mid - approxOffset);
          const candidate = normalizeCapturedWord(match[0]);
          if (candidate && dist < bestDistance) {
            bestDistance = dist;
            bestWord = candidate;
          }
          match = regex.exec(src);
        }
        return bestWord;
      }

      function extractWordAtOffset(text, offset) {
        const src = String(text || "");
        if (!src) return "";
        const isWordChar = function (ch) {
          return /[A-Za-z0-9'-]/.test(ch);
        };
        let start = Math.max(0, Math.min(offset, src.length));
        let end = start;
        while (start > 0 && isWordChar(src[start - 1])) {
          start -= 1;
        }
        while (end < src.length && isWordChar(src[end])) {
          end += 1;
        }
        return normalizeCapturedWord(src.slice(start, end));
      }

      function buildWordHitsFromSpan(rawText, rect, layerRect) {
        const src = String(rawText || "");
        if (!src || !rect || !layerRect || rect.width <= 0 || rect.height <= 0) return [];

        const words = [];
        const totalChars = Math.max(1, src.length);
        const regex = /[A-Za-z][A-Za-z0-9'-]*/g;
        let match = regex.exec(src);
        while (match) {
          const word = normalizeCapturedWord(match[0]);
          if (word) {
            const start = match.index;
            const end = start + match[0].length;
            words.push({
              word,
              x1: (rect.left - layerRect.left) + (rect.width * (start / totalChars)),
              x2: (rect.left - layerRect.left) + (rect.width * (end / totalChars)),
              y1: rect.top - layerRect.top,
              y2: rect.bottom - layerRect.top
            });
          }
          match = regex.exec(src);
        }
        return words;
      }

      function findWordHitAtPoint(hits, x, y) {
        if (!Array.isArray(hits) || !hits.length) return "";
        for (let idx = 0; idx < hits.length; idx += 1) {
          const hit = hits[idx];
          if (x >= hit.x1 && x <= hit.x2 && y >= hit.y1 && y <= hit.y2) {
            return hit.word || "";
          }
        }
        return "";
      }

      function buildWordHitsFromIndexRows(rows, scaleX, scaleY, pageHeightPx) {
        if (!Array.isArray(rows) || !rows.length) return [];
        const hits = [];

        for (let i = 0; i < rows.length; i += 1) {
          const row = rows[i];
          if (!row || !Array.isArray(row.bbox) || row.bbox.length !== 4) continue;
          const text = normalizeCapturedWord(row.text || "");
          if (!text) continue;

          const x0 = Number(row.bbox[0]) * scaleX;
          const y0 = Number(row.bbox[1]) * scaleY;
          const x1 = Number(row.bbox[2]) * scaleX;
          const y1 = Number(row.bbox[3]) * scaleY;
          if (!Number.isFinite(x0) || !Number.isFinite(y0) || !Number.isFinite(x1) || !Number.isFinite(y1)) continue;

          const lx = Math.min(x0, x1);
          const rx = Math.max(x0, x1);
          const ty = Math.min(y0, y1);
          const by = Math.max(y0, y1);
          hits.push({ word: text, x1: lx, y1: ty, x2: rx, y2: by });
        }
        return hits;
      }

      function extractWordFromTextSpan(span, event) {
        if (!span) return "";
        const raw = String(span.textContent || "");
        if (!raw.trim()) return "";

        let offset = -1;
        if (document.caretPositionFromPoint) {
          const pos = document.caretPositionFromPoint(event.clientX, event.clientY);
          if (pos && span.contains(pos.offsetNode)) {
            offset = Number(pos.offset) || 0;
          }
        } else if (document.caretRangeFromPoint) {
          const range = document.caretRangeFromPoint(event.clientX, event.clientY);
          if (range && span.contains(range.startContainer)) {
            offset = Number(range.startOffset) || 0;
          }
        }

        if (offset >= 0) {
          const atOffset = extractWordAtOffset(raw, offset);
          if (atOffset) return atOffset;
        }

        if (offset < 0) {
          const rect = span.getBoundingClientRect();
          if (rect.width > 0) {
            const ratio = Math.max(0, Math.min(1, (event.clientX - rect.left) / rect.width));
            offset = Math.round(ratio * raw.length);
          }
        }

        const byApprox = findWordByApproxOffset(raw, Math.max(0, offset));
        if (byApprox) return byApprox;

        const firstMatch = raw.match(/[A-Za-z][A-Za-z0-9'-]*/);
        return normalizeCapturedWord(firstMatch ? firstMatch[0] : "");
      }

      function appendWordToActiveMemo(word) {
        const cleanWord = normalizeCapturedWord(word);
        if (!cleanWord) return false;

        lastCapturedWord = cleanWord;
        pushWordToDictSearch(cleanWord);

        const tab = getActiveMemoTab();
        if (!tab) return false;

        if (tab.type === "blank") {
          const current = typeof tab.blankText === "string" ? tab.blankText : "";
          const next = current.trimEnd().length ? `${current.trimEnd()}\n${cleanWord}` : cleanWord;
          tab.blankText = next;
          overlayMemoText.value = next;
          overlayMemoText.scrollTop = overlayMemoText.scrollHeight;
          return true;
        }

        if (tab.type === "two_three") {
          const twoThree = ensureTwoThreeData(tab);
          if (!twoThree || !Array.isArray(twoThree.words) || !twoThree.words.length) return false;

          const nextSlot = findNextTwoTWordSlot(twoThree.words);
          if (nextSlot < 0) {
            trace("warn", "2T 슬롯이 가득 차서 단어를 추가하지 못했습니다.");
            return false;
          }

          twoThree.words[nextSlot].word = cleanWord;
          rebuildWordMeaningMap();
          applyCapturedWordToTwoTView(nextSlot, cleanWord);
          return true;
        }

        return false;
      }

      async function renderPdfPagesWithTextLayer(blob) {
        if (!window.pdfjsLib) {
          throw new Error("pdf.js is not loaded");
        }
        pdfjsLib.GlobalWorkerOptions.workerSrc = PDFJS_WORKER_SRC;
        hideWordTooltip();

        const myToken = ++pdfRenderToken;
        const bytes = await blob.arrayBuffer();
        const loadingTask = pdfjsLib.getDocument({ data: bytes });
        const pdfDoc = await loadingTask.promise;

        previewPages.innerHTML = "";
        previewPages.style.minHeight = "0";
        previewPages.style.height = "100%";
        hidePanel(previewFrame);
        previewFrame.removeAttribute("src");
        showPanel(previewPages);
        hidePanel(previewEmpty);
        lockPreviewViewportHeight("before-render");

        for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum += 1) {
          if (myToken !== pdfRenderToken) return;
          const page = await pdfDoc.getPage(pageNum);
          const baseViewport = page.getViewport({ scale: 1 });
          const hostWidth = (previewPages.parentElement && previewPages.parentElement.clientWidth) || previewPages.clientWidth;
          const usableWidth = Math.max(320, hostWidth - 24);
          const scale = Math.max(1, Math.min(2.7, usableWidth / baseViewport.width));
          const viewport = page.getViewport({ scale });
          const deviceScale = Math.max(1, window.devicePixelRatio || 1);
          const outputScale = Math.min(4, Math.max(1, deviceScale * RENDER_QUALITY_BOOST));

          const pageWrap = document.createElement("div");
          pageWrap.className = "pdf-page";
          pageWrap.style.width = `${viewport.width}px`;
          pageWrap.style.height = `${viewport.height}px`;

          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d", { alpha: false });
          canvas.width = Math.floor(viewport.width * outputScale);
          canvas.height = Math.floor(viewport.height * outputScale);
          canvas.style.width = `${viewport.width}px`;
          canvas.style.height = `${viewport.height}px`;

          pageWrap.appendChild(canvas);
          previewPages.appendChild(pageWrap);

          const renderContext = {
            canvasContext: ctx,
            viewport
          };
          if (outputScale !== 1) {
            renderContext.transform = [outputScale, 0, 0, outputScale, 0, 0];
          }
          await page.render(renderContext).promise;

          const indexPages = activeWordIndex && activeWordIndex.pages && typeof activeWordIndex.pages === "object"
            ? activeWordIndex.pages
            : null;
          const indexRows = indexPages
            ? (indexPages[String(pageNum)] || indexPages[pageNum] || [])
            : [];
          const scaleX = viewport.width / baseViewport.width;
          const scaleY = viewport.height / baseViewport.height;
          const wordHits = buildWordHitsFromIndexRows(indexRows, scaleX, scaleY, viewport.height);
          canvas.style.cursor = wordHits.length ? "pointer" : "default";

          if (wordHits.length) {
            canvas.addEventListener("mousemove", function (event) {
              const rect = canvas.getBoundingClientRect();
              const px = event.clientX - rect.left;
              const py = event.clientY - rect.top;
              const found = findWordHitAtPoint(wordHits, px, py);
              if (!found) {
                canvas.style.cursor = "default";
                hideWordTooltip();
                return;
              }

              const meaning = findMeaningForWord(found);
              canvas.style.cursor = meaning ? "help" : "pointer";
              if (meaning) {
                showWordTooltip(meaning, event.clientX, event.clientY);
              } else {
                hideWordTooltip();
              }
            }, { passive: true });
            canvas.addEventListener("mouseleave", function () {
              canvas.style.cursor = "default";
              hideWordTooltip();
            }, { passive: true });
          }

          canvas.addEventListener("wheel", function (event) {
            const host = previewPages;
            if (!host) return;
            const before = host.scrollTop;
            host.scrollTop += event.deltaY;
            host.scrollLeft += event.deltaX;
            if (DEBUG_SCROLL_DIAG) {
              trace("info", "diag/canvas-wheel", {
                deltaY: event.deltaY,
                before,
                after: host.scrollTop,
                changed: host.scrollTop !== before
              });
            }
            hideWordTooltip();
            event.preventDefault();
          }, { passive: false });

          canvas.addEventListener("click", function (event) {
            if (Date.now() - lastPreviewScrollAt < 140) return;
            if (!wordHits.length) return;

            const canvasRect = canvas.getBoundingClientRect();
            const px = event.clientX - canvasRect.left;
            const py = event.clientY - canvasRect.top;
            const word = findWordHitAtPoint(wordHits, px, py);
            if (!word) return;
            const added = appendWordToActiveMemo(word);
            if (added) {
              trace("info", `memo append word: ${word}`);
            }
            hideWordTooltip();
          });
        }
        if (DEBUG_SCROLL_DIAG) {
          trace("info", "diag/render-done", {
            host: getScrollHostMetrics(previewPages),
            pagesClientHeight: previewPages.clientHeight,
            pagesScrollHeight: previewPages.scrollHeight
          });
        }
        lockPreviewViewportHeight("after-render");
      }

      function getExamLabel(examKey) {
        const row = EXAM_META.find(item => item.key === examKey);
        return row ? row.label : "";
      }

      function getGradeLabel(gradeValue) {
        const row = GRADE_OPTIONS.find(function (item) {
          return item.value === gradeValue;
        });
        return row ? row.label : String(gradeValue || "");
      }

      function getSessionDateLabel(session) {
        if (!session || typeof session !== "object") return "";
        return String(session.date || session.scheduledAt || session.title || "").trim();
      }

      function getSessionKey(session, idx) {
        const dateLabel = getSessionDateLabel(session) || `slot-${idx + 1}`;
        return `${FIXED_STUDENT_ID || "student"}::${dateLabel}::${idx}`;
      }

      function ensureSelectValue(selectEl, value, label) {
        if (!value) return;
        const hasOption = Array.from(selectEl.options).some(function (opt) {
          return opt.value === value;
        });
        if (!hasOption) {
          const option = document.createElement("option");
          option.value = value;
          option.textContent = label || value;
          selectEl.appendChild(option);
        }
        selectEl.value = value;
      }

      function normalizeSessionTabs(rawTabs) {
        const sourceTabs = Array.isArray(rawTabs) && rawTabs.length ? rawTabs : [{ type: "blank", blankText: "" }];
        return sourceTabs.map(function (raw, idx) {
          const safeRaw = raw && typeof raw === "object" ? raw : {};
          const type = safeRaw.type === "two_three" ? "two_three" : "blank";
          if (type === "two_three") {
            const words = Array.isArray(safeRaw.words) ? safeRaw.words.map(function (row) {
              const safeRow = row && typeof row === "object" ? row : {};
              return {
                word: typeof safeRow.word === "string" ? safeRow.word : "",
                meaning: typeof safeRow.meaning === "string" ? safeRow.meaning : ""
              };
            }) : [];
            const sentences = Array.isArray(safeRaw.sentences) ? safeRaw.sentences.map(function (row) {
              const safeRow = row && typeof row === "object" ? row : {};
              const sentenceCard = {
                sentence: typeof safeRow.sentence === "string" ? safeRow.sentence : ""
              };
              if (Array.isArray(safeRow.ink)) {
                sentenceCard.ink = safeRow.ink;
              };
              ensureThreeSentenceInk(sentenceCard);
              return sentenceCard;
            }) : [];
            return {
              id: idx + 1,
              type: "two_three",
              blankText: "",
              blankInk: [],
              twoThree: { words, sentences }
            };
          }
          const blankTab = {
            id: idx + 1,
            type: "blank",
            blankText: typeof safeRaw.blankText === "string" ? safeRaw.blankText : "",
            blankInk: Array.isArray(safeRaw.blankInk) ? safeRaw.blankInk : [],
            twoThree: null
          };
          ensureBlankInk(blankTab);
          return blankTab;
        });
      }

      function renderSessionList() {
        sessionList.innerHTML = "";
        SAMPLE_CLASS_SESSIONS.forEach(function (session, idx) {
          const sessionKey = getSessionKey(session, idx);
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "session-item-btn";
          if (sessionKey === selectedSessionId) {
            btn.classList.add("is-selected");
          }

          const title = document.createElement("div");
          title.className = "session-item-title";
          title.textContent = getSessionDateLabel(session) || "수업 일정";

          const mockInfo = session.mock || {};
          const meta = document.createElement("div");
          meta.className = "session-item-meta";
          meta.textContent = [
            getGradeLabel(mockInfo.grade || FOLDER),
            mockInfo.year || "",
            getExamLabel(mockInfo.examKey || "")
          ].filter(Boolean).join(" · ");

          const note = document.createElement("div");
          note.className = "session-item-note";
          note.textContent = session.note || "";

          btn.appendChild(title);
          btn.appendChild(meta);
          if (note.textContent) {
            btn.appendChild(note);
          }
          btn.addEventListener("click", function () {
            applySessionPreset(session, sessionKey);
          });
          sessionList.appendChild(btn);
        });
      }

      async function applySessionPreset(session, sessionKey) {
        if (!session || !session.mock) return;
        const mockInfo = session.mock;
        stopThreePenDrawing();

        selectedSessionId = sessionKey || "";
        selectedSessionTitle = getSessionDateLabel(session);

        ensureSelectValue(gradeSel, mockInfo.grade || FOLDER, getGradeLabel(mockInfo.grade || FOLDER));
        ensureSelectValue(yearSel, mockInfo.year, mockInfo.year);
        ensureSelectValue(examSel, mockInfo.examKey, getExamLabel(mockInfo.examKey));
        ensureSelectValue(typeSel, mockInfo.typeLabel || DEFAULT_TYPE_LABEL, mockInfo.typeLabel || DEFAULT_TYPE_LABEL);

        overlaySide = session.overlaySide === "left" ? "left" : "right";
        applyOverlaySide();

        const normalizedTabs = normalizeSessionTabs(session.tabs);
        memoTabs.length = 0;
        normalizedTabs.forEach(function (tab) {
          memoTabs.push(tab);
        });
        nextMemoTabId = memoTabs.length + 1;
        const nextIndex = Number(session.activeTabIndex);
        activeMemoTabIndex = Number.isFinite(nextIndex)
          ? Math.min(Math.max(nextIndex, 0), memoTabs.length - 1)
          : 0;
        renderActiveMemoPane();
        renderMemoTabbar();
        closeFontPopup();
        closeTabTypePopup();
        renderSessionList();
        updateTopbarStatus();
        closeSessionPopup();

        const loaded = await tryLoadPdf();
        if (session.openMemo && loaded) {
          toggleMemoOverlay(true);
        }
      }

      function updateTopbarStatus() {
        const parts = [];
        if (selectedSessionTitle) {
          parts.push(selectedSessionTitle);
        }
        const gradeLabel = gradeSel.options && gradeSel.selectedIndex >= 0
          ? gradeSel.options[gradeSel.selectedIndex].text
          : "";
        if (gradeLabel) parts.push(gradeLabel);
        if (yearSel.value) parts.push(yearSel.value);
        if (examSel.value) parts.push(getExamLabel(examSel.value));
        if (typeSel.value) parts.push(typeSel.value);
        topbarStatus.textContent = parts.length ? parts.join(" · ") : "고3 · 연도 선택";
      }

      function clearSessionSelection() {
        if (!selectedSessionId && !selectedSessionTitle) return;
        selectedSessionId = "";
        selectedSessionTitle = "";
        renderSessionList();
      }

      function setSelectOptions(selectEl, options, placeholderLabel) {
        const html = [];
        if (placeholderLabel) {
          html.push(`<option value="">${placeholderLabel}</option>`);
        }
        for (const opt of options) {
          html.push(`<option value="${opt.value}">${opt.label}</option>`);
        }
        selectEl.innerHTML = html.join("");
      }

      function buildPublicUrl(filename) {
        return `${SUPABASE_BASE}/${BUCKET}/${FOLDER}/${filename}`;
      }

      async function loadWordIndexForFile(fileInfo) {
        activeWordIndex = null;
        if (!fileInfo || !fileInfo.filename) return null;
        const indexName = String(fileInfo.filename).replace(/\.pdf$/i, ".words.json");
        if (!indexName || indexName === fileInfo.filename) return null;

        const candidates = [
          indexName,
          buildPublicUrl(indexName)
        ];

        for (let i = 0; i < candidates.length; i += 1) {
          const url = candidates[i];
          try {
            const res = await fetch(url);
            if (!res.ok) continue;
            const data = await res.json();
            const pages = data && data.pages && typeof data.pages === "object"
              ? Object.keys(data.pages).length
              : 0;
            activeWordIndex = data;
            trace("info", `word-index loaded: ${indexName} (${pages}p) from ${url}`);
            return data;
          } catch (_err) {
            // try next candidate
          }
        }

        trace("warn", `word-index not found: ${indexName}`);
        return null;
      }

      function buildFilename(grade, year, examKey, typeLabel) {
        const exam = EXAM_META.find(item => item.key === examKey);
        const type = TYPE_META.find(item => item.label === typeLabel);
        if (!exam || !type) return "";
        return `${grade}_${year}_${exam.token}${type.suffix}.pdf`;
      }

      function refreshYearExamTypeOptions() {
        const years = YEAR_CANDIDATES.slice().sort().reverse();
        setSelectOptions(
          yearSel,
          years.map(y => ({ value: y, label: y })),
          "연도 선택"
        );
        if (!yearSel.value || !years.includes(yearSel.value)) {
          yearSel.value = years.includes("2023to2024") ? "2023to2024" : (years[0] || "");
        }

        const examOptions = EXAM_META.map(meta => ({ value: meta.key, label: meta.label }));
        setSelectOptions(examSel, examOptions, "몇평 선택");
        if (!examSel.value || !examOptions.some(opt => opt.value === examSel.value)) {
          examSel.value = examOptions.some(opt => opt.value === "november")
            ? "november"
            : (examOptions[0] ? examOptions[0].value : "");
        }

        const typeOptions = TYPE_META.map(meta => ({ value: meta.label, label: meta.label }));
        setSelectOptions(typeSel, typeOptions, "유형 선택");
        if (!typeSel.value || !typeOptions.some(opt => opt.value === typeSel.value)) {
          typeSel.value = "시험지";
        }
      }

      function initializeFileMap() {
        setSelectOptions(gradeSel, GRADE_OPTIONS, "학년 선택");
        gradeSel.value = FOLDER;
        refreshYearExamTypeOptions();
        openBtn.disabled = false;
        updateTopbarStatus();
        trace("info", "mode=direct-request");
      }

      function getSelectedFileInfo() {
        const grade = gradeSel.value || FOLDER;
        const year = yearSel.value;
        const examKey = examSel.value;
        const typeLabel = typeSel.value;
        if (!grade || !year || !examKey || !typeLabel) return null;

        const filename = buildFilename(grade, year, examKey, typeLabel);
        if (!filename) return null;
        return {
          grade,
          year,
          examKey,
          typeLabel,
          filename,
          url: buildPublicUrl(filename)
        };
      }

      async function fetchPdfBlob(url) {
        const res = await fetch(url);
        if (!res.ok) {
          const err = new Error(`HTTP ${res.status}`);
          err.httpStatus = res.status;
          throw err;
        }
        return res.blob();
      }

      async function tryLoadPdf() {
        const fileInfo = getSelectedFileInfo();
        if (!fileInfo) {
          resetPdfPreviewToEmpty("선택한 조건의 PDF가 없습니다.");
          trace("warn", "selected combo is incomplete");
          return false;
        }

        openBtn.disabled = true;
        newTabBtn.hidden = true;
        lastPdfUrl = fileInfo.url;
        topbarStatus.textContent = "PDF 불러오는 중...";
        trace("info", `load start: ${fileInfo.filename}`);

        try {
          const pdfBlob = await fetchPdfBlob(fileInfo.url);
          trace("info", `download ok: ${fileInfo.filename} (${Math.round(pdfBlob.size / 1024)}KB)`);
          const wordIndex = await loadWordIndexForFile(fileInfo);
          if (wordIndex && window.pdfjsLib) {
            try {
              await renderPdfPagesWithTextLayer(pdfBlob);
            } catch (renderErr) {
              trace("warn", `word-index renderer failed -> iframe fallback: ${fileInfo.filename}`, renderErr);
              showPdfWithIframeBlob(pdfBlob);
            }
          } else {
            showPdfWithIframeBlob(pdfBlob);
          }
          if (DEBUG_SCROLL_DIAG) {
            trace("info", "diag/post-load", {
              frameHidden: previewFrame.hidden,
              pagesHidden: previewPages.hidden,
              emptyHidden: previewEmpty.hidden,
              host: getScrollHostMetrics(previewPages)
            });
          }
          newTabBtn.hidden = false;
          updateTopbarStatus();
          trace("info", `load success: ${fileInfo.filename}`);
          return true;
        } catch (err) {
          const code = Number(err && err.httpStatus);
          if (code === 400 || code === 404) {
            resetPdfPreviewToEmpty("해당 조합의 PDF가 아직 없습니다.");
            updateTopbarStatus();
            trace("warn", `missing file: ${fileInfo.filename}`);
            return false;
          }

          resetPdfPreviewToEmpty("PDF를 불러오지 못했습니다.");
          updateTopbarStatus();
          trace("error", `load failed: ${fileInfo.filename}`, err);
          return false;
        } finally {
          openBtn.disabled = false;
        }
      }

      yearSel.addEventListener("change", function () {
        clearSessionSelection();
        updateTopbarStatus();
      });

      examSel.addEventListener("change", function () {
        clearSessionSelection();
        updateTopbarStatus();
      });

      gradeSel.addEventListener("change", function () {
        clearSessionSelection();
        updateTopbarStatus();
      });

      typeSel.addEventListener("change", function () {
        clearSessionSelection();
        updateTopbarStatus();
      });

      openBtn.addEventListener("click", async function () {
        const loaded = await tryLoadPdf();
        if (loaded) {
          closePickerPopup();
        }
      });

      pickerToggleBtn.addEventListener("click", togglePickerPopup);
      pickerBackdrop.addEventListener("click", closePickerPopup);
      topbarStatus.addEventListener("click", function (event) {
        event.stopPropagation();
        toggleSessionPopup();
      });
      sessionBackdrop.addEventListener("click", closeSessionPopup);
      memoToggleBtn.addEventListener("click", function () {
        toggleMemoOverlay();
      });
      overlayCloseBtn.addEventListener("click", function () {
        toggleMemoOverlay(false);
      });
      overlayTwoFlipTriangleBtn.addEventListener("click", function (event) {
        event.stopPropagation();
        flipOverlaySide();
      });
      overlayFontOpenBtn.addEventListener("click", function (event) {
        event.stopPropagation();
        toggleFontPopup();
      });
      overlayAddTabBtn.addEventListener("click", function (event) {
        event.stopPropagation();
        toggleTabTypePopup();
      });
      overlayMemoText.addEventListener("input", saveActiveMemoText);
      blankPenToggleBtn.addEventListener("click", function () {
        setBlankPenMode();
      });
      blankPenClearBtn.addEventListener("click", function () {
        clearActiveBlankInk();
      });
      blankDrawCanvas.addEventListener("pointerdown", handleBlankPenPointerDown);
      blankDrawCanvas.addEventListener("pointermove", handleBlankPenPointerMove);
      blankDrawCanvas.addEventListener("pointerup", handleBlankPenPointerEnd);
      blankDrawCanvas.addEventListener("pointercancel", handleBlankPenPointerEnd);
      overlayFontIncBtn.addEventListener("click", function () {
        memoFontSize = Math.min(36, memoFontSize + 1);
        applyMemoFontSize();
      });
      overlayFontDecBtn.addEventListener("click", function () {
        memoFontSize = Math.max(10, memoFontSize - 1);
        applyMemoFontSize();
      });
      overlayTypeOptionBtns.forEach(function (btn) {
        btn.addEventListener("click", function () {
          const type = btn.getAttribute("data-type") || "blank";
          addMemoTab(type);
        });
      });
      overlayThreePenToggleBtn.addEventListener("click", function () {
        setThreePenMode();
      });
      overlayThreePenClearBtn.addEventListener("click", function () {
        clearActiveThreeInk();
      });
      overlayDictToggleBtn.addEventListener("click", function () {
        toggleDictPanel();
      });
      overlayDictZoomInBtn.addEventListener("click", function () {
        adjustDictZoom(1);
      });
      overlayDictZoomOutBtn.addEventListener("click", function () {
        adjustDictZoom(-1);
      });
      overlayDictOpenBtn.addEventListener("click", function () {
        const url = overlayDictOpenBtn.dataset.url || buildNaverDictUrl(lastCapturedWord);
        if (!url) return;
        window.open(url, "_blank", "noopener,noreferrer");
      });

      newTabBtn.addEventListener("click", function () {
        const target = lastBlobUrl || lastPdfUrl;
        if (!target) return;
        window.open(target, "_blank", "noopener,noreferrer");
      });

      const previewScrollHost = previewPages;
      if (previewScrollHost) {
        attachPreviewScrollDiagnostics(previewScrollHost);
        previewScrollHost.addEventListener("scroll", function () {
          lastPreviewScrollAt = Date.now();
          hideWordTooltip();
        }, { passive: true });
      }
      window.addEventListener("resize", function () {
        lockPreviewViewportHeight("resize");
        if (isBlankPenMode && getActiveBlankTab() && !overlayBlankPane.hidden) {
          redrawBlankCanvas();
        }
      });

      document.addEventListener("click", function (event) {
        const target = event.target;
        if (!(target instanceof Node)) return;

        if (!overlayFontPopup.hidden && !overlayFontPopup.contains(target) && target !== overlayFontOpenBtn) {
          closeFontPopup();
        }
        if (!overlayTabTypePopup.hidden && !overlayTabTypePopup.contains(target) && target !== overlayAddTabBtn) {
          closeTabTypePopup();
        }
        if (!sessionPopup.hidden && !sessionPopup.contains(target) && target !== topbarStatus) {
          closeSessionPopup();
        }
      });

      document.addEventListener("keydown", function (event) {
        if (event.key !== "Escape") return;
        if (!sessionPopup.hidden) {
          closeSessionPopup();
          return;
        }
        if (!pickerPopup.hidden) {
          closePickerPopup();
          return;
        }
        if (!overlayFontPopup.hidden) {
          closeFontPopup();
          return;
        }
        if (!overlayTabTypePopup.hidden) {
          closeTabTypePopup();
          return;
        }
        if (isMemoOpen()) {
          toggleMemoOverlay(false);
        }
      });

      initializeFileMap();
      renderSessionList();
      applyMemoFontSize();
      applyDictZoom();
      applyOverlaySide();
      switchMemoTab(0);
      renderMemoTabbar();
      updateTopbarStatus();
    })();
  </script>
</body>
</html>
